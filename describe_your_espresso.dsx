#######################################################################################################################
### A Decent DE1 app plugin for the DSx skin that improves the default logging / "describe your espresso"
### functionality in Insight and DSx.
###  
### INSTALLATION: 
###	    1) Ensure you have DE1 app v1.33 stable (except for fontawesome symbols, which may need to be downloaded manually) 
###			or higher, and DSx version v4.39 or higher.
###		2) Copy this file "describe_your_espresso.dsx" to the "de1_plus/skins/DSx/DSx_Plugins" folder.
###		3) Restart the app with DSx as skin.
###
### Features:
###	1) "Describe your espresso" accesible from DSx home screen with a single click, for both next and last shots.
###	2) All main description data in a single screen for easier data entry.
###		* Irrelevant options ("I weight my beans" / "I use a refractometer") are removed.
###	3) Facilitate data entry in the UI:
###		* Numeric fields can be typed directly.
###		* Keyboard return in non-multiline entries take you directly to the next field.
###		* Choose categories fields (bean brand, type, grinder, etc) from a list of all previously typed values.
###		* Star-rating system for Enjoyment
###		* Mass-modify past entered categories values at once.
###	4) Description data from previous shot can now be retrieved and modified:
###		* A summary is shown on the History Viewer page, below the profile on both the left and right shots.
###		* When that summary is clicked, the describe page is open showing the description for the past shot,
###			which can be modified.
### 5) Create a SQLite database of shot descriptions.
### 	* Populate on startup
###		* User decides what is to be stored in the database.
###		* Update whenever there are new shots or shot data changes
###		* Update on startup when a shot file has been changed on disk (TODO using a simple/fast test, some cases
###			may be undetected, review)
###		* TBD Persist profiles too (as an option)
### 6) "Filter Shot History" page callable from the history viewer to restrict the shots being shown on both 
###		left and right listboxes.
### 7) TBD Add new description data: other equipment, beans details (country, variety), detailed coffee ratings like
##		in cupping scoring sheets, etc.
### 8) Upload shot files to Miha's visualizer or other repositories with a button press.
### 9) Configuration page allows defining settings and launch database maintenance actions from within the app. 
###
### Source code available in GitHub: https://github.com/ebengoechea/dye_de1app_dsx_plugin/
### This code is released under GPLv3 license. See LICENSE file under the DE1 source folder in github.
###
### By Enrique Bengoechea <enri.bengoechea@gmail.com> 
### (with lots of copy/paste/tweak from Damian, John and Johanna's code!)
########################################################################################################################

package provide describe_your_espresso.dsx 1.15
package require sqlite3
package require http
package require tls
package require json
package require zipfs

variable version {1.15}

########################################################################################################################
### VARIABLES DECLARATIONS 

namespace eval DYE {
	variable plugin_version {1.15}
	variable plugin_file "describe_your_espresso.dsx"
	variable db_version 4
	variable min_DSx_version {4.39}
	variable min_de1app_version {1.31}
	variable settings_path "[skin_directory]/DSx_User_Set/DYE_settings.tdb"
	variable filename_clock_format "%Y%m%dT%H%M%S"
	variable friendly_clock_format "%Y/%m/%d %H:%M"
	variable debug_text {}	
	
	variable settings
	array set settings {}
		
	# DATA DICTIONARY CONVENTIONS:
	#  * The column name in the shot table or the lookup table must be identical to the array item key.
	#  * The shot_field is the variable name in the shot file, settings section. May not match the array item key in 
	#		cases like 'other_equipment'.
	#  * desc_section has to be one of bean, bean_batch, equipment, extraction or people.
	#  * data_type has to be one of text, long_text, category, numeric or date.
	variable field_lookup_whats {name name_plural short_name short_name_plural \
		desc_section db_table lookup_table db_type_column1 db_type_column2 shot_field data_type \
		min_value max_value n_decimals default_value small_increment big_increment
	}
		
	variable data_dictionary
	array set data_dictionary {
		profile_title {"Profile" "Profiles" "Profile" "Profiles" \
			"" shot "" "" "" profile_title category 0 0 0}
		bean_brand {"Beans roaster" "Beans roasters" "Roaster" "Roasters" \
			bean shot "" "" "" bean_brand category 0 0 0}
		bean_type {"Beans type" "Beans types" "Name" "Names" \
			bean shot "" "" "" bean_type category 0 50 0}
		bean_notes {"Beans notes" "Beans notes" "Note" "Notes" \
			bean_batch shot "" "" "" bean_notes long_text 0 1000 0}
		roast_date {"Roast date" "Roast dates" "Date" "Dates" \
			bean_batch shot "" "" "" roast_date date 0 0 0}
		roast_level {"Roast level" "Roast levels" "Level" "Levels" \
			bean_batch shot "" "" "" roast_level category 0 50 0}
		grinder_model {"Grinder name" "Grinder names" "Grinder" "Grinders" \
			equipment shot "" "" "" grinder_model category 0 100 0}
		grinder_setting {"Grinder setting" "Grinder settings" "Setting" "Settings" \
			equipment shot "" "" "" grinder_setting category 0 100 0}
		equipment_type {"Equipment type" "Equipment types" "Type" "Types" \
			equipment shot_equipment equipment_type "" "" other_equipment category 0 100 0}
		equipment_name {"Equipment name" "Equipment names" "Equipment" "Equipment" \
			equipment shot_equipment equipment equipment_type "" other_equipment category 0 100 0}
		equipment_setting {"Equipment setting" "Equipment settings" "Setting" "Settings" \
			equipment shot_equipment "" equipment_type equipment_name other_equipment category 0 100 0}
		grinder_dose_weight {"Dose weight" "Dose weights" "Dose" "Doses" \
			extraction shot "" "" "" grinder_dose_weight numeric 0 30 1 18 0.1 1.0}
		drink_weight {"Drink weight" "Drink weights" "Weight" "Weights" \
			extraction shot "" "" "" drink_weight numeric 0 500 1 36 1.0 10.0}
		drink_tds {"Total Dissolved Solids (TDS %)" "Total Dissolved Solids %" "TDS" "TDS" \
			extraction shot "" "" "" drink_tds numeric 0 15 2 8 0.01 0.1}
		drink_ey {"Extraction Yield (EY %)" "Extraction Yields %" "EY" "EYs" \
			extraction shot "" "" "" drink_ey numeric 0 30 2 20 0.1 1.0}	
		espresso_enjoyment {"Enjoyment (0-100)" "Enjoyments" "Enjoyment" "Enjoyment" \
			extraction shot "" "" "" espresso_enjoyment numeric 0 100 0 50 1 10}
		espresso_notes {"Notes" "Notes" "Notes" "Notes" \
			extraction shot "" "" "" espresso_notes long_text 0 1000 0}	
		my_name {"Barista" "Baristas" "Barista" "Baristas" \
			people shot "" "" "" my_name category 0 100 0 people}
		drinker_name {"Drinker" "Drinkers" "Drinker" "Drinkers" \
			people shot "" "" "" drinker_name category 0 100 0}
	}

	variable desc_text_fields {bean_brand bean_type roast_date roast_level bean_notes grinder_model grinder_setting \
		espresso_notes my_name drinker_name skin repository_links}	
#	variable desc_text_fields {bean_brand bean_type roast_date roast_level bean_notes grinder_model grinder_setting \
#		other_equipment espresso_notes my_name drinker_name skin repository_links}
	variable desc_numeric_fields {grinder_dose_weight drink_weight drink_tds drink_ey espresso_enjoyment}
	variable propagated_fields {bean_brand bean_type roast_date roast_level bean_notes grinder_model grinder_setting \
		my_name drinker_name}
#	variable propagated_fields {bean_brand bean_type roast_date roast_level bean_notes grinder_model grinder_setting \
#		other_equipment my_name drinker_name}	
	variable last_shot_desc {}	
	variable next_shot_desc {}
	variable past_shot_desc {}
	variable past_shot_desc_one_line {}
	variable past_shot_desc2 {}
	variable past_shot_desc_one_line2 {}
}

### PLUGIN WORKFLOW ###################################################################################################

# Startup the Describe Your Espresso plugin.
proc ::DYE::main {} {
	check_versions
	load_settings
	check_settings
	DB::init
	GUI::setup_aspect
	foreach ns {DE IS NUME FSH CFG SEQ MODC MENU TXT GUI} { ::DYE::${ns}::setup_ui }	
	save_settings
	
	if { [ifexists $::debugging 0] == 1 && $::android != 1 } {
		ifexists ::debugging_window_title "Decent"
		wm title . "$::debugging_window_title DYE v$::DYE::plugin_version"
	}
}
 
# Verify the minimum required versions of DE1 app & DSx skin are used, otherwise prevents startup.
proc ::DYE::check_versions {} {	
	if { [package vcompare $::DSx_settings(version) $::DYE::min_DSx_version] < 0 } {
		message_page "[translate {Plugin 'Describe Your Espreso'}] v$::DYE::plugin_version [translate requires]\
DSx v$::DYE::min_DSx_version [translate {or higher}]\r\r[translate {Current DSx version is}] $::DSx_settings(version)" \
		[translate Ok]
	}
	if { [package vcompare [package version de1app] $::DYE::min_de1app_version] < 0 } {
		message_page "[translate {Plugin 'Describe Your Espreso'}] v$::DYE::plugin_version [translate requires] \
DE1app v$::DYE::min_de1app_version [translate {or higher}]\r\r[translate {Current DE1app version is}] [package version de1app]" \
		[translate Ok]
	}	
}

# Loads settings from DYE::settings.tbd file.
proc ::DYE::load_settings {} {
	array set ::DYE::settings [encoding convertfrom utf-8 [read_binary_file $DYE::settings_path]]
}

# Ensure all settings values are defined, otherwise set them to their default values.
proc ::DYE::check_settings {} {
	variable settings
	
	if {[info exists settings(db_path)] == 0} {
		set settings(db_path) "skins/DSx/DSx_User_Set/shots.db"
	} elseif { ! [file exists "[homedir]/$settings(db_path)"] } {
		set settings(db_path) "skins/DSx/DSx_User_Set/shots.db"
	}
	
	ifexists settings(calc_ey_from_tds) on
	ifexists settings(show_shot_desc_on_home) 1
	ifexists settings(shot_desc_font_color) $::DYE::GUI::default_shot_desc_font_color
	ifexists settings(describe_from_sleep) 1
	ifexists settings(date_format) "%d/%m/%Y"
	ifexists settings(describe_icon) $DYE::GUI::symbol_cup
	ifexists settings(propagate_previous_shot_desc) 1
	ifexists settings(backup_modified_shot_files) 0
	ifexists settings(db_persist_desc) 1
	ifexists settings(db_persist_series) 0
	ifexists settings(use_stars_to_rate_enjoyment) 1
	ifexists settings(next_shot_DSx_home_coords) {500 1150}
	ifexists settings(last_shot_DSx_home_coords) {2120 1150}
	ifexists settings(github_latest_url) "https://api.github.com/repos/ebengoechea/dye_de1app_dsx_plugin/releases/latest"
	
	# Propagation mechanism 
	ifexists settings(next_modified) 0
	foreach field_name "$::DYE::propagated_fields espresso_notes" {
		if { ! [info exists settings(next_$field_name)] } {
			set settings(next_$field_name) {}
		}		
	}
	if { $settings(next_modified) == 0 } {
		if { $settings(propagate_previous_shot_desc) == 1 } {
			foreach field_name $::DYE::propagated_fields {
				set settings(next_$field_name) $::settings($field_name)
			}
			set settings(next_espresso_notes) {}
		} else {
			foreach field_name "$::DYE::propagated_fields next_espresso_notes" {
				set settings(next_$field_name) {}
			}
		}
	}
	
	ifexists settings(visualizer_url) "visualizer.coffee"
	ifexists settings(visualizer_endpoint) "api/shots/upload"
	if { ![info exists settings(visualizer_username)] } { set settings(visualizer_username) {} }
	if { ![info exists settings(visualizer_password)] } { set settings(visualizer_password) {} }
	if { ![info exists settings(last_visualizer_result)] } { set settings(last_visualizer_result) {} } 

	if { ![info exists settings(last_sync_clock)] } {
		set settings(last_sync_clock) 0
		foreach fn "analyzed inserted modified archived unarchived removed unremoved" {
			set settings(last_sync_$fn) 0
		}
	}

	set settings(version) $DYE::plugin_version
	set settings(db_version) $DYE::db_version

	# Ensure load_DSx_past_shot and load_DSx_past2_shot in DSx includes exactly all fields we need when they load the 
	# shots.  	
	if { $::settings(skin) eq "DSx" } {
		# clock drink_weight grinder_dose_weight - already included
		set ::DSx_settings(extra_past_shot_fields) {bean_brand bean_type roast_date \
roast_level bean_notes grinder_model grinder_setting drink_tds drink_ey espresso_enjoyment \
espresso_notes my_name drinker_name scentone skin beverage_type final_desired_shot_weight repository_links}	
	}
#	set ::DSx_settings(extra_past_shot_fields) {bean_brand bean_type roast_date \
#roast_level bean_notes grinder_model grinder_setting other_equipment drink_tds drink_ey espresso_enjoyment \
#espresso_notes my_name drinker_name scentone skin beverage_type final_desired_shot_weight repository_links}	
	
}

# Save settings to the DYE::settings.tbd file.
proc ::DYE::save_settings {} {
	msg "DYE: saving Describe Your Espresso settings"
	::save_DSx_array_to_file DYE::settings $DYE::settings_path
}

# Returns a string with the summary description of the current (last) shot.
# Needs the { args } as this is being used in a trace add execution.
proc ::DYE::define_last_shot_desc { args } {
	if { $::DYE::settings(show_shot_desc_on_home) == 1 } {
		if { $::settings(history_saved) == 1 } {		
			set ::DYE::last_shot_desc [shot_description_summary $::settings(bean_brand) \
				$::settings(bean_type) $::settings(roast_date) $::settings(grinder_model) \
				$::settings(grinder_setting) $::settings(drink_tds) $::settings(drink_ey) \
				$::settings(espresso_enjoyment) 3]
		} else {
			set ::DYE::last_shot_desc "\[ Shot not saved to history \]"
		}
	} else {
		set ::DYE::last_shot_desc ""
	}
}

# Hook executed after save_espresso_rating_to_history
proc ::DYE::save_espresso_to_history_hook { args } {
	if { $::settings(history_saved) == 1 } {
		msg "DYE: save_espresso_to_history_hook "
		
		::DYE::define_last_shot_desc
		
		if { $::DYE::settings(db_persist_desc) == 1 || $::DYE::settings(db_persist_series) == 1 } {
			# We need the shot data in DYE::DB::persist_shot in an array that is a bit different from ::settings,
			# e.g. "clock" is "espresso_clock" in the settings, chart series are not in ::settings but in other vars,
			# we miss the filename and the modification time, and we need to build some variables with a priority
			# (like dose may come from DSx vars or from base vars). So, rather than replicate everything, we just read
			# the just-written file, which is not highly efficient but it's very straightforward.
			set fn "[homedir]/history/[clock format $::settings(espresso_clock) -format $::DYE::filename_clock_format].shot"
			array set shot [::DYE::load_shot $fn]
			::DYE::DB::persist_shot shot $::DYE::settings(db_persist_desc) $::DYE::settings(db_persist_series) 1
		}
	}
}

# Returns a string with the summary description of the shot selected on the left side of the DSx History Viewer.
# Needs the { args } as this is being used in a trace add execution.
proc ::DYE::define_past_shot_desc { args } {
	if { $::settings(skin) eq "DSx" && [info exists ::DSx_settings(past_bean_brand)] } {
		set ::DYE::past_shot_desc [shot_description_summary $::DSx_settings(past_bean_brand) \
			$::DSx_settings(past_bean_type) $::DSx_settings(past_roast_date) $::DSx_settings(past_grinder_model) \
			$::DSx_settings(past_grinder_setting) $::DSx_settings(past_drink_tds) $::DSx_settings(past_drink_ey) \
			$::DSx_settings(past_espresso_enjoyment)]
		
		set ::DYE::past_shot_desc_one_line [shot_description_summary $::DSx_settings(past_bean_brand) \
			$::DSx_settings(past_bean_type) $::DSx_settings(past_roast_date) $::DSx_settings(past_grinder_model) \
			$::DSx_settings(past_grinder_setting) $::DSx_settings(past_drink_tds) $::DSx_settings(past_drink_ey) \
			$::DSx_settings(past_espresso_enjoyment) 1 ""]
	} else {
		set ::DYE::past_shot_desc ""
		set ::DYE::past_shot_desc_one_line ""
	}
}

# Returns a string with the summary description of the shot selected on the right side of the DSx History Viewer. 
# Needs the { args } as this is being used in a trace add execution.
proc ::DYE::define_past_shot_desc2 { args } {
	if { $::settings(skin) eq "DSx" } {
		if {$::DSx_settings(history_godshots) == "history" && [info exists ::DSx_settings(past_bean_brand2)] } {
			set ::DYE::past_shot_desc2 [shot_description_summary $::DSx_settings(past_bean_brand2) \
				$::DSx_settings(past_bean_type2) $::DSx_settings(past_roast_date2) $::DSx_settings(past_grinder_model2) \
				$::DSx_settings(past_grinder_setting2) $::DSx_settings(past_drink_tds2) $::DSx_settings(past_drink_ey2) \
				$::DSx_settings(past_espresso_enjoyment2)]
			
			set ::DYE::past_shot_desc_one_line2 [shot_description_summary $::DSx_settings(past_bean_brand2) \
				$::DSx_settings(past_bean_type2) $::DSx_settings(past_roast_date2) $::DSx_settings(past_grinder_model2) \
				$::DSx_settings(past_grinder_setting2) $::DSx_settings(past_drink_tds2) $::DSx_settings(past_drink_ey2) \
				$::DSx_settings(past_espresso_enjoyment2) 1 ""]
		} else {
			set ::DYE::past_shot_desc2 ""
			set ::DYE::past_shot_desc_one_line2 ""
		}
	} else {
		set ::DYE::past_shot_desc2 ""
		set ::DYE::past_shot_desc_one_line2 ""
	}
}

# Returns a string with the summary description of the next shot.
# Needs the { args } as this is being used in a trace add execution.
proc ::DYE::define_next_shot_desc { args } {
	if { $::DYE::settings(show_shot_desc_on_home) == 1 && [info exists ::DYE::settings(next_bean_brand)] } {
		set desc [shot_description_summary $::DYE::settings(next_bean_brand) \
			$::DYE::settings(next_bean_type) $::DYE::settings(next_roast_date) $::DYE::settings(next_grinder_model) \
			$::DYE::settings(next_grinder_setting) {} {} {} 2 "\[Tap to describe the next shot\]" ]
		if { $::DYE::settings(next_modified) == 1 } { append desc " *" }
		set ::DYE::next_shot_desc $desc
	} else {
		set ::DYE::next_shot_desc ""
	}
}

# Returns a 2 or 3-lines formatted string with the summary of a shot description.
proc ::DYE::shot_description_summary { {bean_brand {}} {bean_type {}} {roast_date {}} {grinder_model {}} \
		{grinder_setting {}} {drink_tds 0} {drink_ey 0} {espresso_enjoyment 0} {lines 2} \
		{default_if_empty "Tap to describe this shot" }} {
	set shot_desc ""

	set beans_items [list_remove_element [list $bean_brand $bean_type $roast_date] ""]
	set grinder_items [list_remove_element [list $grinder_model $grinder_setting] ""]
	set extraction_items {}
	if {$drink_tds > 0} { lappend extraction_items "[translate TDS] $drink_tds\%" }
	if {$drink_ey > 0} { lappend extraction_items "[translate EY] $drink_ey\%" }
	if {$espresso_enjoyment > 0} { lappend extraction_items "[translate Enjoyment] $espresso_enjoyment" }
	
	set each_line {}
	if {[llength $beans_items] > 0} { lappend each_line [string trim [join $beans_items " "]] }
	if {[llength $grinder_items] > 0} { lappend each_line [string trim [join $grinder_items " \@ "]] }
	if {[llength $extraction_items] > 0} { lappend each_line [string trim [join $extraction_items ", "]] }
			
	if { $lines == 1 } {
		set shot_desc [join $each_line " \- "]
	} elseif { $lines == 2 } {
		if {[llength $each_line] == 3} {
			set shot_desc "[lindex $each_line 0] \- [lindex $each_line 1]\n[lindex $each_line 2]"
		} else {
			set shot_desc [join $each_line "\n"] 
		}
	} else {
		set shot_desc [join $each_line "\n"]
	}

	if {$shot_desc eq ""} { 
		set shot_desc "\[[translate $default_if_empty]\]" 
	}  		
	return $shot_desc
}

# Looks up fields metadata in the data dictionary. 'what' can be a list with multiple items, then a list is returned.
proc ::DYE::field_lookup { field {what name} } {
	if { $field eq "" } return
	if { ![info exists ::DYE::data_dictionary($field)] } { 
		msg "DYE: ERROR data field '$field' unmatched in proc field_lookup"
		return {} 		
	}
	
	set result {}
	foreach whatpart $what {
		set match_idx [lsearch -all $::DYE::field_lookup_whats $whatpart]
		if { $match_idx == -1 } { 
			msg "DYE: ERROR what item '$whatpart' unmatched in proc field_lookup"
			lappend result {}
		} else {
			lappend result [lindex $::DYE::data_dictionary($field) $match_idx]
		}
	}

	if { [llength $result] == 1 } { set result [lindex $result 0] }
	return $result
}

# Loads from a shot file the data we use in the DYE plugin. Returns an array.
# Input can be a filename, with or without .shot extension, a clock value, or a full path to a shot file.
proc ::DYE::load_shot { filename } {
	set path [get_shot_file_path $filename]
	if { $path eq "" } return
	
	msg "DYE: loading shot file $path"
	array set shot_data {}
	array set file_props  [encoding convertfrom utf-8 [read_binary_file $path]]
	
	if { [file tail [file dirname $path]] eq "history_archive" } {
		set shot_data(comes_from_archive) 1
	} else {
		set shot_data(comes_from_archive) 0
	}

	set shot_data(path) $path
	set shot_data(filename) [file rootname [file tail $path]]
	set shot_data(file_modification_date) [file mtime $path]
	set shot_data(clock) $file_props(clock)
	set shot_data(date_time) [clock format $file_props(clock) -format {%a, %d %b %Y   %I:%M%p}]
	
	if {[llength [ifexists file_props(espresso_elapsed)]] > 0} {
		set shot_data(espresso_elapsed) $file_props(espresso_elapsed)
		set shot_data(extraction_time) [round_to_one_digits [expr ([lindex $file_props(espresso_elapsed) end]+0.05)]]
	} else {
		set shot_data(espresso_elapsed) {0.0}
		set shot_data(extraction_time) 0.0
	}
	
	foreach field_name {espresso_pressure espresso_weight espresso_flow espresso_flow_weight \
			espresso_temperature_basket espresso_temperature_mix espresso_flow_weight_raw espresso_water_dispensed \
			espresso_temperature_goal espresso_pressure_goal espresso_flow_goal espresso_state_change } {
		if { [info exists file_props($field_name)] } {
			set shot_data($field_name) $file_props($field_name)
		} else {
			set shot_data($field_name) {0.0}
		}
	}
	
	array set file_sets $file_props(settings)
	
	set text_fields $::DYE::desc_text_fields
	lappend text_fields profile_title skin beverage_type
	foreach field_name $text_fields {
		if { [info exists file_sets($field_name)] == 1 } {
			set shot_data($field_name) [string trim $file_sets($field_name)]
		} else {
			set shot_data($field_name) {}
		}
	}
	
	foreach field_name $::DYE::desc_numeric_fields {
		if { [info exists file_sets($field_name)] == 1 && $file_sets($field_name) > 0 } {
			set shot_data($field_name) $file_sets($field_name)
		} else {
			# We use {} instead of 0 to get DB NULLs and empty values in entry textboxes
			set shot_data($field_name) {}
		}
	}

	if { $shot_data(grinder_dose_weight) eq "" } {
		if {[info exists file_sets(DSx_bean_weight)] == 1} {
			set shot_data(grinder_dose_weight) $file_sets(DSx_bean_weight)
		} elseif {[info exists file_sets(dsv4_bean_weight)] == 1} {
			set shot_data(grinder_dose_weight) $file_sets(dsv4_bean_weight)
		} elseif {[info exists file_sets(dsv3_bean_weight)] == 1} {
			set shot_data(grinder_dose_weight) $file_sets(dsv3_bean_weight)
		} elseif {[info exists file_sets(dsv2_bean_weight)] == 1} {
			set shot_data(grinder_dose_weight) $file_sets(dsv2_bean_weight)
		}
	}
	
	return [array get shot_data]
}

# Builds a full path to a filename and returns the path if the file exists, otherwise an empty string.
# If the filename happens to be an integer number, it is assumed it's a clock rather than a filename, and it is
#	transformed to a shot filename.
# If the filename does not have ".shot" extension, adds it.
# If the filename is already a full path and the file exists, returns it. If it's just the filename, checks
# 	existence of file first in history folder, then in history_archive folder.
proc ::DYE::get_shot_file_path { filename } {
	if { [string is integer $filename] } {
		set filename "[clock format $filename -format $::DYE::filename_clock_format].shot"
	} elseif { [string range $filename end-4 end] ne ".shot" } { append filename ".shot" }
	
	if { [file dirname $filename] eq "." } {
		if { [file exists "[homedir]/history/$filename"] } {
			return "[homedir]/history/$filename"
		} elseif { [file exists "[homedir]/history_archive/$filename"] } {
			return "[homedir]/history_archive/$filename"
		}
	} elseif { [file exists $filename] } {
		return $filename
	} 
	
	return ""
}

# Reads a shot file, modifies the settings that are defined in arr_new_settings, and optionally backups the old file 
# 	before modifying and updates the file in disk. Returns the string with the text that is/would be written to disk.
# This is normally called with write_file=1, but can be invoked with write_file=0 only to use the return string,
# 	for example for Visualizer uploads.
# Multivalued settings such as parts of "other_equipment" are flagged with a "~" initial character and are handled differently:  
#	~equipment_X (X=type/name/setting): a 2-items list with the old and new equipment value to replace in the 'other_equipment' list.
		
proc ::DYE::modify_shot_file { path arr_new_settings { backup_file {} } { write_file 1 } } {
	upvar $arr_new_settings new_settings
	if { $backup_file eq {} } {
		set backup_file $::DYE::settings(backup_modified_shot_files)
	}
	set path [get_shot_file_path $path]
	
	array set past_props [encoding convertfrom utf-8 [read_binary_file $path]] 
	array set past_sets $past_props(settings)
	array set past_mach $past_props(machine)

	foreach key [array names new_settings] {
		if { [string range $key 0 0] eq "~" } {
			if { $key eq "~equipment_type" } {
				if { [llength $new_settings($key)] == 2 && [info exists past_sets(other_equipment)] } {
					#set old_value $past_sets(other_equipment)
					set new_settings(other_equipment) [modify_other_equipment $past_sets(other_equipment) [string range $key 1 9999] \
						[lindex $new_settings($key) 0] [lindex $new_settings($key) 1]]  
					set key other_equipment
				} else {
					msg "DYE: new_settings($key)='$new_settings($key)' malformed or other_equipment doesn't exist, when modifying shot file '[file tail $path]'"
					continue
				}
			} elseif { $key eq "~equipment_name" } { 
				if { [llength $new_settings($key)] == 3 && [info exists past_sets(other_equipment)] } {
					#set old_value $past_sets(other_equipment)
					set new_settings(other_equipment) [modify_other_equipment $past_sets(other_equipment) [string range $key 1 9999] \
						[lindex $new_settings($key) 0] [lindex $new_settings($key) 1] [lindex $new_settings($key) 2]]  
					set key other_equipment
				} else {
					msg "DYE: new_settings($key)='$new_settings($key)' malformed or other_equipment doesn't exist, when modifying shot file '[file tail $path]'"
					continue
				}
			} elseif { $key eq "~equipment_settting" } { 
				if { [llength $new_settings($key)] == 4 && [info exists past_sets(other_equipment)] } {
					#set old_value $past_sets(other_equipment)
					set new_settings(other_equipment) [modify_other_equipment $past_sets(other_equipment) [string range $key 1 9999] \
						[lindex $new_settings($key) 0] [lindex $new_settings($key) 1] [lindex $new_settings($key) 2] [lindex $new_settings($key) 3]]  
					set key other_equipment
				} else {
					msg "DYE: new_settings($key)='$new_settings($key)' malformed or other_equipment doesn't exist, when modifying shot file '[file tail $path]'"
					continue
				}								
			} else {
				msg "DYE: key $key in new_settings not recognized when modifying shot file '[file tail $path]'"
				continue 
			}
			
			if { [info exists past_sets($key)] } {
				msg "DYE: Modified $key from '$past_sets($key)' to '$new_settings($key)' in shot file '[file tail $path]'"
			} else {
				msg "DYE: Added new $key='$new_settings($key)' in shot file '[file tail $path]'"
			}			
		} elseif { [info exists past_sets($key)] } {			
			#set old_value $past_sets($key)
			msg "DYE: Modified $key from '$past_sets($key)' to '$new_settings($key)' in shot file '[file tail $path]'"
		} else {
			#set old_value {}
			msg "DYE: Added new $key='$new_settings($key)' in shot file '[file tail $path]'"
		}
		
		set past_sets($key) $new_settings($key)
	}
	
	set espresso_data {}

	# Sort the variables in the first part of the file exactly as in the original. 
	set default_pars {clock espresso_elapsed espresso_pressure espresso_weight espresso_flow espresso_flow_weight \
		espresso_flow_weight_raw espresso_temperature_basket espresso_temperature_mix espresso_water_dispensed \
		espresso_pressure_goal espresso_flow_goal espresso_temperature_goal}
	set past_props_keys [array names past_props]	
	foreach k $default_pars {
		if { [lsearch $past_props_keys $k] > -1 } {
			set v $past_props($k)
			append espresso_data [subst {[list $k] [list $v]\n}]
		}
	}	
	
	# Check if there's any variable in the first shot section not in our default list and add it afterwards.
	set past_props_keys [list_remove_element $past_props_keys settings]
	set past_props_keys [list_remove_element $past_props_keys machine]
	foreach k $past_props_keys {
		if { [lsearch $default_pars $k] == -1 } {
			set v $past_props($k)
			append espresso_data [subst {[list $k] [list $v]\n}]
		}
	}

	append espresso_data "settings {\n"
	foreach k [lsort -dictionary [array names past_sets]] {
		set v $past_sets($k)
		append espresso_data [subst {\t[list $k] [list $v]\n}]
	}
	append espresso_data "}\n"

	append espresso_data "machine {\n"
	foreach k [lsort -dictionary [array names past_mach]] {
		set v $past_mach($k)
		append espresso_data [subst {\t[list $k] [list $v]\n}]
	}
	append espresso_data "}\n"

	if { $write_file == 1 && $backup_file == 1 } {
		set backup_path [string range $path 0 end-5].bak
		if {[file exists $backup_path]} { file delete $backup_path }
		file rename $path $backup_path
	}
	if { $write_file == 1 } {
		write_file $path $espresso_data
		msg "DYE: Updated past espresso history file $path"
	}
	
	return $espresso_data	
}

# Takes a list of other_equipment containing 3-tuples {{name} {type} {setting}} and modify the requested modify_type
# (which has to be one of 'equipment_type'/'type', 'equipment_name'/'equipment'/'name' or 'equipment_setting'/'setting') matching old_value to new_value.
# Returns the modified list.
proc ::DYE::modify_other_equipment { other_equipment modify_type old_value new_value {equipment_type {}} {equipment_name {}} } {
	#msg "DYE DEBUG: CALL modify_other_equipment '$other_equipment' '$modify_type' '$old_value' '$new_value' '$equipment_type' '$equipment_name'"
	if { [llength $other_equipment] < 3 } { return $other_equipment }

	if { $modify_type eq "equipment" || $modify_type eq "equipment_name" || $modify_type eq "name"} {
		set modify_type name
		set start 0
	} elseif { $modify_type eq "equipment_type" || $modify_type eq "type" } {
		set modify_type type
		set start 1
	} elseif { $modify_type eq "equipment_setting" || $modify_type eq "setting" } {
		set modify_type setting
		set start 2
	} else {
		msg "DYE ERROR: modify_type $modify_type not recognized in DYE::modify_other_equipment"
		return $other_equipment
	}
		
	for {set i $start} { $i < [llength $other_equipment] } {incr i 3} {
		set value [lindex $other_equipment $i]		
		if { $value eq $old_value } {
			if { $modify_type eq "type" } {
				set other_equipment [lreplace $other_equipment $i $i $new_value]
			} elseif { $modify_type eq "name" } {
				if { [lindex $other_equiment [expr {$i+1}]] eq $equipment_type } {
					set other_equipment [lreplace $other_equipment $i $i $new_value]
				}				
			} elseif { $modify_type eq "setting" } {
				if { [lindex $other_equiment [expr {$i-1}]] eq $equipment_type && \
						[lindex $other_equiment [expr {$i-2}]] eq $equipment_name } {
					set other_equipment [lreplace $other_equipment $i $i $new_value]
				}								
			}
		}
	}
	
	return $other_equipment	
}

### GENERAL UTILITIES #################################################################################################

# Adds a named option "-option_name option_value" to a named argument list if the option doesn't exist in the list.
# Returns the option value.
proc ::DYE::args_add_option_if_not_exists { proc_args option_name option_value } {
	upvar $proc_args largs	
	if { [string range $option_name 0 0] ne "-" } { set option_name "-$option_name" }
	set opt_idx [lsearch -exact $largs $option_name]
	if {  $opt_idx == -1 } {
		lappend largs $option_name $option_value
	} else {
		set option_value [lindex $largs [expr {$opt_idx+1}]]
	}
	return $option_value
}

# Removes the named option "-option_name" from the named argument list, if it exists.
proc ::DYE::args_remove_option { proc_args option_name } {
	upvar $proc_args largs
	if { [string range $option_name 0 0] ne "-" } { set option_name "-$option_name" }	
	set option_idx [lsearch -exact $largs $option_name]
	if { $option_idx > -1 } {
		if { $option_idx == [expr {[llength $largs]-1}] } {
			set value_idx $option_idx 
		} else {
			set value_idx [expr {$option_idx+1}]
		}
		set largs [lreplace $largs $option_idx $value_idx]
	}
}

# Returns 1 if the named arguments list has a named option "-option_name".
proc ::DYE::args_has_option { proc_args option_name } {
	if { [string range $option_name 0 0] ne "-" } { set option_name "-$option_name" }	
	set n [llength $proc_args]
	set option_idx [lsearch -exact $proc_args $option_name]
	return [expr {$option_idx > -1 && $option_idx < [expr {$n-1}]}]
}

# Returns the value of the named option in the named argument list
proc ::DYE::args_get_option { proc_args option_name {default_value {}} {rm_option 0} } {
	upvar $proc_args largs	
	if { [string range $option_name 0 0] ne "-" } { set option_name "-$option_name" }
	set n [llength $largs]
	set option_idx [lsearch -exact $largs $option_name]
	if { $option_idx > -1 && $option_idx < [expr {$n-1}] } {
		set result [lindex $largs [expr {$option_idx+1}]]
		if { $rm_option == 1 } {
			set largs [lreplace $largs $option_idx [expr {$option_idx+1}]]
		}
	} else {
		set result $default_value
	}	
	return $result
}

# Extracts from args all pairs whose key start by the prefix. And returns the extracted named options in a new
# args list that contains the pairs, with the prefix stripped from the keys. 
# For example, "-label_fill X" will return "-fill X" if prefix="-label_", and args will be emptied.
proc ::DYE::args_extract_prefixed { proc_args prefix } {
	upvar $proc_args largs
	set new_args {}
	set n [expr {[string length $prefix]-1}]
	set i 0 
	while { $i < [llength $largs] } { 
		if { [string range [lindex $largs $i] 0 $n] eq $prefix } {
			lappend new_args "-[string range [lindex $largs $i] 7 9999]"
			lappend new_args [lindex $largs [expr {$i+1}]]
			set largs [lreplace $largs $i [expr {$i+1}]]
		} else {
			incr i 2
		}
	}
	return $new_args
}

proc ::DYE::keypress_is_number_or_dot {keyvalue} {
	# set ::DYE::debug_text "PRESSED \"$keyvalue\""
	return [expr { [string is integer $keyvalue] || $keyvalue eq "period" } ]
}

proc ::DYE::keypress_is_number_or_slash {keyvalue} {
	#set ::DYE::debug_text "PRESSED \"$keyvalue\""
	return [expr { [string is integer $keyvalue] || $keyvalue eq "slash" } ]
}

proc ::DYE::return_blank_if_zero {in} {
	if {$in == 0} { return {} }
	return $in
}

# Replaces ::web_browser while John considers adding the code for it to work under windows.
proc ::DYE::web_browser {url} {
	msg "Browser '$url'"
	if { $::android == 1 } {
		borg activity android.intent.action.VIEW $url text/html
	} elseif { $::tcl_platform(platform) eq "windows" } {
		eval exec [auto_execok start] $url
	}
}

# A TEMPORAL COPY OF THE visualizer plugin upload proc, until it promotes to stable and can be invoked directly.	
proc ::DYE::visualizer_upload {content} {
	msg "uploading shot"
	borg toast "Uploading Shot"
	set ::DYE::settings(last_visualizer_result) {}
	
	set content [encoding convertto utf-8 $content]

	http::register https 443 [list ::tls::socket -servername $::DYE::settings(visualizer_url)]

	set username $::DYE::settings(visualizer_username)
	set password $::DYE::settings(visualizer_password)

	set auth "Basic [binary encode base64 $username:$password]"
	set boundary "--------[clock seconds]"
	set type "multipart/form-data, charset=utf-8, boundary=$boundary"
	set headerl [list Authorization "$auth"]

	set url "https://$::DYE::settings(visualizer_url)/$::DYE::settings(visualizer_endpoint)"
	
	set contentHeader "Content-Disposition: form-data; name=\"file\"; filename=\"file.shot\"\r\nContent-Type: application/octet-stream\r\n"
	set body "--$boundary\r\n$contentHeader\r\n$content\r\n--$boundary--\r\n"

	if {[catch {
		set token [http::geturl $url -headers $headerl -method POST -type $type -query $body -timeout 30000]
		set status [http::status $token]
		set answer [http::data $token]
		set returncode [http::ncode $token]
		set returnfullcode [http::code $token]
	} err] != 0} {
		msg "Could not upload shot! $err"
		borg toast "Upload failed!"
		set ::DYE::settings(last_visualizer_result) "[translate {Upload failed}]: $err"
		
		catch { http::cleanup $token }
		return
	}
			
	msg "DYE Visualizer Upload: token: $token, status: $status, answer: $answer, returncode=$returncode, returnfullcode=$returnfullcode"
	if {$returncode == 401} {
		msg "DYE Visualizer Upload failed. Unauthorized"
		borg toast [translate "Authentication failed: Please check username / password"]
		set ::DYE::settings(last_visualizer_result) "[translate {Authentication failed}]: [translate {Please check username / password}]"
		http::cleanup $token
		return
	}
	if {[string length $answer] == 0 || $returncode != 200} {
		msg "DYE Visualizer Upload failed: $returnfullcode, $answer"
		borg toast [translate "Upload failed"]
		set ::DYE::settings(last_visualizer_result) "[translate {Upload failed}]: $returnfullcode"
		http::cleanup $token
		return
	}

	borg toast "Upload successful"

	if {[catch {
		set response [::json::json2dict [http::data $token]]
		set uploaded_id [dict get $response id]
	} err] != 0} {
		msg "Upload failed: Unexpected server answer $answer"
		set ::DYE::settings(last_visualizer_result) "[translate {Upload failed}]: [translate {Unexpected server answer}]"
		http::cleanup $token
		return
	}

	set ::DYE::settings(last_visualizer_result) "[translate {Upload successful}]"
	http::cleanup $token
	return $uploaded_id
}

# Queries GitHub repository for the latest released version and returns a 3-elements list 
# 	{ <tag (version number)> <release_url> <release_description> }.
# If there's an error or the data can't be donwloaded, returns {-1 {} <error_description> }
proc ::DYE::github_latest_release { { url {}} } {
	if { $url eq "" } {
		set url $::DYE::settings(github_latest_url)
		if { $url eq "" } { return [list -1 "" [translate "No GitHub URL"]] }
	}
	
	::http::register https 443 ::tls::socket
	
	if {[catch {
		set token [::http::geturl $url -timeout 10000]
		set status [::http::status $token]
		set answer [::http::data $token]
		set ncode [::http::ncode $token]
		set code [::http::code $token]
		::http::cleanup $token
	} err] != 0} {
		set my_err "Could not get latest release from GitHub"
		msg "DYE: $my_err : $err"
		say [translate "Download failed"] ""
		catch { ::http::cleanup $token }
		return [list -1 "" [translate $my_err]]
	}
	
	if { $status eq "ok" && $ncode == 200 } {
		if {[catch {
			set response [::json::json2dict $answer]
			set release_url [dict get $response zipball_url]
			set release_desc [dict get $response body]
			set release_version [dict get $response tag_name]
		} err] != 0} {
			set my_err "Unexpected GitHub server answer"
			msg "DYE: $my_err : $answer"
			say [translate "Download failed"] ""
			return [list -1 "" [translate $my_err]]
		}
		
		regsub "^v(.+)$" $release_version "\\1" release_version
		return [list $release_version $release_url $release_desc]
	} else {
		set my_err "Could not get latest release from GitHub"
		msg "DYE: $my_err : $code"
		say [translate "Download failed"] ""
		return [list -1 "" [translate $my_err]]
	}
}

# Downloads a release ZIP file from GitHub (default to latest), extracts $plugin_file from it and copies it to the 
# DSx plugin folders, replacing the current plugin file if it exists. Returns 1 if successful, 0 otherwise.
proc ::DYE::update_DSx_plugin_from_github { plugin_file { release_url {}} { save_backup 1 } } {
	if { $release_url eq "" } {
		set release [::DYE::github_latest_release]
		if { [llength $release] == 3 } { 
			set release_url [lindex $release 1]
		} else {
			return 0
		}
	}

	::http::register https 443 ::tls::socket
	
	if {[catch {
		set token [::http::geturl $release_url -timeout 30000]
		set status [::http::status $token]
		set meta [::http::meta $token]
		set ncode [::http::ncode $token]
		set code [::http::code $token]
		::http::cleanup $token
	} err] != 0} {
		msg "DYE: Could not get latest release ZIP answer from GitHub! $err"
		say [translate "Download failed"] ""
		catch { ::http::cleanup $token }
		return 0
	}
	
	set zip_url {}
	if { $status eq "ok" && $ncode == 302} {
		if {[catch {
			set zip_url [dict get $meta Location]
		} err] != 0} {
			msg "DYE: Unexpected meta format from GitHub! $err"
			say [translate "Download failed"] ""
			return 0
		}			
	} else {
		msg "DYE: Could not get latest release from GitHub! $code"
		say [translate "Download failed"] ""
		return 0	
	}
	
	set zip_path "[skin_directory]/DSx_User_Set/latest_plugin.zip"
	set zip_fn [file tail $zip_path]
	if { [file exists $zip_path] } { 
		file delete $zip_path
	}
	
	::decent_http_get_to_file $zip_url $zip_path
	
	if { [file exists $zip_path] } {
		if {[catch {
			cd "[skin_directory]/DSx_User_Set"
			set mnt_point [zipfs::mount $zip_path __zip]
		} err] != 0} {
			msg "DYE: Could not get uncompress ZIP or unexpected ZIP contents: $err"
			say [translate "Download failed"] ""
			catch { zipfs::unmount $zip_path }
			catch { file delete $zip_path } 
			return 0
		}
		
		cd __zip
		set dir_name [glob *]
		
		if { [llength $dir_name] == 1 && [file isdirectory $dir_name] } {
			cd $dir_name
								
			if { [zipfs exists $plugin_file] } {
				set current_plugin_path "[skin_directory]/DSx_Plugins/${plugin_file}"
				if { $save_backup == 1 && [file exists $current_plugin_path] } {
					set backup_path "[skin_directory]/DSx_Plugins/[file rootname $plugin_file]_previous.off"
					file copy -force $current_plugin_path $backup_path
				}
				file copy -force $plugin_file "[skin_directory]/DSx_Plugins/${plugin_file}" 
			} else {
				msg "DYE: Could not find plugin file inside ZIP: $err"
				say [translate "Download failed"] ""
				catch { zipfs unmount $zip_path }
				catch { file delete $zip_path }
				return 0
			}
		} else {
			msg "DYE: Donwloaded ZIP does not have the expected structure: $err"
			say [translate "Download failed"] ""
			catch { zipfs unmount $zip_path }
			catch { file delete $zip_path }
			return 0
		}

		catch { zipfs unmount $zip_path }
		catch { file delete $zip_path }		
		return 1
	} else {
		msg "DYE: Could not download ZIP file"
		say [translate "Download failed"] ""
		return 0
	}
}

### DYE GRAPHICAL USER INTERFACE PROCEDURES ###########################################################################

namespace eval DYE::GUI {
	variable pages {}
	
	# Use the GUI widgets array to store the references to widgets created by DYE in non-DYE pages (for skin integration) 
	variable widgets
	array set widgets {}
		
	variable page_bg_image {}
	# button 1 is medium-size button for done/cancel actions
	variable button1_img {}
	variable button1_width 220
	variable button1_height 140	
	# button 2 is big-size button for icon+explanation actions (such as "Calc EY from TDS") 
	variable button2_img {}	
	variable button2_width 384
	variable button2_height 192
	# button 3 is small-size button used for the filter icon in the History Viewer
	variable button3_img {}
	variable button3_width 0
	variable button3_height 0
			
	variable bg_color {}
	variable font_color {}
	variable default_shot_desc_font_color {#206ad4}
	variable page_title_color {}
	variable remark_color {}
	variable error_color {}
	variable disabled_color {}
	variable highlight_color {}
	variable insert_bg_color {}
	
	variable font {}
	variable font_size 7
	variable header_font_size 11
	
	variable symbol_filter "\uf0b0"
	variable symbol_people "\uf500"
	variable symbol_plug "\uf1e6"
	variable symbol_cup "\uf0f4"
	variable symbol_sort_down "\uf0dd"
	variable symbol_file_upload "\uf574"
	variable symbol_file_import "\uf56f"
	variable symbol_file_contract "\uf56c"
	variable symbol_cloud_download_alt "\uf381"
	variable symbol_plus "\uf067"	
	variable symbol_eraser "\uf12d"
	variable symbol_pencil "\uf303"
	variable symbol_circle "\uf111"
	variable symbol_circle_right "\uf138"
	variable symbol_circle_left "\uf137"
	variable symbol_circle_up "\uf331"
	variable symbol_circle_down "\uf32d"
	variable symbol_circle_times "\uf057"
	variable symbol_circle_check "\uf058"
	variable symbol_square "\uf0c8"
	variable symbol_square_check "\uf14a"
	variable symbol_paintbrush "\uf5a9"
	variable symbol_db "\uf1c0"
	variable symbol_sync "\uf021"
	variable symbol_star "\uf005"
	variable symbol_half_star "\uf089"
	variable symbol_bars "\uf0c9"
	variable symbol_window_close "\uf410"
	variable symbol_chevron_left "\uf053"
	variable symbol_chevron_double_left "\uf323"
	variable symbol_arrow_to_left "\uf33e"
	variable symbol_chevron_right "\uf054"
	variable symbol_chevron_double_right "\uf324"
	variable symbol_arrow_to_right "\uf340"
	
	# Used to map booleans to their checkbox representation (square/square_check) in fontawesome.
	variable checkbox_symbols_map {"\uf0c8" "\uf14a"}
		
	variable db_progress_msg {}
}

# Setup the general aspect parameters (colors, fonts etc.) depending on the skin used.
proc ::DYE::GUI::setup_aspect { } {
	load_font fontawesome_reg_big "[homedir]/fonts/Font Awesome 5 Pro-Regular-400.otf" 55
	load_font fontawesome_reg_medium "[homedir]/fonts/Font Awesome 5 Pro-Regular-400.otf" 40
	load_font fontawesome_reg_small "[homedir]/fonts/Font Awesome 5 Pro-Regular-400.otf" 24
	
#	set ::DYE::GUI::fontawesome_reg_small [DSx_load_font fontawesome_reg_small "$::DSx_settings(font_dir)/Font Awesome 5 Pro-Regular-400.oft" 24]
#	set ::DYE::GUI::fontawesome_reg_medium [DSx_load_font fontawesome_reg_medium "$::DSx_settings(font_dir)/Font Awesome 5 Pro-Regular-400.oft" 40]
#	set ::DYE::GUI::fontawesome_reg_big [DSx_load_font fontawesome_reg_big "$::DSx_settings(font_dir)/Font Awesome 5 Pro-Regular-400.oft" 55]
#	set ::DYE::GUI::fontawesome_solid_small [DSx_load_font fontawesome_solid_small "$::DSx_settings(font_dir)/Font Awesome 5 Pro-Solid-900.oft" 24]	
	#load_font fontawesome_solid_small "[homedir]/fonts/Font Awesome 5 Pro-Solid-900.otf" 24
	
	
	if { $::settings(skin) eq "DSx" } {
		variable page_bg_image "[skin_directory_graphics]/background/$::DSx_settings(bg_name)"
		variable button1_img "[skin_directory_graphics]/icons/button4.png"
		variable button2_img "[skin_directory_graphics]/icons/button8.png"
		variable button3_img "[skin_directory_graphics]/icons/store_button.png"
		variable bg_color $::DSx_settings(bg_colour)
		variable font_color $::DSx_settings(font_colour)
		variable page_title_color $::DSx_settings(heading_colour)
		variable remark_color $::DSx_settings(orange)
		variable error_color $::DSx_settings(red)
		variable disabled_color "#535353"
		variable highlight_color $::DSx_settings(font_colour)
		variable insert_bg_color $::DSx_settings(orange)
		#variable text_font $font
		variable text_font_size 7
		variable page_title_size 11
	} else {
		message_page [translate "DSx skin is required to run the Describe Your Espresso plugin"] "Ok"
	}
}
	
# Setup the plugin User Interface integration with other DSx pages.
proc ::DYE::GUI::setup_ui { } {
	variable widgets 
	
	### DE1APP SPLASH PAGE ###
#	add_de1_variable "splash" 1280 1200 -justify center -anchor "center" -font [DSx_font font 12] \
#		-fill $::DYE::settings(orange) -textvariable {$::DYE::GUI::db_progress_msg}

	### DSx HOME PAGE ###
	# Shortcuts menu (EXPERIMENTAL)
	if { [info exists ::debugging] && $::debugging == 1 } {
		add_de1_text "$::DSx_standby_pages" 100 60 -font fontawesome_reg_small -fill $::DYE::GUI::font_color \
			-anchor "nw" -text $::DYE::GUI::symbol_bars
		add_de1_button "$::DSx_standby_pages" { ::DYE::MENU::load_page } 70 40 175 150
	}
	
	# Icon and summary of next shot description below the profile & specs for next shot (left side)
	set x [lindex $::DYE::settings(next_shot_DSx_home_coords) 0]
	set y [lindex $::DYE::settings(next_shot_DSx_home_coords) 1]
	if { $x > 0 && $y > 0 } {
		add_de1_text "$::DSx_standby_pages" [expr {$x-360}] [expr {$y-35}] -font fontawesome_reg_small \
			-fill $::DYE::GUI::font_color -anchor "nw" -text $::DYE::settings(describe_icon)
		set ::DYE::next_shot_desc [::DYE::define_next_shot_desc]
		set widgets(DSx_home_next_shot_desc) [add_de1_variable "$::DSx_standby_pages" $x $y -justify center \
			-anchor "center" -font [DSx_font font 6] -fill $::DYE::settings(shot_desc_font_color) \
			-width [rescale_x_skin 500] -textvariable {$::DYE::next_shot_desc} ] 
		add_de1_button "$::DSx_standby_pages" { ::DYE::DE::load_page next } [expr {$x-400}] [expr {$y-75}] \
			[expr {$x+250}] [expr {$y+75}]
	}
	
	# Icon and summary of the current (last) shot description below the shot chart and steam chart (right side)
	set x [lindex $::DYE::settings(last_shot_DSx_home_coords) 0]
	set y [lindex $::DYE::settings(last_shot_DSx_home_coords) 1]
	if { $x > 0 && $y > 0 } {
		add_de1_text "$::DSx_standby_pages" [expr {$x+300}] [expr {$y-35}] -font fontawesome_reg_small \
			-fill $::DSx_settings(font_colour) -anchor "nw" -text $::DYE::settings(describe_icon)
		set ::DYE::last_shot_desc [::DYE::define_last_shot_desc]
		set widgets(DSx_home_last_shot_desc) [add_de1_variable "$::DSx_standby_pages" $x $y -justify center \
			-anchor "center" -font [DSx_font font 6] -fill $::DYE::settings(shot_desc_font_color) \
			-width [rescale_x_skin 500] -textvariable {$::DYE::last_shot_desc} ]
		add_de1_button "$::DSx_standby_pages" { 
			if { $::settings(history_saved) == 1 && [info exists ::DSx_settings(live_graph_time)] } {
				::DYE::DE::load_page current
			} 		
			} [expr {$x-300}] [expr {$y-75}] [expr {$x+400}] [expr {$y+75}]
	}
	
	# Update the describe settings to the "next" ones when the a shot is started 
	trace add execution ::reset_gui_starting_espresso enter ::DYE::DE::reset_gui_starting_espresso_enter_hook
	trace add execution ::reset_gui_starting_espresso leave ::DYE::DE::reset_gui_starting_espresso_leave_hook
	
	### HISTORY VIEWER PAGE ###
	# Show espresso summary description (beans, grind, TDS, EY and enjoyment), and make it clickable to show to full
	# espresso description.
	set widgets(DSx_past_shot_desc) [add_de1_variable "DSx_past" 40 850 -text "" -font [DSx_font font 7] \
		-fill $::DYE::settings(shot_desc_font_color) -anchor "nw" -justify left -width [rescale_x_skin 1100] \
		-textvariable {$::DYE::past_shot_desc} ]
	add_de1_button "DSx_past" { 
		if { [ifexists ::DSx_settings(past_shot_file) ""] ne "" } { ::DYE::DE::load_page past } 		
		} 40 850 1125 975
		
	set widgets(DSx_past_shot_desc2) [add_de1_variable "DSx_past" 1300 850 -text "" -font [DSx_font font 7] \
		-fill $::DYE::settings(shot_desc_font_color) -anchor "nw" -justify left -width [rescale_x_skin 1100] \
		-textvariable {$::DYE::past_shot_desc2}]
	add_de1_button "DSx_past" { 
		if { [ifexists ::DSx_settings(past_shot_file2) ""] ne "" } { ::DYE::DE::load_page past2 }
		} 1300 850 2400 975

	# Update left and right side shot descriptions when they change
	trace add execution ::load_DSx_past_shot {leave} { ::DYE::define_past_shot_desc }
	trace add execution ::load_DSx_past2_shot {leave} { ::DYE::define_past_shot_desc2 }
	trace add execution ::clear_graph {leave} { ::DYE::define_past_shot_desc2 }	
	
	# Search/filter button for left side
	add_de1_image "DSx_past" 935 1390 "[skin_directory_graphics]/icons/store_button.png"
	add_de1_text "DSx_past" 977 1473 -font fontawesome_reg_small \
		-fill $::DSx_settings(font_colour) -anchor "nw" -text $::DYE::GUI::symbol_filter
	add_de1_variable "DSx_past" 1066 1495 -font [DSx_font font 7] -fill $::DSx_settings(font_colour) -anchor "center" \
		-justify "center" -textvariable {$::DYE::FSH::data(left_filter_status)} 
	add_de1_button "DSx_past" { 
		if { $::DYE::FSH::data(left_filter_status) eq "on" } {
			set ::DYE::FSH::data(left_filter_status) "off"
			unset -nocomplain ::DSx_filtered_past_shot_files
			fill_DSx_past_shots_listbox
		} else {
			::DYE::FSH::load_page
		}
		} 935 1400 1120 1575

	# Search/filter button for right side
	add_de1_image "DSx_past" 1435 1390 "[skin_directory_graphics]/icons/store_button.png"
	add_de1_text "DSx_past" 1477 1473 -font fontawesome_reg_small \
		-fill $::DSx_settings(font_colour) -anchor "nw" -text $::DYE::GUI::symbol_filter
	add_de1_variable "DSx_past" 1566 1495 -font [DSx_font font 7] -fill $::DSx_settings(font_colour) -anchor "center" \
		-justify "center" -textvariable {$::DYE::FSH::data(right_filter_status)}
	add_de1_button "DSx_past" { 
		if { $::DYE::FSH::data(right_filter_status) eq "on" } {
			set ::DYE::FSH::data(right_filter_status) "off"
			unset -nocomplain ::DSx_filtered_past_shot_files2
			fill_DSx_past2_shots_listbox
		} else {
			::DYE::FSH::load_page 
		}
		} 1435 1400 1620 1575

	### FULL PAGE CHARTS FROM HISTORY VIEWER ###
	set widgets(DSx_past_zoomed_shot_desc) [add_de1_variable "DSx_past_zoomed" 1280 1535 -font [DSx_font font 7] \
		-fill $::DYE::settings(shot_desc_font_color) \
		-anchor "center" -justify center -width [rescale_x_skin 2200] \
		-textvariable {$::DYE::past_shot_desc_one_line}]
	set widgets(DSx_past_zoomed_shot_desc2) [add_de1_variable "DSx_past2_zoomed" 1280 1535 -font [DSx_font font 7] \
		-fill $::DYE::settings(shot_desc_font_color) \
		-anchor "center" -justify center -width [rescale_x_skin 2200] \
		-textvariable {$::DYE::past_shot_desc_one_line2}]
	trace add execution ::history_godshots_switch leave ::DYE::DE::history_godshots_switch_leave_hook
	
	### SCREENSAVER ###
	# Makes the left side of the app screensaver clickable so that you can describe your last shot without waking up 
	# the DE1. Note that this would overlap with the DSx plugin management option, if enabled. Provided by Damian.
	if { $::DYE::settings(describe_from_sleep) == 1} {
		set sleep_describe_symbol $::DYE::settings(describe_icon)
		set sleep_describe_button_coords {230 0 460 230}
	} else { 
		set sleep_describe_symbol ""
		set sleep_describe_button_coords {0 0 0 0}
	}
	set widgets(describe_from_sleep_symbol) [add_de1_text "saver" 275 35 -font fontawesome_reg_big \
		-fill $::DSx_settings(font_colour) -anchor "nw" -text $sleep_describe_symbol]	
	set widgets(describe_from_sleep_button) [add_de1_button "saver" { ::DYE::DE::load_page current 1 } \
		{*}$sleep_describe_button_coords]
	
	### DEBUG TEXT IN SOME PAGES ###
	# Show the debug text variable. Set it to any value I want to see on screen at the moment.
	if { $::DSx_skindebug == 1 } {
		add_de1_variable "$::DYE::GUI::pages DSx_past $::DSx_standby_pages" \
			20 20 -font [DSx_font font 7] -fill $::DSx_settings(orange) -anchor "nw" -textvariable {$::DYE::debug_text}
		#-textvariable {enjoyment=$::DYE::DE::data(espresso_enjoyment)}
		
		# Debug button/text to do some debugging action (current to go straight to the ::DYE::DE page)
		# TODO This is not working. Console hides in background as soon as focus is given to anything, and cannot
		#	get it back.
		#add_de1_text "$::DSx_home_pages" 2300 225 -font [DSx_font font 7] -fill $::DSx_settings(orange) -anchor "nw" \
		#	-text "CONSOLE"
		#add_de1_button "$::DSx_standby_pages" { catch { console hide } \
		# 	console show; set DYE_window {[focus -displayof .can]} } 2250 220 2500 280		
	}	
}

# Call this on the page "load_page" namespace proc, before the actual page_show call.
proc ::DYE::GUI::set_previous_page { ns } {
	set prev_page $::de1(current_context)
	if { $prev_page eq "::DYE::MENU" } {
		set prev_page $::DYE::MENU::data(previous_page)
	}
	set "${ns}::data(previous_page)" $prev_page
}

proc ::DYE::GUI::get_font { font size } {
	
}
	
proc ::DYE::GUI::page_name_is_namespace { page_name } {
	return [expr {[string range $page_name 0 1] eq "::" && [info exists ${page_name}::widgets]}]
}

# "Smart" widget names selector. If 'ns' is specified, looks for the widgets in ::DYE::<ns>::widgets(<widget_name>),
#	otherwise assumes 'widgets' directly references the widgets names.
# If a namespace 'ns' is provided, and a widget_name final character is a "*", tries to find all "related" widgets
#	with that name, namely those with suffix "_label", "_state", "_symbol", "_img" and "_button".
# Also, if the widget_name ends in "_rating*", tries to find _rating_button, _rating1, _rating_half1, etc.
proc ::DYE::GUI::select_widgets { widgets {ns {}} } {
	set result {}
	if { $ns eq "" } { 
		foreach wn $widgets {
			if { $wn ne "" && [info exists $wn] } { 
				lappend result $wn  
			} else {
				msg "DYE ERROR: select_widgets - can't find widget '$wn'"
			}
		}
	} else {
		foreach wn $widgets {
			if { [string range $wn end end] eq "*" } {
				set some_found 0
				if { [string range $wn end-7 end] eq "_rating*"} {
					set wn [string range $wn 0 end-1]					
					if { [info exists "${ns}::widgets(${wn}_button)"] } {
						lappend result [subst \$${ns}::widgets(${wn}_button)]
						set some_found 1
						set i 1
						while { [info exists "${ns}::widgets(${wn}$i)"] } {
							lappend result [subst \$${ns}::widgets(${wn}$i)]
							if { [info exists "${ns}::widgets(${wn}_half$i)"] } {
								lappend result [subst \$${ns}::widgets(${wn}_half$i)]
							}
							incr i
						}
					}
				} else {
					set wn [string range $wn 0 end-1]
					
					foreach subtype "{} _label _symbol _img _button _state _clicker _clicker_img" {
						if { [info exists "${ns}::widgets(${wn}$subtype)"] } {
							lappend result [subst \$${ns}::widgets(${wn}$subtype)]
							set some_found 1
						}
					}
				}
				if { $some_found == 0 } {
					msg "DYE ERROR: select_widgets - can't find any widget variable ${ns}::widgets($wn)"
				}
			} else {
				if { [info exists "${ns}::widgets($wn)"] } {
					lappend result [subst \$${ns}::widgets($wn)]
				} else {
					msg "DYE ERROR: select_widgets - can't find widget variable ${ns}::widgets($wn)"
				}
			}
		}
	}
	return $result
}
	
# "Smart" widgets disabler. 
# For text, changes its fill color to the default or provided disabled color.
# For other widgets like rectangle "clickable" button areas, disables them.
# Does nothing if the widget is hidden. 
proc ::DYE::GUI::disable_widgets { widgets {ns {}} { disabled_color {}} } {
	::DYE::GUI::enable_or_disable_widgets 0 $widgets $ns {} $disabled_color
		
#	if { $disabled_color eq "" } { set disabled_color $::DYE::GUI::disabled_color }
# 
#	foreach wn [::DYE::GUI::select_widgets $widgets $ns] {		
##		set wc ""; catch { append wc [winfo class widget] }
##		msg "DYE disabling widget $wn - class $wc"
#		# DE1 prefixes: text / image / .btn			
#		if { [string range $wn 0 3] eq "text" } {
#			if { [.can itemconfig $wn -state] ne "hidden" } { .can itemconfig $wn -fill $disabled_color }
#		} elseif { [string range $wn 0 3] eq ".btn" } {
#			if { [.can itemconfig $wn -state] ne "hidden" } { .can itemconfig $wn -state disabled }
#		} elseif { [string range $wn 0 5] eq ".can.w"} {
#			if { [$wn cget -state] ne "hidden" } { $wn configure -state disabled }
#		}
#	}
#		
#	update
}

# "Smart" widgets enabler. 
# For text, changes its fill color to the default or provided font color.
# For other widgets like rectangle "clickable" button areas, enables them.
# Does nothing if the widget is hidden.
proc ::DYE::GUI::enable_widgets { widgets {ns {}} { enabled_color {} } } {
	::DYE::GUI::enable_or_disable_widgets 1 $widgets $ns $enabled_color {}
#	if { $enabled_color eq "" } { set enabled_color $::DYE::GUI::font_color }
#	
#	foreach wn [::DYE::GUI::select_widgets $widgets $ns] {		
#		# DE1 prefixes: text / image / .btn			
#		set wt [string range $wn 0 3]
#		if { [string range $wn 0 3] eq "text" } {
#			if { [.can itemconfig $wn -state] ne "hidden" } { .can itemconfig $wn -fill $enabled_color }
#		} elseif { [string range $wn 0 3] eq ".btn" } {
#			if { [.can itemconfig $wn -state] ne "hidden" } { .can itemconfig $wn -state normal }
#		} elseif { [string range $wn 0 5] eq ".can.w"} {
#			if { [$wn cget -state] ne "hidden" } { $wn configure -state normal }
#		}
#	}
#	
#	update
}

proc ::DYE::GUI::enable_or_disable_widgets { enabled widgets {ns {}} { enabled_color {}} { disabled_color {} } } {
	if { $enabled_color eq "" } { set enabled_color $::DYE::GUI::font_color }
	if { $disabled_color eq "" } { set disabled_color $::DYE::GUI::disabled_color }
	
	if { $enabled == 0 } {
		set color $disabled_color
		set state disabled
	} else {
		set color $enabled_color
		set state normal
	}
 
	foreach wn [::DYE::GUI::select_widgets $widgets $ns] {		
#		set wc ""; catch { append wc [winfo class widget] }
#		msg "DYE disabling widget $wn - class $wc"
		# DE1 prefixes: text / image / .btn			
		if { [string range $wn 0 3] eq "text" } {
			if { [.can itemconfig $wn -state] ne "hidden" } { .can itemconfig $wn -fill $color }
		} elseif { [string range $wn 0 3] eq ".btn" } {
			if { [.can itemconfig $wn -state] ne "hidden" } { .can itemconfig $wn -state $state }
		} elseif { [string range $wn 0 5] eq ".can.w"} {
			if { [$wn cget -state] ne "hidden" } { $wn configure -state $state }
		}
	}
	
	update		
} 

# "Smart" widgets hider. 
# If 'contex' is provided, only hides or shows if that context is currently active.
proc ::DYE::GUI::hide_widgets { widgets {ns {}} { context {}} } {
	if { $context ne "" && $context ne $::de1(current_context) } return
	
	foreach wn [::DYE::GUI::select_widgets $widgets $ns] {		
		.can itemconfig $wn -state hidden
	}
		
	update
}

# "Smart" widgets shower. 
# If 'contex' is provided, only hides or shows if that context is currently active.
proc ::DYE::GUI::show_widgets { widgets {ns {}} { context {} } } {
	if { $context ne "" && $context ne $::de1(current_context) } return
	
	foreach wn [::DYE::GUI::select_widgets $widgets $ns] {		
		.can itemconfig $wn -state normal
	}
	
	update
}
		
# Adds a standard DYE dialog page to the DE1 GUI.
# New named options:
#	* -title: The page title. If not defined, uses variable <namespace>::data(page_title). A widget named "page_title"
#		is added to the namespace widgets array.
#   * -add_bg_img: Whether to add the background image, default 1. Use 0 if the page needs to be initialized in some
#		other way, like for DSx configuration pages carousel.
#	* -done_button: 0 or 1 (default), to include a "done" button. This will call a "<namespace>::page_done" command 
#	* -cancel_button: 0 or 1 (default), to include a "cancel" button. This will call a "<namespace>::page_cancel" command
#	* -buttons_loc: one of "left", "center" or "right" (default).
proc ::DYE::GUI::add_page { page args } {		
	array set opts $args
	set has_ns [page_name_is_namespace $page]

	if { [ifexists opts(-add_bg_img) 1] == 1 } {
		add_de1_image $page 0 0 $::DYE::GUI::page_bg_image
	}
	if { $has_ns } {
		set "${page}::data(page_name)" $page
		lappend ::DYE::GUI::pages $page
	}
	
	if { [info exists opts(-title)] } {
		set w [::add_de1_text $page 1280 60 \
			-font [DSx_font font $::DYE::GUI::header_font_size] \
			-fill $::DYE::GUI::page_title_color -anchor "center" -text $opts(-title)]
		if { $has_ns } { set "${page}::widgets(page_title)" $w }
	} elseif { $has_ns && [info exists ${page}::data(page_title)] } {
		set "${page}::widgets(page_title)" [::add_de1_variable $page 1280 60 \
			-font [DSx_font font $::DYE::GUI::header_font_size] -fill $::DYE::GUI::page_title_color \
			-anchor "center" -textvariable [subst {\$${page}::data(page_title)}] ]
	}
	
	set done_button 1
	if { [info exists opts(-done_button)] && $opts(-done_button) == 0 } { set done_button 0 }
	set cancel_button 1
	if { [info exists opts(-cancel_button)] && $opts(-cancel_button) == 0 } { set cancel_button 0 }  
	
	if { !$done_button && !$cancel_button } return
	
	set y 1425
	if { [info exists opts(-buttons_loc)] && $opts(-buttons_loc) eq "center" } {
		if { $done_button && $cancel_button } {
			set x_cancel [expr {1280-[rescale_x_skin $::DYE::GUI::button2_width]-75}]
			set x_done [expr {1280+75}]
		} elseif { $done_button } {
			set x_done [expr {1280-[rescale_x_skin $::DYE::GUI::button2_width]/2}]
		} elseif { $cancel_button } {
			set x_cancel [expr {1280-[rescale_x_skin $::DYE::GUI::button2_width]/2}]
		}
	} elseif { [info exists opts(-buttons_loc)] && $opts(-buttons_loc) eq "left" } {
		if { $done_button && $cancel_button } {
			set x_cancel 100
			set x_done 400
		} elseif { $done_button } {
			set x_done 100
		} elseif { $cancel_button } {
			set x_cancel 100
		}
	} else {
		if { $done_button && $cancel_button } {
			set x_cancel 1900
			set x_done 2200
		} elseif { $done_button } {
			set x_done 2200
		} elseif { $cancel_button } {
			set x_cancel 2200
		}
	}
	
	if { $cancel_button } {
		::DYE::GUI::add_cancel_button $page $x_cancel $y ${page}::page_cancel
	}
	if { $done_button } {
		::DYE::GUI::add_done_button $page $x_done $y ${page}::page_done
	}
}

# Adds a Cancel button to a page. Two widgets called "cancel_text" and "cancel_button" are added to the namespace 
#	widgets array, and the "cancel_button" widget is returned.
proc ::DYE::GUI::add_cancel_button { page x y { command {} } { text {Cancel} } } {	
	set has_ns [page_name_is_namespace $page]
	set width $::DYE::GUI::button1_width
	set height $::DYE::GUI::button1_height
	
	set w [ add_de1_image $page $x $y $::DYE::GUI::button1_img ]
	if { $has_ns } { set "${page}::widgets(cancel_img)" $w }
	set w [add_de1_text $page \
		[expr {$x + ($width / 2)}] [expr {$y + ($height / 2) - 4}] \
		-font [DSx_font font 10] -fill $::DYE::GUI::font_color -anchor "center" \
		-text [translate $text]]
	if { $has_ns } { set "${page}::widgets(cancel_text)" $w }
	
	set widget [add_de1_button $page $command $x $y [expr {$x + $width}] [expr {$y + $height}]]
	if { $has_ns } { set "${page}::widgets(cancel_button)" $widget }
	return $widget
}

# Adds an Ok / Done button to a page. Two widgets called "done_text" and "done_button" are added to the namespace 
#	widgets array, and the "done_button" widget is returned.
proc ::DYE::GUI::add_done_button { page x y { command {} } { text {Done} } } {
	set has_ns [page_name_is_namespace $page]
	set width $::DYE::GUI::button1_width
	set height $::DYE::GUI::button1_height
	
	set w [::add_de1_image $page $x $y $::DYE::GUI::button1_img ]
	if { $has_ns } { set "${page}::widgets(done_img)" $w }
	set w [::add_de1_text $page [expr {$x + ($width / 2)}] [expr {$y + ($height / 2) - 4}] \
		-font [DSx_font font 10] -fill $::DYE::GUI::font_color -anchor "center" -text [translate $text]]
	if { $has_ns } { set "${page}::widgets(done_text)" $w }
	
	set widget [::add_de1_button $page $command $x $y [expr {$x + $width}] [expr {$y + $height}]]
	if { $has_ns } { set "${page}::widgets(done_button)" $widget }
	return $widget 
}

# Adds a button1 (the same as used for the Done/Cancel)
proc ::DYE::GUI::add_button1 { page widget_name x y label command args } {
	set has_ns [page_name_is_namespace $page]
	set width $::DYE::GUI::button1_width
	set height $::DYE::GUI::button1_height
	
	DYE::args_add_option_if_not_exists args -font [DSx_font font 10]
	DYE::args_add_option_if_not_exists args -fill $::DYE::GUI::font_color
	DYE::args_add_option_if_not_exists args -anchor "center"
	
	set w [::add_de1_image $page $x $y $::DYE::GUI::button1_img]
	if { $has_ns } { set "${page}::widgets(${widget_name}_img)" $w }
	if { $label ne "" } {
		set w [::add_de1_text $page [expr {$x + ($width / 2)}] [expr {$y + ($height / 2) - 4}] \
			-text [translate $label] {*}$args ]
		if { $has_ns } { set "${page}::widgets(${widget_name}_label)"  $w }
	}
	
	set widget [::add_de1_button $page $command $x $y [expr {$x + $width}] [expr {$y + $height}]]
	if { $has_ns } { set "${page}::widgets(${widget_name}_button)" $widget }
	return $widget 	
}
	
# Adds a button2 (the big buttons on DSx History Viewer).
# The button can have any of the following 3 components:
#	* label: Main text
#	* state_variable: Variable with the status text, which is shown in a smaller size, below the label. 
#		For showing states like on/off. If the value is.
#	* symbol: A fontawesome symbol shown on the left third of the button
# Adds to the namespace widgets array <widget_name> (clickable button area, returned by the function), 
#	<widget_name>_symbol, <widget_name>_label and <widget_name>_state.
# New named options_
#	-label_fill, -symbol_fill, -state_fill the font color of each element.
proc ::DYE::GUI::add_button2 { page widget_name x y label state_variable symbol {command {}} args } {
	set has_ns [page_name_is_namespace $page]
	set width $::DYE::GUI::button2_width
	set height $::DYE::GUI::button2_height
	
	set label_fill [DYE::args_get_option args -label_fill $::DYE::GUI::font_color 1]
	set symbol_fill [DYE::args_get_option args -symbol_fill $::DYE::GUI::font_color 1]
	set state_fill [DYE::args_get_option args -state_fill $::DYE::GUI::font_color 1]
	
	set w [::add_de1_image $page $x $y $::DYE::GUI::button2_img ]
	if { $has_ns } { set "${page}::widgets(${widget_name}_img)" $w } 

	if { $symbol eq "" } {
		set x_label [expr {$x+$width/2}]
		set x_state [expr {$x+$width/2}]
	} else {
		set x_label [expr {$x+$width*2/3}]
		set x_state [expr {$x+$width*2/3}]
	}
	if { $state_variable eq "" } {
		set y_label [expr {$y+$height/2}]
		set label_size 8
	} else {
		if { [regexp {[\r\n]} $label] } {
			set y_label [expr {$y+$height/3}]
			set y_state [expr {$y+$height*4/5}]
			set label_size 8
			set state_size 7
		} else {
			set y_label [expr {$y+$height/3}]
			set y_state [expr {$y+$height*2/3}]
			set label_size 8
			set state_size 8
		}
	}
	
	if { $symbol ne "" } {
		set w [::add_de1_text $page [expr {$x+$width/5}] [expr {$y+$height/2}] \
			-text [subst \$::DYE::GUI::symbol_$symbol] \
			-fill $symbol_fill -font fontawesome_reg_medium -justify "center" -anchor "center"]
		if { $has_ns } { set "${page}::widgets(${widget_name}_symbol)" $w } 
	}
	if { $label eq "" && [info exists "${page}::data(${widget_name}_label)"] } {
		set w [::add_de1_variable $page $x_label [expr {$y_label+3}] \
			-font [DSx_font font $label_size] -fill $label_fill -justify "center" -anchor "center" \
			-textvariable "\$${page}::data(${widget_name}_label)" ]
		if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
	} else {
		set w [::add_de1_text $page $x_label $y_label \
			-text $label -font [DSx_font font $label_size] -fill $label_fill -justify "center" -anchor "center"]
		if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
	}
	if { $state_variable ne "" } {
		if { $state_variable eq "auto" || $state_variable eq "1" } {
			set state_variable "\$${page}::data(${widget_name}_state)"
		}
		set w [::add_de1_variable $page $x_state $y_state \
			-font [DSx_font font $state_size] -fill $state_fill -justify "center" -anchor "center" \
			-textvariable $state_variable]
		if { $has_ns } { set "${page}::widgets(${widget_name}_state)" $w }
	}
	
	set w [::add_de1_button $page $command [expr {$x-14}] [expr {$y-12}] \
		[expr {$x+$width+10}] [expr {$y+$height+10}]]
	if { $has_ns } { set "${page}::widgets(${widget_name})" $w }
	return $w
}

# Adapted from gui.tcl "proc add_de1_button", but allowing user-defined options like fill, outline, width etc., 
# as there is not base proc to do that.
# Use -label_* to pass named options to the label. 
proc ::DYE::GUI::add_button { page widget_name x0 y0 x1 y1 label command args } {
	set has_ns [page_name_is_namespace $page]
	global button_cnt
	incr button_cnt
	set btn_name ".btn_$button_cnt"
	incr button_cnt
	set btn2_name ".btn_$button_cnt"
	
	set rx0 [rescale_x_skin $x0]
	set rx1 [rescale_x_skin $x1]
	set ry0 [rescale_y_skin $y0]
	set ry1 [rescale_y_skin $y1]
	
	DYE::args_add_option_if_not_exists args -fill $::DYE::GUI::bg_color
	DYE::args_add_option_if_not_exists args -outline $::DYE::GUI::font_color
	DYE::args_add_option_if_not_exists args -disabledoutline $::DYE::GUI::disabled_color
	DYE::args_add_option_if_not_exists args -activeoutline $::DYE::GUI::remark_color
	DYE::args_add_option_if_not_exists args -width 3

	set label_args {}
	set label_args [DYE::args_extract_prefixed args -label_]
	DYE::args_add_option_if_not_exists label_args -font [DSx_font font $::DYE::GUI::font_size] 
	DYE::args_add_option_if_not_exists label_args -fill $::DYE::GUI::font_color
	
	.can create rect $rx0 $ry0 $rx1 $ry1 -tag $btn_name -state hidden {*}$args
	if { $has_ns && $widget_name ne "" } { set "${page}::widgets(${widget_name}_button)" $btn_name }
	
	if { $label ne "" || [info exists "${page}::data(${widget_name}_label)"] } {
		set x_label [expr {$x0+($x1-$x0)/2}]
		set y_label [expr {$y0+($y1-$y0)/2}]
		
		if { $label ne "" } {			
			set w [::add_de1_text $page $x_label $y_label \
				-anchor center -justify center -text $label {*}$label_args ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
		} elseif { [info exists "${page}::data(${widget_name}_label)"] } {
			set w [::add_de1_variable $page $x_label $y_label \
				-anchor center -justify center {*}$label_args -textvariable "\$${page}::data(${widget_name}_label)" ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
		}
	}

	.can create rect $rx0 $ry0 $rx1 $ry1 -fill {} -outline black -width 0 -tag $btn2_name -state hidden
	if { $has_ns && $widget_name ne "" } { set "${page}::widgets(${widget_name})" $btn2_name }
	
	if { $command ne "" } {
		regsub {%x0} $command $rx0 command
		regsub {%x1} $command $rx1 command
		regsub {%y0} $command $ry0 command
		regsub {%y1} $command $ry1 command
		.can bind $btn2_name [platform_button_press] $command
	}

	add_visual_item_to_context $page $btn_name
	add_visual_item_to_context $page $btn2_name
	return $btn2_name
}

# Calls add_de1_text but with the DYE GUI aspect by default. Returns the created widget. 
# Named options (except the new ones described below) are passed through to add_de1_text.
# New named options:
#  -widget_name, if specified the widget is saved into the widgets array of the namespace, with name "widget_name".
#  -has_button: if 1, makes a clickable rectangular area around the symbol, with action given by -button_cmd
proc ::DYE::GUI::add_text { page x y text args } {
	set has_ns [page_name_is_namespace $page]
	set has_button [DYE::args_get_option args -has_button 0 1]
	set button_cmd [DYE::args_get_option args -button_cmd {} 1]
	set button_width [DYE::args_get_option args -button_width 200 1]
	set button_height [DYE::args_get_option args -button_height 40 1]
	
	DYE::args_add_option_if_not_exists args -font [DSx_font font $::DYE::GUI::font_size]
	DYE::args_add_option_if_not_exists args -fill $::DYE::GUI::font_color
	set anchor [DYE::args_add_option_if_not_exists args -anchor nw]
	set widget_name [DYE::args_get_option args -widget_name {} 1]
	
	set widget [::add_de1_text $page $x $y {*}$args -text $text]
	if { $has_ns && $widget_name ne "" } { set "${page}::widgets($widget_name)" $widget }
	
	if { $has_button == 1 } {
		set offset 20
		if { $anchor eq "center" } {
			set x0 [expr {$x-$button_width/2-$offset}]
			set y0 [expr {$y-$button_height/2-$offset}]
			set x1 [expr {$x+$button_width/2+$offset}]
			set y1 [expr {$y+$button_height/2+$offset}]
		} elseif { $anchor eq "ne" } {
			set x0 [expr {$x-$offset-$button_width}]
			set y0 [expr {$y-$offset-$button_height}]
			set x1 [expr {$x+$offset}]
			set y1 [expr {$y+$offset}]
		} else {
			#assume nw
			set x0 [expr {$x-$offset}]
			set y0 [expr {$y-$offset}]
			set x1 [expr {$x+$button_width+$offset}]
			set y1 [expr {$y+$button_height+$offset}]
		}
		
		set button_widget [::add_de1_button $page $button_cmd $x0 $y0 $x1 $y1]
		if { $has_ns && $widget_name ne "" } { set "${page}::widgets(${widget_name}_button)" $button_widget}
	}
	
	return $widget	
}

# Inserts a fontawesome symbol. Returns the created symbol text widget. Named arguments are passed through to add_de1_text.
# New named arguments:
#  -widget_name: if specified the widget is saved into the widgets array of the namespace, with name "widget_name".
#  -size: size of the symbol, can be one of small (default), medium or big.
#  -has_button: if 1, makes a clickable rectangular area around the symbol, with action given by -button_cmd
proc ::DYE::GUI::add_symbol { page x y symbol args } {
	set has_ns [page_name_is_namespace $page]
	DYE::args_add_option_if_not_exists args -fill $::DYE::GUI::font_color
	set anchor [DYE::args_add_option_if_not_exists args -anchor nw]
	set has_button [DYE::args_get_option args -has_button 0 1]
	set button_cmd [DYE::args_get_option args -button_cmd {} 1]
	
	set size [DYE::args_get_option args -size small 1]
	if { [info exists ::DYE::GUI::symbol_$symbol ] } {
		set text [subst \$::DYE::GUI::symbol_$symbol]
	} else {
		set text $symbol
	}
	set widget_name [DYE::args_get_option args -widget_name {} 1]
	
	set widget [::add_de1_text $page $x $y -font fontawesome_reg_$size {*}$args -text $text]
	if { $has_ns && $widget_name ne "" } { set "${page}::widgets($widget_name)" $widget }
	
	if { $has_button == 1 } {
		set offset 20
		if { $size eq "small"} { set symbol_space 65
		} elseif { $size eq "medium"} { set symbol_space 90
		} elseif { $size eq "big"} { set symbol_space 150 }
		
		if { $anchor eq "center" } {
			set x0 [expr {$x-$symbol_space/2-$offset}]
			set y0 [expr {$y-$symbol_space/2-$offset}]
			set x1 [expr {$x+$symbol_space/2+$offset}]
			set y1 [expr {$y+$symbol_space/2+$offset}]
		} elseif { $anchor eq "ne" } {
			set x0 [expr {$x-$offset-$symbol_space}]
			set y0 [expr {$y-$offset-$symbol_space}]
			set x1 [expr {$x+$offset}]
			set y1 [expr {$y+$offset}]
			
		} else { 
			#assume nw
			set x0 [expr {$x-$offset}]
			set y0 [expr {$y-$offset}]
			set x1 [expr {$x+$symbol_space+$offset}]
			set y1 [expr {$y+$symbol_space+$offset}]
		}
		
		set button_widget [::add_de1_button $page $button_cmd $x0 $y0 $x1 $y1]
		if { $has_ns && $widget_name ne "" } { set "${page}::widgets(${widget_name}_button)" $button_widget}
	}
	
	return $widget	
}

# Calls add_de1_variable but with the DYE GUI aspect by default. Returns the created widget.
# Named options (except the new ones described below) are passed through to add_de1_widget.
# New named options:
#  -widget_name: if specified the widget is saved into the widgets array of the namespace, with name "widget_name".
#  -has_button: if 1, makes a clickable rectangular area around the symbol, with action given by -button_cmd
proc ::DYE::GUI::add_variable { page x y textvariable args } {	
	set has_ns [page_name_is_namespace $page]
	
	DYE::args_add_option_if_not_exists args -font [DSx_font font $::DYE::GUI::font_size]
	DYE::args_add_option_if_not_exists args -fill $::DYE::GUI::font_color
	set anchor [DYE::args_add_option_if_not_exists args -anchor nw]
	set widget_name [DYE::args_get_option args -widget_name {} 1]

	set has_button [DYE::args_get_option args -has_button 0 1]
	set button_cmd [DYE::args_get_option args -button_cmd {} 1]
	set button_width [DYE::args_get_option args -button_width 200 1]
	set button_height [DYE::args_get_option args -button_height 40 1]
	
	set widget [::add_de1_variable $page $x $y {*}$args -textvariable $textvariable]
	if { $has_ns && $widget_name ne "" } { set "${page}::widgets($widget_name)" $widget }

	if { $has_button == 1 } {
		set offset 20
		if { $anchor eq "center" } {
			set x0 [expr {$x-$button_width/2-$offset}]
			set y0 [expr {$y-$button_height/2-$offset}]
			set x1 [expr {$x+$button_width/2+$offset}]
			set y1 [expr {$y+$button_height/2+$offset}]
		} elseif { $anchor eq "ne" } {
			set x0 [expr {$x-$offset-$button_width}]
			set y0 [expr {$y-$offset-$button_height}]
			set x1 [expr {$x+$offset}]
			set y1 [expr {$y+$offset}]
		} else {
			#assume nw
			set x0 [expr {$x-$offset}]
			set y0 [expr {$y-$offset}]
			set x1 [expr {$x+$button_width+$offset}]
			set y1 [expr {$y+$button_height+$offset}]
		}
		
		set button_widget [::add_de1_button $page $button_cmd $x0 $y0 $x1 $y1]
		if { $has_ns && $widget_name ne "" } { set "${page}::widgets(${widget_name}_button)" $button_widget}
	}
		
	return $widget
}
	
# Adds a text entry widget and its label using DYE GUI standards:
# 	Stores the entry widget in the widgets array of the namespace, and stores the data in the data array of the namespace.
# 	If field_name is specified, uses the data dictionary to automate things, such as validation
#	Named options (except the new ones described below) are passed through to add_de1_widget.
#	If -textvariable is not specified, variable ::DYE::<page>::data(field_name) is used.
# New named options: 
#	-widget_name: if not specified the widget is stored as ::DYE::<page>::widgets(field_name). Its label, if defined,
#		is stored as ::DYE::<page>::widgets(field_name_label)
#	-label: if not specified and field_name is in the data dictionary, uses the data dictionary name lookup.
#			If still blank, and <page>::data(<widget_name>_label) exists, uses it as -textvariable.
#			Use x_label=-1 & y_label=-1 to not paint a label.
#	-data_type, -n_decimals, -min_value, -max_value: all used for validation, if not specified uses the values
#		looked up in the data dictionary for $field_name.
#	-dropdown_cmd: For categories, the command to execute when tapping the dropdown arrow. If not specified,
#		launches the DYE_item_selection page to show the category field_type.
# 	-dropdown_callback_cmd: For categories, the callback command from the IS page. Defaults to ${page}::select_${field_name}_callback
#	-clicker: If not empty and the data_type is numeric, adds clicker arrows to change the value.
#		Must be a list with 3 elements, big increment, small increment, and default value on first click.
#		Use empty "-clicker {}" to take those values from the data dictionary.
#	-extra_clicker_cmd: Tcl code to be run *after* the clicker command is run. 
#	-editor_page: If 1 (default), double tapping the box will launch a dedicated editor page for the field. Currently 
#		supported for numeric data only. By default all numeric entries launch the numeric pad editor, unless 
#		editor_page=0

proc ::DYE::GUI::add_text_entry { page field_name x_label y_label x_widget y_widget width args } {
	set has_ns [page_name_is_namespace $page]
	set widget_name [DYE::args_get_option args -widget_name $field_name 1]

	# If the field name is found in the data dictionary, use its metadata unless they are provided in the proc call
	lassign [DYE::field_lookup $field_name {name data_type n_decimals min_value max_value small_increment big_increment \
		default_value}] \
		f_label f_data_type f_n_decimals f_min_value f_max_value f_small_increment f_big_increment f_default_value
	foreach fn {label data_type n_decimals min_value max_value small_increment big_increment default_value} {
		set $fn [DYE::args_get_option args "-$fn" [subst \$f_$fn] 1]
	}
	
	set textvariable [DYE::args_add_option_if_not_exists args -textvariable "${page}::data($widget_name)"]
	DYE::args_add_option_if_not_exists args -width [expr {int($width * $::globals(entry_length_multiplier))}]
	DYE::args_add_option_if_not_exists args -font [DSx_font font $::DYE::GUI::font_size]	
	set dropdown_callback_cmd [DYE::args_get_option args -dropdown_callback_cmd "${page}::select_${widget_name}_callback" 1]
	set default_dropdown_cmd "say \"select\" $::settings(sound_button_in); \
		::DYE::IS::load_page $field_name $dropdown_callback_cmd \$$textvariable"
	set dropdown_cmd [DYE::args_get_option args -dropdown_cmd $default_dropdown_cmd 1]
	set editor_page [DYE::args_get_option args -editor_page 1 1]
	
	DYE::args_add_option_if_not_exists args -justify left
	DYE::args_add_option_if_not_exists args -relief sunken
	DYE::args_add_option_if_not_exists args -borderwidth 1 
	DYE::args_add_option_if_not_exists args -bg $::DYE::GUI::bg_color
	DYE::args_add_option_if_not_exists args -highlightthickness 1
	DYE::args_add_option_if_not_exists args -highlightcolor $::DYE::GUI::font_color
	DYE::args_add_option_if_not_exists args -foreground $::DYE::GUI::font_color 
	DYE::args_add_option_if_not_exists args -insertbackground $::DYE::GUI::insert_bg_color
	DYE::args_add_option_if_not_exists args -disabledbackground $::DYE::GUI::disabled_color
	DYE::args_add_option_if_not_exists args -disabledforeground $::DYE::GUI::bg_color
	DYE::args_add_option_if_not_exists args -exportselection 1
		
	if { ![DYE::args_has_option $args -vcmd] } {
		if { $data_type eq "numeric" } {
			set vcmd "expr \{\[string trimleft %P 0\] eq \{\} || ("
			if { $n_decimals == 0 } {
				append vcmd "\[string is entier %P\] && "
			} else {
				append vcmd "\[string is double %P\] && "
			}
			if { $min_value ne "" } {
				append vcmd "\[string trimleft %P 0\] >= $min_value && "
			}
			if { $max_value ne "" } {
				append vcmd "\[string trimleft %P 0\] <= $max_value && "
			}
			set vcmd [string range $vcmd 0 end-4]
			append vcmd ")\}"
		} elseif { $data_type eq "date" } {
			set vcmd "regexp \{^\[0-9/\]\{0,10\}\$\} %P"
		} else {
			set vcmd ""
		}
		
		if { $vcmd ne "" } {
			DYE::args_add_option_if_not_exists args -vcmd $vcmd
			DYE::args_add_option_if_not_exists args -validate key
		}
	}

	if { $x_label > -1 && $y_label > -1 } {
		set label_args {}
		set label_args [DYE::args_extract_prefixed args -label_]
		DYE::args_add_option_if_not_exists label_args -font [DSx_font font $::DYE::GUI::font_size] 
		DYE::args_add_option_if_not_exists label_args -fill $::DYE::GUI::font_color
		DYE::args_add_option_if_not_exists label_args -anchor "nw"
		
		if { $label ne "" } {			
			set w [::add_de1_text $page $x_label [expr {$y_label+3}] -text $label {*}$label_args ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
		} elseif { [info exists "${page}::data(${widget_name}_label)"]} {
			set w [::add_de1_variable $page $x_label [expr {$y_label+3}] {*}$label_args \
				-textvariable "\$${page}::data(${widget_name}_label)" ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
		}
	}
	
	if { [DYE::args_has_option $args -clicker] } {
		set clicker_opts [DYE::args_get_option args -clicker "" 1]
		if { [llength $clicker_opts] > 0 } { set big_increment [lindex $clicker_opts 0] }
		if { [llength $clicker_opts] > 1 } { set small_increment [lindex $clicker_opts 1] }
		if { [llength $clicker_opts] > 2 } { set default_value [lindex $clicker_opts 2] }
				
		set extra_clicker_cmd [DYE::args_get_option args -clicker_cmd "" 1]

		if { $data_type eq "numeric" } { 
			set clicker_cmd "say \"\" \$::settings(sound_button_in); "
			if { $default_value ne "" } {
				append clicker_cmd "if \{ \$$textvariable eq \"\" \} \{ set $textvariable $default_value \};"
			}
			append clicker_cmd "horizontal_clicker $big_increment $small_increment $textvariable $min_value $max_value %x %y %%x0 %%y0 %%x1 %%y1;"

			if { $n_decimals == 0 } {
				append clicker_cmd "set $textvariable \[expr \{round(\$$textvariable)\}\];"
			}
			if { $extra_clicker_cmd ne "" } { append clicker_cmd $extra_clicker_cmd } 
			
			set w [::add_de1_image $page [expr {$x_widget-250}] [expr {$y_widget-8}] \
				 "[skin_directory_graphics]/icons/click_no_box.png"]
			if { $has_ns } { set "${page}::widgets(${widget_name}_clicker_img)" $w}
			
			set w [::add_de1_button $page $clicker_cmd \
				[expr {$x_widget-250}] [expr {$y_widget-8}] [expr {$x_widget+360}] [expr {$y_widget+75}] ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_clicker)" $w }
		}
	}
			
	set widget [::add_de1_widget $page entry $x_widget $y_widget {
			bind $widget <Return> { hide_android_keyboard ; focus [tk_focusNext %W] }
		} -exportselection 1 {*}$args ]
	
	if { $data_type eq "text" || $data_type eq "long_text" || $data_type eq "category" } {
		set leave_cmd "set $textvariable \[string trim \$$textvariable\]; hide_android_keyboard;"
	} elseif { $data_type eq "numeric" && $n_decimals > 0 } {
		set leave_cmd "if \{\$$textvariable ne \{\} \} \{ 
			set $textvariable \[format \"%%.${n_decimals}f\" \$$textvariable\] 
			\}; hide_android_keyboard;"
	} else {
		set leave_cmd "hide_android_keyboard"
	}	
	bind $widget <Leave> $leave_cmd
	
	if { $has_ns } { set "${page}::widgets($widget_name)" $widget }
	
	if { $field_name ne "" } {
		if { $data_type eq "category" } {
			set w [add_de1_text $page [expr {$x_widget+300}] [expr {$y_widget-11}] -font fontawesome_reg_small \
				-fill $::DSx_settings(font_colour) -anchor "nw" -justify "left" -text $DYE::GUI::symbol_sort_down ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_dropdown)" $w }
						 		
			set w [add_de1_button $page $dropdown_cmd [expr {$x_widget+295}] $y_widget \
				[expr {$x_widget+360}] [expr {$y_widget+68}] ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_dropdown_button)" $w }
		}
		
		
		if { $data_type eq "numeric" && $editor_page == 1 && $field_name ne "" } {
			set editor_cmd "if \{ \[$widget cget -state\] eq \"normal\" \} \{ ::DYE::NUME::load_page $field_name $textvariable \}" 
			bind $widget <Double-Button-1> $editor_cmd
		}
	}
	
	return $widget
}

# Adds a multiline text entry widget and its label using DYE GUI standards:
# 	Stores the entry widget in the widgets array of the namespace, and stores the data in the data array of the namespace.
# 	If field_name is specified, uses the data dictionary to automate things, such as validation
#	Named options (except the new ones described below) are passed through to add_de1_widget.
#	If -textvariable is not specified, variable ::DYE::<page>::data(field_name) is used.
# New named options: 
#	-widget_name: if not specified the widget is stored as ::DYE::<page>::widgets(field_name). Its label, if defined,
#		is stored as ::DYE::<page>::widgets(field_name_label)
#	-label: if not specified and field_name is in the data dictionary, uses the data dictionary name lookup.
#			If still blank, and <page>::data(<widget_name>_label) exists, uses it as -textvariable.
#			Use x_label=-1 & y_label=-1 to not paint a label.
#	-data_type, -n_decimals, -min_value, -max_value: all used for validation, if not specified uses the values
#		looked up in the data dictionary for $field_name.
# 	-dropdown_callback_cmd: For categories, the callback command from the IS page. Defaults to ${page}::select_${field_name}_callback
proc ::DYE::GUI::add_multiline_entry { page field_name x_label y_label x_widget y_widget {width 20} {height 3} args } {
	set has_ns [page_name_is_namespace $page]
	set widget_name [DYE::args_get_option args -widget_name $field_name 1]

	# If the field name is found in the data dictionary, use its metadata unless they are provided in the proc call
	lassign [DYE::field_lookup $field_name {name data_type n_decimals min_value max_value}] \
		f_label f_data_type f_n_decimals f_min_value f_max_value 	
	foreach fn {label data_type n_decimals min_value max_value} {
		set $fn [DYE::args_get_option args "-$fn" [subst \$f_$fn] 1]
	}
	
	set textvariable [DYE::args_add_option_if_not_exists args -textvariable "${page}::data($field_name)"]
	DYE::args_add_option_if_not_exists args -width [expr {int($width * $::globals(entry_length_multiplier))}]
	DYE::args_add_option_if_not_exists args -height $height
	DYE::args_add_option_if_not_exists args -font [DSx_font font $::DYE::GUI::font_size]
	set dropdown_callback_cmd [DYE::args_get_option args -dropdown_callback_cmd "${page}::select_${field_name}_callback" 1]
	set editor_page [DYE::args_get_option args -editor_page 1 1]
	
	DYE::args_add_option_if_not_exists args -relief sunken
	DYE::args_add_option_if_not_exists args -borderwidth 1 
	DYE::args_add_option_if_not_exists args -bg $::DYE::GUI::bg_color
	DYE::args_add_option_if_not_exists args -highlightthickness 1
	DYE::args_add_option_if_not_exists args -highlightcolor $::DYE::GUI::font_color
	DYE::args_add_option_if_not_exists args -foreground $::DYE::GUI::font_color 
	DYE::args_add_option_if_not_exists args -insertbackground $::DYE::GUI::insert_bg_color
	DYE::args_add_option_if_not_exists args -exportselection 1
#	DYE::args_add_option_if_not_exists args -disabledbackground $::DYE::GUI::disabled_color
#	DYE::args_add_option_if_not_exists args -disabledforeground $::DYE::GUI::bg_color
	
	if { $x_label > -1 && $y_label > -1 } {
		set label_args [DYE::args_extract_prefixed args -label_]
		DYE::args_add_option_if_not_exists label_args -font [DSx_font font $::DYE::GUI::font_size] 
		DYE::args_add_option_if_not_exists label_args -fill $::DYE::GUI::font_color
		DYE::args_add_option_if_not_exists label_args -anchor "nw"
		
		if { $label ne "" } {
			set w [::add_de1_text $page $x_label [expr {$y_label+3}] -text [translate $label] {*}$label_args ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
		} elseif { [info exists "${page}::data(${widget_name}_label)"]} {
			set w [::add_de1_variable $page $x_label [expr {$y_label+3}] \
				{*}$label_args -textvariable "\$${page}::data(${widget_name}_label)" ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
		}
	}
	
	set widget [::add_de1_widget $page multiline_entry $x_widget $y_widget {
			bind $widget <Return> { hide_android_keyboard ; focus [tk_focusNext %W] }
		} {*}$args ]
	
	if { $data_type eq "text" || $data_type eq "long_text" || $data_type eq "category" } {
		set leave_cmd "set $textvariable \[string trim \$$textvariable\]; hide_android_keyboard;"
	} else {
		set leave_cmd "hide_android_keyboard"
	}	
	bind $widget <Leave> $leave_cmd
	
	# Double-tap binding doesn't work on multiline_entry. Think of an alternative way.
#	if { $editor_page == 1 } { 
#		set editor_cmd "if \{ \[$widget cget -state\] eq \"normal\" \} \{ 
#			::DYE::TXT::load_page $field_name $textvariable 1
#		\} elseif \{ \[$widget cget -state\] eq \"disabled\" \} \{
#			::DYE::TXT::load_page $field_name $textvariable 0
#		\}"
#		bind $widget <Double-Button-1> { set ::DYE::debug_text "DBL_CLICK"; continue }
#	}
	
	if { $has_ns } { set "${page}::widgets($widget_name)" $widget }
	
	return $widget
}

# Moves the dropdown arrows (that launches the page to select a category item) to the right of all entry textboxes.
# This is needed as textbox width is defined in characters not in pixels, thus this must be invoked after the 
# initial rendering of the textbox entry, so its actual width in pixels can be computed and the dropdown arrow
# located exactly in the right spot.
# Receives the full array of page/namespace widgets and assumes a convention for the widgets names ("<field_name>" for 
# the textbox, "<field_name>_dropdown" for the dropdown arrow text label, and "<field_name>_dropdown_button" for the
# clickable button area). This is the convention followed when creating the dropdowns automatically in proc 
# ::DYE::GUI::add_text_entry.
proc ::DYE::GUI::relocate_dropdown_arrows { arr_widgets field_names } {
	upvar $arr_widgets widgets
	foreach fn $field_names {
		set coords [.can coords $widgets($fn) ]	
		set newx [expr {[winfo width $widgets($fn)] + [lindex $coords 0] + 10}]
		set newy [expr {[lindex $coords 1] - 10 }]
		.can coords $widgets(${fn}_dropdown) "$newx $newy"	
		.can coords $widgets(${fn}_dropdown_button) "[expr {$newx-5}] $newy [expr {$newx+60}] [expr {$newy+60}]"
	}
}

# Moves a widget with respect to another, i.e. to a position relative to another one.
# pos can be any of "n", "nw", "ne", "s", "sw", "se", "w", "wn", "ws", "e", "en", "es".
# xoffset and yoffset define a fixed offset with respect to the coordinates obtained from processing 'pos'. 
#	Can be positive or negative.
# anchor is how to position widget relative to the point obtained after processing pos & offsets. Takes the
#	same values as the standard -anchor option. If not defined, keeps the existing widget -anchor.
# move_too is a list of widgets that will be repositioned together with widget, maintaining the same relative
#	distances to widget as they had originally. Typically used for the rectangle "button" areas around text labels.
proc ::DYE::GUI::relocate_text_wrt { widget wrt { pos w } { xoffset 0 } { yoffset 0 } { anchor {} } { move_too {} } } {
	lassign [.can bbox $wrt ] x0 y0 x1 y1 
	lassign [.can bbox $widget ] wx0 wy0 wx1 wy1
	
	if { $pos eq "center" } {
		set newx [expr {$x0+int(($x1-$x0)/2)+$xoffset}]
		set newy [expr {$y0+int(($y1-$y0)/2)+$yoffset}]
	} else {
		set pos1 [string range $pos 0 0]
		set pos2 [string range $pos 1 1]
		
		if { $pos1 eq "w" || $pos1 eq ""} {
			set newx [expr {$x0+$xoffset}]
			
			if { $pos2 eq "n" } {
				set newy [expr {$y0+$yoffset}]
			} elseif { $pos2 eq "s" } {
				set newy [expr {$y1+$yoffset}]
			} else {
				set newy [expr {$y0+int(($y1-$y0)/2)+$yoffset}]
			}
		} elseif { $pos1 eq "e" } {
			set newx [expr {$x1+$xoffset}]
			
			if { $pos2 eq "n" } {
				set newy [expr {$y0+$yoffset}]
			} elseif { $pos2 eq "s" } {
				set newy [expr {$y1+$yoffset}]
			} else {
				set newy [expr {$y0+int(($y1-$y0)/2)+$yoffset}]
			}			
		} elseif { $pos1 eq "n" } {
			set newy [expr {$y0+$yoffset}]
			
			if { $pos2 eq "w" } {
				set newx [expr {$x0+$xoffset}]
			} elseif { $pos2 eq "e" } {
				set newx [expr {$x1+$xoffset}]
			} else {
				set newx [expr {$x0+int(($x1-$x0)/2)+$xoffset}]
			}
		} elseif { $pos1 eq "s" } {
			set newy [expr {$y1+$yoffset}]
			
			if { $pos2 eq "w" } {
				set newx [expr {$x0+$xoffset}]
			} elseif { $pos2 eq "e" } {
				set newx [expr {$x1+$xoffset}]
			} else {
				set newx [expr {$x0+int(($x1-$x0)/2)+$xoffset}]
			}
		} else return 
	}
	
	if { $anchor ne "" } {
		# Embedded in catch as widgets like rectagles don't support -anchor
		catch { .can itemconfigure $widget -anchor $anchor }
	}
	# Don't use 'moveto' as then -anchor is not acknowledged
	.can coords $widget "$newx $newy"
	
	if { $move_too ne "" } {
		lassign [.can bbox $widget] newx newy
		
		foreach w $move_too {			
			set mtcoords [.can coords $w]
			set mtxoffset [expr {[lindex $mtcoords 0]-$wx0}]
			set mtyoffset [expr {[lindex $mtcoords 1]-$wy0}]
			
			if { [llength $mtcoords] == 2 } {
				.can coords $w "[expr {$newx+$mtxoffset}] [expr {$newy+$mtyoffset}]"
			} elseif { [llength $mtcoords] == 4 } {
				.can coords $w "[expr {$newx+$mtxoffset}] [expr {$newy+$mtyoffset}] \
					[expr {$newx+$mtxoffset+[lindex $mtcoords 2]-[lindex $mtcoords 0]}] \
					[expr {$newy+$mtyoffset+[lindex $mtcoords 3]-[lindex $mtcoords 1]}]"
			}
		}
	}
	
	return "$newx $newy"
}

# Adds a listbox widget, its (optional) label and its scrollbar, using DYE GUI standards. New widgets
# 	<widget_name>, <widget_name_label>, <widget_name_scrollbar> and <widget_name_slider> are added to the namespace
# 	widgets array.
# New named options: 
#	-label: Label text. If not specified, and <page>::data(<widget_name>_label) exists, uses it as -textvariable.
#	-scrollbar_width
#	-scrollbar_height
#	-sliderlength
proc ::DYE::GUI::add_listbox { page widget_name x_label y_label x_widget y_widget width height args } {
	set has_ns [page_name_is_namespace $page]
	if { ![DYE::args_has_option $args -listvariable] && [info exists ${page}::data($widget_name)] } {
		DYE::args_add_option_if_not_exists args -listvariable "${page}::data($widget_name)"
	}
	DYE::args_add_option_if_not_exists args -font [DSx_font font $::DYE::GUI::font_size]
	DYE::args_add_option_if_not_exists args -relief flat
	DYE::args_add_option_if_not_exists args -borderwidth 1 
	DYE::args_add_option_if_not_exists args -selectborderwidth 1
	DYE::args_add_option_if_not_exists args -background $::DYE::GUI::bg_color
	DYE::args_add_option_if_not_exists args -selectbackground $::DYE::GUI::font_color
	DYE::args_add_option_if_not_exists args -selectforeground $::DYE::GUI::bg_color
	DYE::args_add_option_if_not_exists args -disabledforeground $::DYE::GUI::disabled_color
	DYE::args_add_option_if_not_exists args -highlightthickness 1
	DYE::args_add_option_if_not_exists args -highlightcolor $::DYE::GUI::font_color
	DYE::args_add_option_if_not_exists args -justify left
	DYE::args_add_option_if_not_exists args -foreground $::DYE::GUI::font_color 
	DYE::args_add_option_if_not_exists args -exportselection 0
	DYE::args_add_option_if_not_exists args -selectmode browser
	
	set scrollbar_width [rescale_y_skin [DYE::args_get_option args -scrollbar_width 75 1]]
	set scrollbar_height [rescale_x_skin [DYE::args_get_option args -scrollbar_height 75 1]]
	set sliderlength [rescale_x_skin [DYE::args_get_option args -sliderlength 100 1]]

	if { $x_label > -1 && $y_label > -1 } {
		set label [DYE::args_get_option args label "" 1]		
		set label_args [DYE::args_extract_prefixed args -label_]
		DYE::args_add_option_if_not_exists label_args -font [DSx_font font $::DYE::GUI::font_size] 
		DYE::args_add_option_if_not_exists label_args -fill $::DYE::GUI::font_color
		DYE::args_add_option_if_not_exists label_args -anchor "nw"
			
		if { $label ne "" } {
			set w [::add_de1_text $page $x_label [expr {$y_label+3}] -text [translate $label] {*}$label_args ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
		} elseif { [info exists "${page}::data(${widget_name}_label)"]} {
			set w [::add_de1_variable $page $x_label [expr {$y_label+3}] \
				{*}$label_args -textvariable "\$${page}::data(${widget_name}_label)" ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
		}
	}
	
	set widget [::add_de1_widget $page listbox $x_widget $y_widget {} \
		-height $height -width [expr {int($width * $::globals(entry_length_multiplier))}] \
		-yscrollcommand "scale_scroll ${page}::widgets(${widget_name}_slider)" -exportselection 1 {*}$args ] 
	if { $has_ns } { set "${page}::widgets($widget_name)" $widget }
	
	# Draw the scrollbar off screen so that it gets resized and moved to the right place on the first draw
	if { $has_ns } { set "${page}::widgets(${widget_name}_slider)" 0 }
	
	set w [::add_de1_widget $page scale [expr {$x_widget+10*$width}] $y_widget {} \
		-from 0 -to .50 -bigincrement 0.2 -borderwidth 1 -showvalue 0 -resolution .01 \
		-length $scrollbar_height -width $scrollbar_width -sliderlength $sliderlength \
		-variable "${page}::widgets(advsteps_$widget_name)" \
		-command " listbox_moveto \$${page}::widgets($widget_name) \$${page}::widgets(${widget_name}_slider) " \
		-background $::DYE::GUI::font_color -font [DSx_font font $::DYE::GUI::font_size] \
		-relief flat -foreground #FFFFFF -troughcolor $::DYE::GUI::bg_color -borderwidth 0  -highlightthickness 0]
	if { $has_ns } { set "${page}::widgets(${widget_name}_scrollbar)" $w }
	
	return $widget
}

# Returns the values of the selected items in a listbox. If a 'values' list is provided, returns the matching
# items in that list instead of matching to listbox entries, unless 'values' is shorter than the listbox,
# in which case indexes not reachable from 'values' are taken from the listbox values.
proc ::DYE::GUI::listbox_get_selection { widget {values {}} } {
	set cursel [$widget curselection]
	if { $cursel eq "" } return {}

	set result {}	
	set n [llength $values]
	foreach idx [$widget curselection] {
		if { $values ne "" && $idx < $n } {
			lappend result [lindex $values $idx]
		} else {
			lappend result [$widget get $idx]
		}
	}	
	
#	if { [llength $result] == 1 } {
#		return [lindex $result 0]
#	} else {
#		return $result
#	}
	return $result	
}

# Sets the selected items in a listbox, matching the string values.
# If a 'values' list is provided, 'selected' is matched against that list instead of the actual values shown in the listbox.
# If 'reset_current' is 1, clears the previous selection first.
proc ::DYE::GUI::listbox_set_selection { widget selected { values {} } { reset_current 1 } } {
	if { $selected eq "" } return
	if { $values eq "" } { 
		set values [$widget get 0 end]
	} else {
		# Ensure values has the same length as the listbox items, otherwises trim it or add the listbox items
		set ln [$widget size]
		set vn [llength $values]
		if { $ln < $vn } {
			set values [lreplace $values $ln end]
		} elseif { $ln > $vn } {
			lappend values [$widget get $vn end]
		}
	}
	
	if { $reset_current == 1 } { $widget selection clear 0 end }	
	if { [$widget cget -selectmode] eq "single" && [llength $selected] > 1 } {
		set selected [lindex $selected end]
	}
	
	
	foreach sel $selected {
		set sel_idx [lsearch -exact $values $sel]
		if { $sel_idx > -1 } { 
			$widget selection set $sel_idx 
			$widget see $sel_idx
		}
	}
}
	
# Configures a page listbox scrollbars locations and sizes. Run once the page is shown for then to be dynamically 
# positioned.
proc ::DYE::GUI::set_scrollbars_dims { page widget_names } {
	if { ![page_name_is_namespace $page] } return
	
	foreach wn $widget_names {
		set listbox_widget [subst \$${page}::widgets($wn)]
		set scrollbar_widget [subst \$${page}::widgets(${wn}_scrollbar)]
				
		# set the height of the scrollbar to be the same as the listbox
		$scrollbar_widget configure -length [winfo height $listbox_widget]
		set coords [.can coords $listbox_widget]
		set newx [expr {[winfo width $listbox_widget] + [lindex $coords 0]}]
		.can coords $scrollbar_widget "$newx [lindex $coords 1]"
	}
}

# Adds a checkbox consisting of a fontawesome square empty/check symbol plus a label text, and dynamically assigns 
# the checkbox value (0 or 1) whenever it changes to the specified namespace data variable <page>::data(<check_variable>).
# Extra named options are applied to both add_de1_text commands.
# Creates 3 widgets in namespace array <page>::widgets():
#	<check_variable>: the square symbol text. The procedure returns this widget.
#	<check_variable>_button: the "clickable" area in the square symbol text
#	<check_variable>_label: the label text
# New named options: 
#	-label: Label text. If not specified, and <page>::data(<widget_name>_label) exists, uses it as -textvariable.
#	-use_page_var: 0 if check_variable is NOT a page namespace data() variable. 1 by default.
proc ::DYE::GUI::add_checkbox { page check_variable x y {command {}} args } {
	set has_ns [page_name_is_namespace $page]
	
	set use_page_var [DYE::args_get_option args use_page_var 1 1]
	set widget_name [DYE::args_get_option args widget_name $check_variable 1]
	
	if { $use_page_var == 1 } {
		set check_variable "${page}::data($check_variable)"
		if { ! [info exists ${page}::data($check_variable)] } {
			set "$check_variable" 0
		}			
	}
	
	if { [DYE::args_has_option $args -label] } {
		set label [DYE::args_get_option args -label "" 1]
		set w [::add_de1_text $page [expr {$x+70}] [expr {$y+5}] \
			-font [DSx_font font $::DYE::GUI::font_size] \
			-fill $::DYE::GUI::font_color -anchor "nw" -text [translate $label]]
		if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
	} elseif { [info exists "${page}::data(${widget_name}_label)"]} {
		set w [::add_de1_variable $page [expr {$x+70}] [expr {$y+5}] \
			-font [DSx_font font $::DYE::GUI::font_size] \
			-fill $::DYE::GUI::font_color -anchor "nw" -textvariable "\$${page}::data(${widget_name}_label)" ]
		if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
	}
	
	set widget [::DYE::GUI::add_variable $page $x $y "\[lindex \$::DYE::GUI::checkbox_symbols_map \$$check_variable\]" \
		-widget_name $widget_name -justify left -font fontawesome_reg_small {*}$args]
	if { $has_ns } { set "${page}::widgets(${widget_name}_symbol)" $widget }
	
	set cmd "if { \$$check_variable == 1 } { set $check_variable 0 } else { set $check_variable 1 }
		$command"
		
	set w [::add_de1_button $page $cmd [expr {$x-10}] [expr {$y-2}] [expr {$x+300}] [expr {$y+65}] ]
	if { $has_ns } { set "${page}::widgets(${widget_name}_button)" $w }
	
	return $widget
}

# Adds a combo of widgets for "star ratings". Maps to any existing integer variable.
# Named options:
#	-rating_var, the variable with the ratings. If not specified, uses ${page}::data(${widget_name}) 
#	-symbol, default "star"
#	-n_ratings, default 5
#	-use_halfs, default 1
proc ::DYE::GUI::add_rating { page field_name x_label y_label x_widget y_widget width args } {
	set has_ns [page_name_is_namespace $page]
	
	set widget_name [DYE::args_get_option args -widget_name $field_name 1]
	set ratingvar [DYE::args_add_option_if_not_exists args -rating_var "${page}::data($widget_name)"]
	set n_ratings [DYE::args_get_option args -n_ratings 5 1]		
	set use_halfs [DYE::args_get_option args -use_halfs 1 1]
	set symbol [DYE::args_get_option args -symbol "star" 1]
				
	if { $use_halfs == 1 } {
		if { [info exists "::DYE::GUI::symbol_half_$symbol"] } {
			set half_symbol [subst \$::DYE::GUI::symbol_half_$symbol]
		} else {
			set half_symbol $::DYE::GUI::symbol_half_star
		}
	}		
	if { [info exists ::DYE::GUI::symbol_$symbol] } {
		set symbol [subst \$::DYE::GUI::symbol_$symbol]
	} 
		
	# If the field name is found in the data dictionary, use its metadata unless they are provided in the proc call
	lassign [DYE::field_lookup $field_name {name data_type n_decimals min_value max_value}] \
		f_label f_data_type f_n_decimals f_min_value f_max_value 	
	foreach fn {label data_type n_decimals min_value max_value} {
		set $fn [DYE::args_get_option args "-$fn" [subst \$f_$fn] 1]
	}
		
	if { $x_label > -1 && $y_label > -1 } { 
		if { $label ne "" } {
			set w [::add_de1_text $page $x_label [expr {$y_label+3}] \
				-font [DSx_font font $::DYE::GUI::font_size] -fill $::DYE::GUI::font_color -anchor "nw" \
				-text [translate $label]]
			if { $has_ns } { set "${page}::widgets(${widget_name}_rating_label)" $w }
		} elseif { [info exists "${page}::data(${widget_name}_rating_label)"]} {
			set w [::add_de1_variable $page $x_label [expr {$y_label+3}] \
				-font [DSx_font font $::DYE::GUI::font_size] \
				-fill $::DYE::GUI::font_color -anchor "nw" -textvariable "\$${page}::data(${widget_name}_label)" ]
			if { $has_ns } { set "${page}::widgets(${widget_name}_label)" $w }
		}
	}
	
	set space [expr {$width / $n_ratings}]	
	for { set i 1 } { $i <= $n_ratings } { incr i } {
		set w [add_de1_text $page [expr {$x_widget+$space/2+$space*($i-1)}] [expr {$y_widget+25}] \
			-font fontawesome_reg_small \
			-fill $::DYE::GUI::disabled_color -anchor "center" -justify "center" -text $symbol]
		if { $has_ns } { set "${page}::widgets(${widget_name}_rating$i)" $w }
		if { $use_halfs == 1 } {
			set w [add_de1_text $page [expr {$x_widget+$space/2+$space*($i-1)}] [expr {$y_widget+25}] \
				-font fontawesome_reg_small -fill $::DYE::GUI::disabled_color -anchor "center" -justify "center" \
				-text $half_symbol]
			if { $has_ns } { set "${page}::widgets(${widget_name}_rating_half$i)" $w }
		}		
	}

	set rating_cmd "::DYE::GUI::rating_clicker $ratingvar $min_value $max_value $n_ratings $use_halfs %x %y %%x0 %%y0 %%x1 %%y1;\
		::DYE::GUI::draw_rating $page $field_name -n_ratings $n_ratings -use_halfs $use_halfs -min_value $min_value -max_value $max_value -widget_name $widget_name;"
	set widget [::add_de1_button $page $rating_cmd $x_widget [expr {$y_widget-15}] \
		[expr {$x_widget+$width}] [expr {$y_widget+70}] ]
	if { $has_ns } { set "${page}::widgets(${widget_name}_rating_button)" $widget }

	return $widget
}

# Colors each of the symbols of a ratings "widget combo" according to the value of the underlying variable. 
proc ::DYE::GUI::draw_rating { page field_name args } {
	set has_ns [page_name_is_namespace $page]
	if { ! $has_ns } return
	
	set widget_name [DYE::args_get_option args -widget_name $field_name 1]
	if { [info exists ${page}::widgets(${widget_name}_rating_button)] } {
		set button_state [.can itemcget [subst \$${page}::widgets(${widget_name}_rating_button)] -state]
		if { $button_state ne "normal" } { return }
	} else { return }
	
	set ratingvar [DYE::args_add_option_if_not_exists args -rating_var "${page}::data($widget_name)"]
	set n_ratings [DYE::args_get_option args -n_ratings 5 1]		
	set use_halfs [DYE::args_get_option args -use_halfs 1 1]
		
	# If the field name is found in the data dictionary, use its metadata unless they are provided in the proc call
	lassign [DYE::field_lookup $field_name {name data_type n_decimals min_value max_value}] \
		f_label f_data_type f_n_decimals f_min_value f_max_value 	
	foreach fn {label data_type n_decimals min_value max_value} {
		set $fn [DYE::args_get_option args "-$fn" [subst \$f_$fn] 1]
	}

	set varname [DYE::args_add_option_if_not_exists args -rating_var "${page}::data($widget_name)"]	
	
	if { $use_halfs == 1 } { set halfs_mult 2 } else { set halfs_mult 1 }  
	if { ($min_value eq "" || $min_value == 0 ) && ($max_value eq "" || $max_value == 0) } {
		set current_val [return_zero_if_blank [subst \$$varname]]
	} else {
		set current_val [expr {int(([return_zero_if_blank [subst \$$varname]] - 1) / \
			(($max_value-$min_value) / ($n_ratings*$halfs_mult))) + 1}]
	}
	
	for { set i 1 } { $i <= $n_ratings } { incr i } {
		set wn [subst \$${page}::widgets(${widget_name}_rating$i)]
		if { $use_halfs == 1 } {
			set wnh [subst \$${page}::widgets(${widget_name}_rating_half$i)]
		}
		if { [expr {$i * $halfs_mult}] <= $current_val } {
			.can itemconfig $wn -fill $::DYE::GUI::font_color
			if { $use_halfs == 1 } { .can itemconfig $wnh -state hidden } 
		} else {
			if { $use_halfs == 1 } {
				if { [expr {$i * $halfs_mult - 1}] == $current_val } {
					.can itemconfig $wn -fill $::DYE::GUI::disabled_color
					.can itemconfig $wnh -state normal 
					.can itemconfig $wnh -fill $::DYE::GUI::font_color
				} else {
					.can itemconfig $wn -fill $::DYE::GUI::disabled_color
					.can itemconfig $wnh -state hidden 
				}
			} else {
				.can itemconfig $wn -fill $::DYE::GUI::disabled_color
			}
		}
	}
}

# Similar to horizontal_clicker but for arbitrary discrete values like rating stars. 
proc ::DYE::GUI::rating_clicker { varname minval maxval n_ratings use_halfs inx iny x0 y0 x1 y1 } {
	set x [translate_coordinates_finger_down_x $inx]
	set y [translate_coordinates_finger_down_y $iny]
#
	set xrange [expr {$x1 - $x0}]
	set xoffset [expr {$x - $x0}]
	
	if { $use_halfs == 1 } { set halfs_mult 2 } else { set halfs_mult 1 }
	
	set interval [expr {int($xrange / $n_ratings)}] 
	set clicked_val [expr {(int($xoffset / $interval) + 1) * $halfs_mult}]
	
	if { ($minval eq "" || $minval == 0 ) && ($maxval eq "" || $maxval == 0) } {
		set current_val [return_zero_if_blank [subst \$$varname]]
	} else {
		set current_val [expr {int(([return_zero_if_blank [subst \$$varname]] - 1) / \
			(($maxval-$minval) / ($n_ratings * $halfs_mult))) + 1}]		
#		set current_val [expr {(int([return_zero_if_blank [subst \$$varname]]-1) / (($maxval-$minval)/$n_ratings))+1}]
	}
	
	if { $current_val == $clicked_val && $current_val > 0 } {
		set clicked_val [expr {$clicked_val-1}]
	} elseif { $use_halfs == 1 && $current_val > 0 && $clicked_val == [expr {$current_val+1}] } {
		set clicked_val [expr {$clicked_val-2}]
	}
	
	if { ($minval eq "" || $minval == 0 ) && ($maxval eq "" || $maxval == 0) } {
		set $varname $clicked_val
	} else {
		set $varname [expr {int($minval + (($maxval - $minval) * $clicked_val / ($n_ratings*$halfs_mult))) }]
	}
	
	#set ::DYE::debug_text "$varname=[subst \$$varname]\rcurrent_value=$current_val, clicked_val=$$clicked_val\rnew_val=[subst \$$varname]"	
}

### SQLITE SHOTS DATABASE PROCEDURES ##################################################################################

namespace eval DYE::DB {
	variable db {}
	variable updating_db 0
}

# Initializes the database. Called on starup.
proc ::DYE::DB::init {} {
	create
	trace add execution app_exit {enter} { ::DYE::DB::db_close }
	populate
	set ::DYE::GUI::db_progress_msg ""
	
	# Ensures the description summary is updated whenever last shot is saved to history
	trace add execution ::save_this_espresso_to_history leave ::DYE::save_espresso_to_history_hook
}

# Creates the SQLite shot database from scratch.
proc ::DYE::DB::create { {recreate 0} {make_backup 1} {update_screen 0} } {
	variable db
	set ::DYE::DB::updating_db 1
	set db_path "[homedir]/$::DYE::settings(db_path)"
	if {[file exists $db_path] == 1} {
		if { $recreate == 1 } {
			::DYE::DB::db_close
			if { $make_backup == 1 } {
				set backup_path  "[file dirname $db_path]/shots_bak.db"
				# BEWARE that "file rename -force" may fail on Windows, so we delete/rename.
				if { [file exists $backup_path] } { file delete $backup_path }
				file rename $db_path $backup_path
			} else {
				file delete $db_path
			}
		} else { 
			::DYE::DB::upgrade $update_screen
#			after 3000 { set ::DYE::GUI::db_progress_msg "" }
			set ::DYE::DB::updating_db 0
			return
		}
	}
	
	say [translate "Creating shots database"] {}	
	msg "DYE: Creating shots database"
	
	set ::DYE::GUI::db_progress_msg [translate "Creating DB"]
	if { $update_screen == 1 } update
	
	sqlite3 db $db_path -create 1
	
	# Seems the PC undrowith version was not compiled to allow foreign key enforcement
	#db config enable_fkey 1
	# Just use empty strings {}, which are traslated to NULL
	#db nullvalue NULL

	db eval { PRAGMA user_version = 0 } 	
	::DYE::DB::upgrade	$update_screen	
#	after 3000 { set ::DYE::GUI::db_progress_msg "" }
	
	set ::DYE::DB::updating_db 0
}

# Grab the reference to the shots database. 
proc ::DYE::DB::get_db {} {
	variable db
	if { $db eq {} } { 
		sqlite3 db "[homedir]/$::DYE::settings(db_path)" -create 0
		if { [ifexists ::debugging 0] == 1 } {
			db trace ::DYE::DB::log_sql_statement
		}
	}
	return $db	
}

# Detects whether the current shots database schema is from an earlier version of the DYE plugin and upgrades its
# structure if needed. Also used to create the database schema incrementally from scratch.
proc ::DYE::DB::upgrade { {update_screen 0} } {
	set db [get_db]	
	set ::DYE::DB::updating_db 1
	
	set setting_table [db eval {SELECT name FROM sqlite_master WHERE type='table' AND name='setting'}]
	if { $setting_table eq "" } {
		set disk_db_version [db eval {PRAGMA user_version}]
	} else {
		set disk_db_version [db eval {SELECT value FROM setting WHERE code='db_version'}]
		if { $disk_db_version eq "" } {
			set disk_db_version [db eval {PRAGMA user_version}]	
		} else {
			db eval "PRAGMA user_version=$disk_db_version"
			db eval "DELETE FROM setting WHERE code='db_version'"
		}
	}

	msg "DYE DB: Using SQLite version [db version]"	
	msg "DYE DB: Comparing shot db versions: disk $disk_db_version, current $::DYE::db_version"
	if { $disk_db_version > $::DYE::db_version } {
		message_page "[translate {Plugin 'Describe Your Espreso'}] v$::DYE::plugin_version [translate {uses database schema version}]\
			$::DYE::db_version, [translate {but shots.db schema is from a higher version}] (v$disk_db_version)" \
			[translate Ok]		
	}

	if { $disk_db_version == $::DYE::db_version } { return }
	
	# SET WHILE DEBUGGING TO FORCE SCHEMA (RE)CREATION
	#set disk_db_version 0	

	msg "DYE DB: Upgrading shot db from schema version $disk_db_version to schema version $::DYE::db_version"

	if { $disk_db_version <= 0 } {
		set ::DYE::GUI::db_progress_msg [translate "Upgrading DB to v1"]
		if { $update_screen == 1 } update
			
		db eval {
		CREATE TABLE IF NOT EXISTS shot (clock INTEGER PRIMARY KEY, filename TEXT(15) UNIQUE NOT NULL, 
			file_modification_date INTEGER, archived INTEGER DEFAULT 0, profile_title TEXT, bean_weight REAL, 
			drink_weight REAL, extraction_time REAL, bean_brand TEXT, bean_type TEXT, 
			bean_notes TEXT, roast_date TEXT, roast_level TEXT, grinder_model TEXT, grinder_setting TEXT,
			drink_tds REAL, drink_ey REAL, espresso_enjoyment INT, espresso_notes TEXT, my_name TEXT, scentone TEXT,
			beverage_type TEXT, skin TEXT, visualizer_link TEXT);

		CREATE TABLE IF NOT EXISTS shot_series (shot_clock INTEGER, elapsed REAL,
			pressure REAL, weight REAL, flow REAL, flow_weight REAL, flow_weight_raw REAL,
			temperature_basket REAL, temperature_mix REAL, water_dispensed REAL,
			pressure_goal REAL, flow_goal REAL, temperature_goal REAL,
			FOREIGN KEY (shot_clock) REFERENCES shot(clock));

		CREATE UNIQUE INDEX IF NOT EXISTS IX_shot_series ON shot_series(shot_clock, elapsed);

		CREATE TABLE IF NOT EXISTS shot_state_change (shot_clock INTEGER, elapsed REAL,
			FOREIGN KEY (shot_clock) REFERENCES shot(clock));

		CREATE UNIQUE INDEX IF NOT EXISTS IX_shot_state_change ON shot_state_change(shot_clock, elapsed);

		CREATE TABLE IF NOT EXISTS profile (name TEXT(15) PRIMARY KEY, filename TEXT UNIQUE);

		CREATE TABLE IF NOT EXISTS profile_step (profile_name TEXT(15), name TEXT, filename TEXT UNIQUE,
			FOREIGN KEY (profile_name) REFERENCES profile(name));

		CREATE TABLE IF NOT EXISTS shot_profile_step (shot_clock INTEGER, name TEXT, filename TEXT UNIQUE,
			FOREIGN KEY (shot_clock) REFERENCES shot(clock));

		CREATE TABLE IF NOT EXISTS setting (code TEXT(30) PRIMARY KEY, value TEXT);
		
		INSERT OR REPLACE INTO setting (code, value) VALUES ('last_updated', 1);
		}
		#INSERT OR REPLACE INTO setting (code, value) VALUES ('db_version', $DYE::db_version);				
	}
	
	if { $disk_db_version <= 1 } {
		set ::DYE::GUI::db_progress_msg [translate "Upgrading DB to v2"]
		if { $update_screen == 1 } update		
		rename_columns shot bean_weight grinder_dose_weight
	}
		
	if { $disk_db_version <= 2 } {
		set ::DYE::GUI::db_progress_msg [translate "Upgrading DB to v3"]
		if { $update_screen == 1 } update		
		catch { db eval { ALTER TABLE shot ADD COLUMN drinker_name TEXT} }
		catch { db eval { ALTER TABLE shot ADD COLUMN removed INTEGER DEFAULT 0} }
		
		db eval { 
		CREATE VIEW IF NOT EXISTS V_shot AS
		SELECT s.clock, s.filename, 
			CASE WHEN s.archived=0 THEN '/history/'||s.filename||'.shot' 
				ELSE '/history_archive/'||s.filename||'.shot' END as rel_path,
			s.file_modification_date, s.archived, s.removed,
			strftime('%d/%m/%Y %H:%M',s.clock,'unixepoch','localtime')||' '||s.profile_title||
				CASE WHEN LENGTH(COALESCE(s.grinder_dose_weight,''))>0 OR LENGTH(COALESCE(s.drink_weight,''))>0 THEN 
					' - '|| CASE WHEN s.grinder_dose_weight IS NULL OR s.grinder_dose_weight='' THEN '0' ELSE s.grinder_dose_weight END ||'g : '||
					CASE WHEN s.drink_weight IS NULL OR s.drink_weight='' THEN '0' ELSE s.drink_weight END ||'g'||
					CASE WHEN LENGTH(COALESCE(s.grinder_dose_weight,''))>0 AND LENGTH(COALESCE(s.drink_weight,''))>0 THEN
						' (1:' || ROUND(s.drink_weight / s.grinder_dose_weight, 1) || ') '
					ELSE '' END 
				ELSE '' END ||
				CASE WHEN LENGTH(COALESCE(s.bean_brand,''))>0 OR LENGTH(COALESCE(s.bean_type,''))>0 OR LENGTH(COALESCE(s.roast_date,''))>0 THEN
					' - '|| TRIM(COALESCE(s.bean_brand||' ','')||COALESCE(s.bean_type||' ','')||COALESCE(s.roast_date,''))
				ELSE '' END ||
				CASE WHEN LENGTH(COALESCE(s.grinder_model,''))>0 OR LENGTH(COALESCE(s.grinder_setting,''))>0 THEN
					' - '|| COALESCE(s.grinder_model, '') ||' @ '|| COALESCE(s.grinder_setting,'') 
				ELSE '' END ||
				CASE WHEN removed=1 THEN ' [REMOVED]' ELSE '' END AS shot_desc,
			s.profile_title, s.grinder_dose_weight, s.drink_weight, s.extraction_time,
			s.bean_brand, s.bean_type, s.bean_notes, s.roast_date, s.roast_level,
			CASE WHEN LENGTH(COALESCE(s.bean_brand,''))>0 OR LENGTH(COALESCE(s.bean_type,''))>0 OR LENGTH(COALESCE(s.roast_date,''))>0 THEN
				TRIM(COALESCE(s.bean_brand||' ','')||COALESCE(s.bean_type||' ','')||COALESCE(s.roast_date,''))
				ELSE '' END AS bean_desc,	
			s.grinder_model, s.grinder_setting, 
			s.drink_tds, s.drink_ey, s.espresso_enjoyment, s.espresso_notes, s.scentone,
			s.my_name, s.drinker_name, s.beverage_type, s.skin,
			s.visualizer_link
		FROM shot s;
						
		DELETE FROM setting WHERE code='db_version';
		}
	}
	
	# v4 corrects an error in V_shot when grinder_dose_weight was 0 the ratio was computed, returned NULL, and 
	# then shot_desc was NULL. Also on the very first .shot files in DE1 the profile_title could be empty.
	if { $disk_db_version <= 3 } {
		set ::DYE::GUI::db_progress_msg [translate "Upgrading DB to v4"]
		if { $update_screen == 1 } update
		
		db eval {
		DROP VIEW IF EXISTS V_shot;
			
		CREATE VIEW IF NOT EXISTS V_shot AS
		SELECT s.clock, s.filename, 
			CASE WHEN s.archived=0 THEN '/history/'||s.filename||'.shot' 
				ELSE '/history_archive/'||s.filename||'.shot' END as rel_path,
			s.file_modification_date, s.archived, s.removed,
			strftime('%d/%m/%Y %H:%M',s.clock,'unixepoch','localtime')||' '||COALESCE(s.profile_title,'')||
			CASE WHEN LENGTH(COALESCE(s.grinder_dose_weight,''))>0 OR LENGTH(COALESCE(s.drink_weight,''))>0 THEN 
				' - '|| CASE WHEN s.grinder_dose_weight IS NULL OR s.grinder_dose_weight='' THEN '0' ELSE s.grinder_dose_weight END ||'g : '||
				CASE WHEN s.drink_weight IS NULL OR s.drink_weight='' THEN '0' ELSE s.drink_weight END ||'g'||
				CASE WHEN LENGTH(COALESCE(s.grinder_dose_weight,''))>0 AND LENGTH(COALESCE(s.drink_weight,''))>0 
						AND s.grinder_dose_weight > 0 AND s.drink_weight > 0 THEN
					' (1:' || ROUND(s.drink_weight / s.grinder_dose_weight, 1) || ')'
				ELSE '' END 
			ELSE '' END ||
			CASE WHEN LENGTH(COALESCE(s.bean_brand,''))>0 OR LENGTH(COALESCE(s.bean_type,''))>0 OR LENGTH(COALESCE(s.roast_date,''))>0 THEN
				' - '|| TRIM(COALESCE(s.bean_brand||' ','')||COALESCE(s.bean_type||' ','')||COALESCE(s.roast_date,''))
			ELSE '' END ||
			CASE WHEN LENGTH(COALESCE(s.grinder_model,''))>0 OR LENGTH(COALESCE(s.grinder_setting,''))>0 THEN
				' - '|| COALESCE(s.grinder_model, '') || 
					CASE WHEN LENGTH(COALESCE(s.grinder_setting,''))>0 THEN ' @ '||s.grinder_setting ELSE '' END
			ELSE '' END ||
			CASE WHEN LENGTH(COALESCE(s.drink_ey,''))>0 OR LENGTH(COALESCE(s.drink_tds,''))>0 OR LENGTH(COALESCE(s.espresso_enjoyment,''))>0 THEN
				' - '||
				CASE WHEN LENGTH(COALESCE(s.drink_tds,''))>0 THEN 'TDS '||s.drink_tds||'% ' ELSE '' END ||
				CASE WHEN LENGTH(COALESCE(s.drink_ey,''))>0 THEN 'EY '||s.drink_ey||'% ' ELSE '' END ||
				CASE WHEN LENGTH(COALESCE(s.espresso_enjoyment,''))>0 THEN 'Enjoy '||s.espresso_enjoyment||' ' ELSE '' END 
			ELSE '' END ||
			CASE WHEN removed=1 THEN ' [REMOVED]' ELSE '' END AS shot_desc,
			s.profile_title, s.grinder_dose_weight, s.drink_weight, s.extraction_time,
			s.bean_brand, s.bean_type, s.bean_notes, s.roast_date, s.roast_level,
			CASE WHEN LENGTH(COALESCE(s.bean_brand,''))>0 OR LENGTH(COALESCE(s.bean_type,''))>0 OR LENGTH(COALESCE(s.roast_date,''))>0 THEN
				TRIM(COALESCE(s.bean_brand||' ','')||COALESCE(s.bean_type||' ','')||COALESCE(s.roast_date,''))
				ELSE '' END AS bean_desc,	
			s.grinder_model, s.grinder_setting, 
			s.drink_tds, s.drink_ey, s.espresso_enjoyment, s.espresso_notes, s.scentone,
			s.my_name, s.drinker_name, s.beverage_type, s.skin, s.visualizer_link
		FROM shot s;
		}
	}
	
	# v5 adds the "Other equipment" related tables and views.
#	if { $disk_db_version <= 4 } {
#		set ::DYE::GUI::db_progress_msg [translate "Upgrading DB to v5"]
#		if { $update_screen == 1 } update
#		
#		db eval {
#							
#		CREATE TABLE IF NOT EXISTS equipment_type (equipment_type TEXT(50) PRIMARY KEY, 
#			sort_number INTEGER NOT NULL DEFAULT 999999);
#
#		CREATE VIEW IF NOT EXISTS V_equipment_type_calc_sort AS
#		SELECT equipment_type, sort_number, (
#			SELECT (COUNT(*)+1)*10 FROM equipment_type etc
#			WHERE etc.sort_number < et.sort_number
#				OR (etc.sort_number = et.sort_number AND etc._rowid_ < et._rowid_)
#		) AS calc_sort_number
#		FROM equipment_type et;
#						
#		CREATE TABLE IF NOT EXISTS equipment (equipment_name TEXT(100) NOT NULL, equipment_type TEXT(50) NOT NULL, 
#			default_setting TEXT(100), propagate INTEGER NOT NULL DEFAULT 1 CHECK(propagate IN(0,1)), 
#			sort_number INTEGER NOT NULL DEFAULT 999999,
#			PRIMARY KEY (equipment_name, equipment_type), 
#			FOREIGN KEY (equipment_type) REFERENCES equipment_type(equipment_type));
#		
#		CREATE VIEW IF NOT EXISTS V_equipment_calc_sort AS
#		SELECT equipment_name, equipment_type, sort_number, (
#			SELECT (COUNT(*)+1)*10 FROM equipment ec
#			WHERE ec.equipment_type=e.equipment_type
#				AND (ec.sort_number < e.sort_number
#					OR (ec.sort_number = e.sort_number AND ec._rowid_ < e._rowid_))
#		) AS calc_sort_number
#		FROM equipment e;
#						
#		CREATE TABLE IF NOT EXISTS shot_equipment (clock INTEGER NOT NULL, equipment_name TEXT(100) NOT NULL,
#			equipment_type TEXT(50) NOT NULL, equipment_setting TEXT(100), sort_number INTEGER NOT NULL DEFAULT 999999,
#			PRIMARY KEY (clock, equipment_name, equipment_type),
#			FOREIGN KEY (clock) REFERENCES shot(clock),
#			FOREIGN KEY (equipment_name, equipment_type) REFERENCES equipment(equipment_name, equipment_type));
#		
#		CREATE VIEW IF NOT EXISTS V_shot_other_equipment AS
#		SELECT se.clock, COUNT(se.equipment_name) AS n_other_equipment, 
#			GROUP_CONCAT(se.equipment_type||': '||se.equipment_name|| 
#			CASE WHEN LENGTH(COALESCE(se.equipment_setting,''))>0 THEN ' ['||se.equipment_setting||']' ELSE '' END, '; ') 
#				AS other_equipment
#		FROM shot_equipment se 
#			INNER JOIN equipment e ON se.equipment_name=e.equipment_name AND se.equipment_type==e.equipment_type 
#		GROUP BY se.shot_clock;
#		
#		CREATE VIEW IF NOT EXISTS V_shot_all AS
#		SELECT s.*, COALESCE(soe.n_other_equipment, 0) AS n_other_equipment, soe.other_equipment
#		FROM V_shot s LEFT JOIN V_shot_other_equipment soe ON s.clock=soe.clock;
#		}
#		
#		insert_default_categories 1
#	}	

#   FIRST VERSION. BUT "OVER" IS NOT SUPPORTED ON SQLite UNTIL 3.25 
#	CREATE VIEW IF NOT EXISTS V_equipment_type_calc_sort AS
#	SELECT name, sort_number, (row_number() over (order by sort_number, _rowid_))*10 AS calc_sort_number
#	FROM equipment_type;
#	
#	CREATE VIEW IF NOT EXISTS V_equipment_calc_sort AS
#	SELECT e.equipment_name, e.equipment_type, e.sort_number, (row_number() 
#			over (order by et.sort_number, e.sort_number, e._rowid_))*10 AS calc_sort_number
#	FROM equipment e INNER JOIN equipment_type et ON e.equipment_type=et.equipment_type;
	
	db eval "PRAGMA user_version=$::DYE::db_version"
	set ::DYE::GUI::db_progress_msg [translate "DB Upgraded"]
	if { $update_screen == 1 } update		
	
	set ::DYE::DB::updating_db 0
}
	
# Closes the shot SQLite database.
# Add unnecessary { args } for this to work on trace add execution.
proc ::DYE::DB::db_close { args } {
	variable db
	db close
	pause 1000
	unset -nocomplain db
	set db {}
}

# Logs SQL statements
proc ::DYE::DB::log_sql_statement { sql } {
	msg "DYE DB: $sql"
#	set msg_txt "DYE DB: $sql\r"
#	append msg_txt [uplevel {subst $sql}]
#	msg $msg_txt
}

# Embed text string in single quotes and escape any SQL character that may produce problems: duplicate single quotes.
# If text is a list, escapes and embeds each one in single quotes, and concatenates by , to be used in an "IN" sql
# statement.
proc ::DYE::DB::strings2sql { text } {
	set result [regsub -all {'} $text {''}]
	set result [lmap a $result {
		if {[string is integer -strict $a]} { set a } else { subst {'$a'} } }]	 
	return [join $result ","]
} 

# Escapes a string to be used within SQL
proc ::DYE::DB::string2sql { text } {
	#return "'[regsub -all {'} $text {''}]'"
	return "'[string map {' ''} $text]'"
} 
	
# Backwards-compatible table column renamere. Takes into account the SQLite version, as before 3.25.0 
#	"ALTER TABLE RENAME COLUMN" was not supported. Also fail-safe if the old column does not exist, or the new 
#	column already does.
# Returns 1 if at least one column is renamed, 0 otherwise.
proc ::DYE::DB::rename_columns { db_table old_columns new_columns } {
	set db [get_db]
	set result 0
	
	if { [package vcompare [db version] 3.25] >= 0 } {
		for { set i 0 } { $i < [llength $old_columns] } { incr i } {
			if { $i < [llength $new_columns] } {
				set sql "ALTER TABLE $db_table RENAME COLUMN [lindex $old_columns $i] TO [lindex $new_columns $i]"
				if { [ catch {db eval "$sql"} err ] != 0 } {
					msg "DYE DB: ERROR, can't rename column [lindex $old_columns $i] to [lindex $new_columns $i] in table $db_table: $err"
				} else { 
					set result 1
				}
			}
		}
		
		return $result
	}

	set old_all_columns {}		
	db eval "PRAGMA table_info($db_table)" { lappend old_all_columns $name }
	set new_all_columns $old_all_columns	
	if { [llength $old_all_columns] == 0 } {
		msg "DYE DB: ERROR, can't find DB table $db_table"
		return $result
	}
	
	set create_sql [db eval "SELECT sql FROM sqlite_master WHERE type='table' AND name='$db_table'" ]
	set create_sql [regsub "\\m$db_table\\M" $create_sql "NEW_$db_table"]
	
	set i 0
	set n_changes 0
	foreach old_col $old_columns {
		set new_col [lindex $new_columns $i]
				
		if { [regexp "\\m$old_col\\M" $create_sql] } {
			set create_sql [regsub "\\m$old_col\\M" $create_sql $new_col]
			set col_idx [lsearch $new_all_columns $old_col]
			if { $col_idx > -1 } {
				set new_all_columns [lreplace $new_all_columns $col_idx $col_idx $new_col]
				incr n_changes
			} else {
				msg "DYE DB: ERROR column $old_col not found in table $db_table"
			}
		} else {
			msg "DYE DB: ERROR column $old_col not found in table $db_table"
		}
		incr i
	}

	if { $n_changes > 0 } {
		set sql "BEGIN TRANSACTION;
			[join $create_sql];
			INSERT INTO NEW_$db_table ([join $new_all_columns ,]) SELECT [join $old_all_columns ,] FROM $db_table;
			DROP TABLE $db_table;
			ALTER TABLE NEW_$db_table RENAME TO $db_table;
			COMMIT TRANSACTION;"
		db eval "$sql";
		set result 1
	}
	
	return $result
}
		
# Fully synchronizes every file in the shot history and history_archive folders to the shots database.
# As a side effect, updates the last_sync_* variables in the DYE settings.
proc ::DYE::DB::populate { {persist_desc {}} { persist_series {}} {update_screen 0} {force_update_series 0} } {
	set db [get_db]
	set ::DYE::DB::updating_db 1
	if { $persist_desc eq "" } { set persist_desc $::DYE::settings(db_persist_desc) }
	if { $persist_series eq "" } { set persist_series $::DYE::settings(db_persist_series) }
	set screen_msg [translate "Synchronizing DB"]
	set ::DYE::GUI::db_progress_msg $screen_msg
	
	set last_sync_start [clock seconds]
	foreach fn "analyzed inserted modified archived unarchived removed unremoved" { set "cnt_$fn" 0 }
	
	#set last_db_updated [db eval { SELECT CAST(value AS integer) FROM setting WHERE code='last_updated' }]
	array set db_shots {}
	db eval { SELECT filename, clock, file_modification_date, archived, removed FROM shot } {
		set db_shots(${filename}.shot) "$clock $file_modification_date $archived $removed"
	}
	
	set files [lsort -dictionary [glob -nocomplain -tails -directory "[homedir]/history/" *.shot]]
	set afiles [lsort -dictionary [glob -nocomplain -tails -directory "[homedir]/history_archive/" *.shot]]
	set n [expr {[llength $files]+[llength $afiles]}]
	set cnt 1
	set ::DYE::GUI::db_progress_msg "$screen_msg: 0/$n (0\%)"
	if { $update_screen == 1 } { update }
	
	foreach f $files {
		if { [info exists db_shots($f)] } {
			set something_changed 0
			lappend db_shots($f) 1
		
			set fmtime [file mtime "[homedir]/history/$f"]
			set db_mtime [lindex $db_shots($f) 1]
			if { $fmtime > $db_mtime } {
				msg "DYE DB: Processing history/$f, as modif time ($fmtime=[clock format $fmtime -format $::DYE::friendly_clock_format]) > DB modif time ($db_mtime=[clock format $db_mtime -format $::DYE::friendly_clock_format])"
				array set shot [::DYE::load_shot "[homedir]/history/$f"]
				persist_shot shot $persist_desc $persist_series 0
				incr cnt_modified
				set something_changed 1
			} elseif { $persist_series == 1 && $force_update_series == 1} {
				set shot_clock [lindex $db_shots($f) 0]
				set shot_has_series [db exists {SELECT 1 FROM shot_series WHERE shot_clock=$shot_clock LIMIT 1}]
				if { $shot_has_series != 1 } {
					msg "DYE DB: Processing history/$f, as it needs its chart series added"
					array set shot [::DYE::load_shot "[homedir]/history/$f"]
				
					persist_shot shot 0 1 0
					incr cnt_modified
					set something_changed 1
				}
			} 
			set sql {}
			if { [lindex $db_shots($f) 2] == 1 } { 
				append sql " archived=0," 
				incr cnt_unarchived
			}
			if { [lindex $db_shots($f) 3] == 1 } { 
				append sql " removed=0," 
				incr cnt_unremoved
			}
			if { $sql ne "" } {
				set sql "UPDATE shot SET [string range $sql 0 end-1] WHERE clock=[lindex $db_shots($f) 0]"
				msg "DYE DB: $sql"
				db eval "$sql"
				set something_changed 1
			} 
			if { $something_changed == 0 } {
				msg "DYE DB: shot file history/$f does not need any updating"
			}
		} else {
			msg "DYE DB: Processing history/$f, as it's a new shot file not yet in the database"
			array set shot [::DYE::load_shot "[homedir]/history/$f"]
			persist_shot shot $persist_desc $persist_series 0
			if { $update_screen == 1 } update
			incr cnt_inserted
		}
		
		incr cnt
		if {[expr {$cnt % 10}] == 0 } {
			set perc [expr {int($cnt*100.0/$n)}]
			set ::DYE::GUI::db_progress_msg "$screen_msg: $cnt/$n ($perc\%)"
			if { $update_screen == 1 } { update }
		}
	}
	
	foreach f $afiles {
		if { [info exists db_shots($f)] } {
			set something_changed 0
			lappend db_shots($f) 1
			set fmtime [file mtime "[homedir]/history_archive/$f"]
			set db_mtime [lindex $db_shots($f) 1]
			if { $fmtime > $db_mtime } {
				msg "DYE DB: Processing history_archive/$f, as modif time ($fmtime=[clock format $fmtime -format $::DYE::friendly_clock_format]) > DB modif time ($db_mtime=[clock format $db_mtime -format $::DYE::friendly_clock_format])"
				array set shot [::DYE::load_shot "[homedir]/history_archive/$f"]
				persist_shot shot $persist_desc $persist_series 0
				incr cnt_modified
				set something_changed 1
			} elseif { $persist_series == 1 && $force_update_series == 1} {
				set shot_clock [lindex $db_shots($f) 0]
				set shot_has_series [db exists {SELECT 1 FROM shot_series WHERE shot_clock=$shot_clock LIMIT 1}]
				if { $shot_has_series != 1 } {
					msg "DYE DB: Processing history/$f, as it needs its chart series added"
					array set shot [::DYE::load_shot "[homedir]/history_archive/$f"]
					persist_shot shot 0 1 0
					incr cnt_modified
				}				
				set something_changed 1
			} 
			set sql {}
			if { [lindex $db_shots($f) 2] == 0 } { 
				append sql " archived=1," 
				incr cnt_archived
			}
			if { [lindex $db_shots($f) 3] == 1 } { 
				append sql " removed=0," 
				incr cnt_unremoved
			}
			if { $sql ne "" } {
				set sql "UPDATE shot SET [string range $sql 0 end-1] WHERE clock=[lindex $db_shots($f) 0]"
				msg "DYE DB: $sql"
				db eval "$sql"
				set something_changed 1
			}
			if { $something_changed == 1 } {
				msg "DYE DB: shot file history/$f does not need any updating"
			}			
		} else {
			msg "DYE DB: Processing history_archive/$f, as it's a new shot file not yet in the database"
			array set shot [::DYE::load_shot "[homedir]/history_archive/$f"]
			persist_shot shot $persist_desc $persist_series 0
			incr cnt_inserted
		}
		
		incr cnt
		if {[expr {$cnt % 10}] == 0 } {
			set perc [expr {int($cnt*100.0/$n)}]			
			set ::DYE::GUI::db_progress_msg "$screen_msg: $cnt/$n ($perc\%)"
			if { $update_screen == 1 } { update }
		}
	}

	# Check files deleted from disk and flag them as removed.
	set rm_clocks {}
	foreach f [array names db_shots] {
		if { [llength $db_shots($f)] < 5 } { 
			lappend rm_clocks [lindex $db_shots($f) 0]
			msg "DYE DB: shot file $f removed from history and history_archive"
		}
	}
	if { [llength $rm_clocks] > 0} {
		set sql "UPDATE shot SET removed=1 WHERE clock IN ([join $rm_clocks ,]) AND removed=0"
		msg "DYE DB: $sql"
		db eval "$sql"
		set cnt_removed [db changes]
	}

	set ::DYE::GUI::db_progress_msg "$screen_msg: $n/$n (100\%)"
	if { $update_screen == 1} update
#	after 3000 { set ::DYE::GUI::db_progress_msg "" } 
	
	update_last_updated
	
	set ::DYE::settings(last_sync_clock) $last_sync_start 	
	set ::DYE::settings(last_sync_analyzed) $n
	foreach fn "inserted modified archived unarchived removed unremoved" {
		set ::DYE::settings(last_sync_$fn) [subst \$cnt_$fn]
	}	
	::DYE::save_settings
	
	set ::DYE::DB::updating_db 0	
}

proc ::DYE::DB::update_last_updated {} {
	variable db
	set sql "UPDATE setting SET value=(SELECT COALESCE(MAX(file_modification_date), 1) FROM shot) \
		WHERE code='last_updated' "
	#msg "DYE: $sql"
	db eval "$sql"
}

# Insert default rows for fixed categories (equipment types, TODO countries, regions, and varieties)
proc ::DYE::DB::insert_default_categories { {equipment_types 1} } {
	set db [get_db]
	
	if { $equipment_types == 1 } {
		db eval {
			INSERT OR REPLACE INTO equipment_type (equipment_type, sort_number) VALUES 
			('Basket', 10), ('Tamper', 20), ('Distribution', 30), ('Filter', 40),
			('Technique', 50), ('Brewer', 60)
		}		
	}
	
	# TODO: REMOVE ON PRODUCTION
	if { [ifexists ::debugging 0] == 1 } {
		db eval {
			INSERT OR REPLACE INTO equipment (equipment_name, equipment_type) VALUES
			('Bravo', 'Tamper'), ('Force', 'Tamper'), ('Decent v3', 'Tamper'), ('Cafelat', 'Tamper'),
			('Cafelat 58mm', 'Filter'), ('Tea 56mm', 'Filter'),
			('Amazon leveller', 'Distribution'), ('Bravo', 'Distribution'),('Force', 'Distribution')
		}
	}

}

# Persists shot data to the SQLite shot database.
# The shot data should be an array reference as produced by proc DYE::load_shot.
# Detects whether the shot is already in the DB and INSERTs or UPDATEs the description as needed.
# Series are only inserted once, never updated as they never change after shot creation.
proc ::DYE::DB::persist_shot { arr_shot {persist_desc {}} {persist_series {}} {calc_last_updated 1} } {
	set db get_db
	upvar $arr_shot shot
	if { $persist_desc eq "" } { set persist_desc $::DYE::settings(db_persist_desc) }
	if { $persist_series eq "" } { set persist_series $::DYE::settings(db_persist_series) }

	if { $persist_desc == 1 } {
		if {[db exists {SELECT 1 FROM shot WHERE clock=$shot(clock)}]} {
			# We only update the description fields, not the others which should not change.
			db eval { UPDATE shot SET archived=COALESCE($shot(comes_from_archive),0),
				grinder_dose_weight=$shot(grinder_dose_weight),drink_weight=$shot(drink_weight),
				bean_brand=$shot(bean_brand),bean_type=$shot(bean_type),
				bean_notes=$shot(bean_notes), roast_date=$shot(roast_date),roast_level=$shot(roast_level),
				grinder_model=$shot(grinder_model),grinder_setting=$shot(grinder_setting),
				drink_tds=$shot(drink_tds),drink_ey=$shot(drink_ey),
				espresso_enjoyment=$shot(espresso_enjoyment),espresso_notes=$shot(espresso_notes),
				my_name=$shot(my_name),drinker_name=$shot(drinker_name),scentone=$shot(scentone),
				file_modification_date=$shot(file_modification_date),skin=$shot(skin),
				beverage_type=$shot(beverage_type)
				WHERE clock=$shot(clock) }
			
			if { [info exists shot(other_equipment)] } {
				update_shot_equipment $shot(clock) $shot(other_equipment) 0
			}						
		} else {
			db eval { INSERT INTO shot (clock,filename,archived,
				profile_title,grinder_dose_weight,drink_weight,extraction_time,
				bean_brand,bean_type,bean_notes,roast_date,roast_level,grinder_model,grinder_setting,
				drink_tds,drink_ey,espresso_enjoyment,espresso_notes,my_name,drinker_name,scentone,
				file_modification_date,skin,beverage_type)
				VALUES ( $shot(clock),$shot(filename),COALESCE($shot(comes_from_archive),0),
				$shot(profile_title),$shot(grinder_dose_weight),$shot(drink_weight),
				$shot(extraction_time),$shot(bean_brand),$shot(bean_type),$shot(bean_notes),$shot(roast_date),
				$shot(roast_level),$shot(grinder_model),$shot(grinder_setting),$shot(drink_tds),$shot(drink_ey),
				$shot(espresso_enjoyment),$shot(espresso_notes),$shot(my_name),$shot(drinker_name),$shot(scentone),
				$shot(file_modification_date),$shot(skin),$shot(beverage_type) ) }
			
			if { [info exists shot(other_equipment)] && $shot(other_equipment) ne "" } {
				update_shot_equipment $shot(clock) $shot(other_equipment) 0
			}									
		}
	} elseif { $persist_series == 1 } {
		# Prevents breaking a FK constraint (though FK are not supported in this compilation of undrowish) if the shot 
		# description has never been persisted and the arguments specify to save the series but not the description.
		set persist_series [db exists {SELECT 1 FROM shot WHERE clock=$shot(clock)}]
	}

	# Only make series inserts, never updates
	if { $persist_series == 1 && [db exists {SELECT 1 FROM shot_series WHERE shot_clock=$shot(clock) LIMIT 1}] == 0 } {
		if { [llength $shot(espresso_elapsed)] > 1 } {
			set n_weight [llength $shot(espresso_weight)]
			set n_flow_weight_raw [llength $shot(espresso_flow_weight_raw)]
			set n_water_dispensed [llength $shot(espresso_water_dispensed)]
			set n_pressure_goal [llength $shot(espresso_pressure_goal)]

			set sql "INSERT INTO shot_series (shot_clock,elapsed,pressure,weight,flow,flow_weight,flow_weight_raw,\
temperature_basket,temperature_mix,water_dispensed,pressure_goal,flow_goal,temperature_goal) VALUES "
			for {set i 0} { $i < [llength $shot(espresso_elapsed)] } {incr i} {
				# I can't make embedding the [lindex ...] statement in the SQL string work, so
				# I need to create each variable
				set elapsed [lindex $shot(espresso_elapsed) $i]
				set pressure [lindex $shot(espresso_pressure) $i]
				if { $i < $n_weight } {
					set weight [lindex $shot(espresso_weight) $i]
				} elseif {[info exists weight] == 1} {
					set weight "NULL"
				}
				set flow [lindex $shot(espresso_flow) $i]
				set flow_weight [lindex $shot(espresso_flow_weight) $i]
				if { $i < $n_flow_weight_raw } {
					set flow_weight_raw [lindex $shot(espresso_flow_weight_raw) $i]
				} else {
					set flow_weight_raw "NULL"
				}
				set temperature_basket [lindex $shot(espresso_temperature_basket) $i]
				set temperature_mix [lindex $shot(espresso_temperature_mix) $i]
				if { $i < $n_water_dispensed } {
					set water_dispensed [lindex $shot(espresso_water_dispensed) $i]
				} else {
					set water_dispensed "NULL"
				}
				if {$i < $n_pressure_goal } {
					set pressure_goal [lindex $shot(espresso_pressure_goal) $i]
					set flow_goal [lindex $shot(espresso_flow_goal) $i]
					set temperature_goal [lindex $shot(espresso_temperature_goal) $i]
				} else {
					set pressure_goal "NULL"
					set flow_goal "NULL"
					set temperature_goal "NULL"
				}

				append sql "($shot(clock),$elapsed,$pressure,$weight,$flow,$flow_weight,$flow_weight_raw,\
$temperature_basket,$temperature_mix,$water_dispensed,$pressure_goal,$flow_goal,$temperature_goal),\r"
			}
			set sql [string range $sql 0 [expr {[string length $sql]-3}]]
			db eval "$sql"
		}
	}

	if { $calc_last_updated == 1 } { update_last_updated }
}

# Updates the shot table for the requested shot (identified by its clock) using the data from provided array.
# Array names must match shot table column names.
proc ::DYE::DB::update_shot_description { clock arr_new_settings } {
	set db [get_db]
	upvar $arr_new_settings new_settings
	if { [string trim $clock] eq "" } return
	if { [array size new_settings] == 0 } return
	
	db eval "SELECT * FROM shot LIMIT 1" x {set columns $x(*)}
	
	set field_updates {}
	foreach field_name [array names new_settings] {
		# TODO: Replace following test by a parametrized done using the data dictionary?
		if { $field_name eq "other_equipment" } {
			update_shot_equipment $clock $new_settings(other_equipment)
		} else {		
			if { [lsearch $columns $field_name] > -1 } {
				lappend field_updates "$field_name=\$new_settings($field_name)"
			} else {
				msg "DYE ERROR: Unmatched column name $field_name in update_shot_description"
			}
		}
	}
	
	if { [llength $field_updates] > 0 } {
		set sql "UPDATE shot SET [join $field_updates ,] WHERE clock=$clock"
		db eval "$sql"
	}
}
	
proc ::DYE::DB::resort_equipment_types {} {
	set db [get_db]
	if {[db exists {SELECT equipment_type FROM V_equipment_type_calc_sort WHERE sort_number<>calc_sort_number LIMIT 1}] } {
		#set ::DYE::debug_text "RESORTING equipment_type"
		db transaction { 
			db eval {
				DROP TABLE IF EXISTS temp.resorted_et;
				CREATE TEMPORARY TABLE resorted_et AS SELECT * FROM V_equipment_type_calc_sort;
				UPDATE equipment_type SET sort_number=(SELECT t.calc_sort_number 
						FROM temp.resorted_et t WHERE t.equipment_type=equipment_type.equipment_type
						AND t.sort_number <> t.calc_sort_number)
				WHERE EXISTS (SELECT * FROM temp.resorted_et t WHERE t.equipment_type=equipment_type.equipment_type
						AND t.sort_number <> t.calc_sort_number);
				DROP TABLE temp.resorted_et;			
			} 			
		}
	}

	# This doesn't work with older SQLite version (may be the version or the change in the view)
#	db eval { UPDATE equipment_type SET sort_number=(SELECT calc_sort_number 
#		FROM V_equipment_type_calc_sort WHERE equipment_type=equipment_type.equipment_type) }
}

proc ::DYE::DB::resort_equipment {} {
	set db [get_db]
#	db eval { UPDATE equipment SET sort_number=(SELECT calc_sort_number FROM V_equipment_calc_sort 
#		WHERE equipment_name=equipment.equipment_name AND equipment_type=equipment.equipment_type ) }
}

# Modifies the shot_equipment table for the requested shot (identified by its clock) using the data from provided 
# 'other_equipment' list. Normally nor called directly but through update_shot_description.
proc ::DYE::DB::update_shot_equipment { clock other_equipment { insert_only 0 } } {
	set db [get_db]
#msg "DYE DB DEBUG: update_shot_equipment clock=$clock, other_equipment=$other_equipment"	
	if { $other_equipment eq "" } {
		db eval {DELETE FROM shot_equipment WHERE shot_clock=$clock}
	} else {
		set enames {}
		
		if { $insert_only == 1 } {
			set sql "INSERT INTO shot_equipment (clock,equipment_name,equipment_type,equipment_setting,sort_number) VALUES "
		} else {
			set sql "INSERT OR REPLACE INTO shot_equipment (clock,equipment_name,equipment_type,equipment_setting,sort_number) VALUES "
		}

		for {set i 0} { $i < [llength $other_equipment] } {incr i 3} {
			set equipment [lindex $other_equipment $i]
			set type [lindex $other_equipment [expr {$i+1}]]
			set setting [lindex $other_equipment [expr {$i+2}]]
			set sort_number [expr {(int($i/3)+1)*10}]
			lappend enames "$equipment$type"

			append sql "($clock,[::DYE::DB::string2sql $equipment],[::DYE::DB::string2sql $type],[::DYE::DB::string2sql $setting],$sort_number),"
		}
		set sql [string range $sql 0 [expr {[string length $sql]-2}]]
		db eval "$sql"
		
		if { $insert_only != 1 } {
			set sql "DELETE FROM shot_equipment WHERE clock=$clock AND equipment_name||equipment_type NOT IN (
				SELECT equipment_name||equipment_type FROM shot_equipment  
				WHERE equipment_name||equipment_type IN ([::DYE::DB::strings2sql $enames]))"
			db eval "$sql"
		}
	}
}

# Extracts the different equipment/equipment_type unique categories from the shots data in shot_equipment table
# and insert new ones into tables equipment and equipment_type.
proc ::DYE::DB::update_equipment_categories { } {
	set db [get_db]
	
	db eval {INSERT INTO equipment_type (equipment_type) SELECT se.equipment_type
		FROM shot_equipment se LEFT JOIN equipment_type et ON se.equipment_type=et.equipment_type
		WHERE et.equipment_type IS NULL GROUP BY se.equipment_type;
		
		INSERT INTO equipment (equipment_name, equipment_type) SELECT se.equipment_name, se.equipment_type
		FROM shot_equipment se LEFT JOIN equipment e ON se.equipment_name=e.equipment_name 
			AND se.equipment_type=e.equipment_type
		WHERE e.equipment_name IS NULL GROUP BY se.equipment_name, se.equipment_type;
	}
	resort_equipment_types
	resort_equipment
}

# Returns a list of available categories. "field_name" must be available in the data dictionary with 
# 	data_type=category. Returns a list for single-column categories, and an array of lists for multi-column
# 	categories such as equipment_name (which requires equipment_type).
# If use_lookup_table=1, grabs the categories from the lookup_table (e.g. equipment_type) instead of from the
#	actual values as used in shots (e.g. shot_equipment inner join equipment_type)
# If args are provided and the field has db_type_column<i>, filters to category values matching the corresponding
#	types.
proc ::DYE::DB::available_categories { field_name {exc_removed_shots 1} {filter {}} {use_lookup_table 1} args } {
	set db [get_db]	
	lassign [::DYE::field_lookup $field_name {data_type db_table lookup_table db_type_column1 db_type_column2}] \
		data_type db_table lookup_table db_type_column1 db_type_column2 
	if { $data_type ne "category" } return
	if { $use_lookup_table == 1 && $lookup_table eq "" } { set use_lookup_table 0 }	
	
	set fields {}
	set grouping_fields {}
	lappend fields "TRIM($field_name) as $field_name"
	lappend grouping_fields "TRIM($field_name)"
	
	set extra_from ""
	set extra_wheres {}
	set type1_db_table ""
	if { $db_type_column1 ne "" } { 
		lappend fields "TRIM($db_type_column1) AS $db_type_column1" 
		lappend grouping_fields "TRIM($db_type_column1)"
		if { $use_lookup_table == 1 } {							
			lassign [::DYE::field_lookup $db_type_column1 {lookup_table}] type1_db_table 
			if { $type1_db_table ne "" } {
				append extra_from "LEFT JOIN $type1_db_table ON $db_type_column1=${type1_db_table}.$db_type_column1 "
			}
		}
		
		if { [llength $args] > 0 && [lindex $args 0] ne "" } {
			lappend extra_wheres "$db_type_column1 IN ([::DYE::DB::strings2sql [lindex $args 0]])"
		}
	}
	
	if { $db_type_column2 ne "" } { 
		lappend fields "TRIM($db_type_column2) as $db_type_column2" 
		lappend grouping_fields "TRIM($db_type_column2)"
		if { [llength $args] > 1 && [lindex $args 1] ne "" } {
			lappend extra_wheres "$db_type_column2 IN ([::DYE::DB::strings2sql [lindex $args 1]])"
		}
	}
	
	if { $db_table eq "shot" } {
		set sql "SELECT [join $fields ,] FROM shot "
	} elseif { $use_lookup_table } {
		set sql "SELECT [join $fields ,] FROM $lookup_table $extra_from"
	} else {
		set sql "SELECT [join $fields ,] FROM $db_table INNER JOIN shot ON ${db_table}.clock=shot.clock "
	}
	
	append sql "WHERE LENGTH(TRIM(COALESCE($field_name,''))) > 0 "
	if { $exc_removed_shots == 1 && $use_lookup_table == 0 } { append sql "AND shot.removed=0 " }
	if { $filter ne "" } { append sql "AND $filter " }
	if { [llength $extra_wheres] > 0 } { append sql "AND [join $extra_wheres { AND }] "  }
	
	if { $use_lookup_table != 1 } {
		append sql "GROUP BY [join $grouping_fields { AND }] "
	}		

	append sql "ORDER BY "
	if { $field_name eq "grinder_setting" } {
		# TODO Include sorting in data dictionary!
		append sql "TRIM($field_name)"
	} elseif { $use_lookup_table == 1 }  { 
		if { $type1_db_table ne ""} {
			append sql "${type1_db_table}.sort_number,"
		}
		append sql "sort_number"
	} else {
		append sql "MAX(shot.clock)"
	}
	
#set ::DYE::debug_text $sql
#msg "DYE DEBUG available_categories for $field_name, sql=$sql"
	if { [llength $fields] == 1 } {
		return [db eval "$sql"]
	} else {
		array set result {}
		
		db eval "$sql LIMIT 1" columns break
		set fields $columns(*)
#msg "DYE DEBUG available_categories, columns=$fields"
		
		foreach fn $fields { set result($fn) {} }
		db eval "$sql" {
			for {set i 0} {$i < [llength $fields]} {incr i 1} {
				lappend result([lindex $fields $i]) [subst $[lindex $fields $i]]
			}
		}
		return [array get result]
	}
}

# Returns data for shots that use a given category.  
# 'field_name' must be available in the data dictionary with data_type=category.
# 'return_what' is a list of column names to return, or 'count' for just the number of shots. If a single column
#	is requested, a list is returned. If more than one column is returned, returns an array with one list per 
#	column.
# 'args' provide 'type' values that must be matched in the target db table (e.g. for an equipment item, its equipment type).
proc ::DYE::DB::shots_using_category { field_name value {return_what clock} args } {
	set db [get_db]
	lassign [::DYE::field_lookup $field_name {data_type db_table db_type_column1 db_type_column2}] \
		data_type db_table db_type_column1 db_type_column2
	if { $data_type ne "category" } { return {} }
	
	if { $db_table eq "shot" } {
		if { $return_what eq "count" } { 
			set sql "SELECT COUNT(clock) "
		} else { 
			set sql "SELECT [join $return_what ,] "
		}
		append sql " FROM V_shot WHERE removed=0 AND $field_name=[::DYE::DB::string2sql $value] ORDER BY clock DESC"
	} else {
		if { $return_what eq "count" } { 
			set sql "SELECT COUNT(DISTINCT t.clock) " 
		} else { 
			set sql "SELECT DISTINCT [join $return_what ,] " 
		}
		append sql "FROM $db_table t INNER JOIN V_shot s ON t.clock=s.clock WHERE t.$field_name=[::DYE::DB::string2sql $value] "
		if { $db_type_column1 ne "" && [llength $args] > 0 } {
			append sql "AND $db_type_column1=[::DYE::DB::string2sql [lindex $args 0]] " 
		}
		if { $db_type_column2 ne "" && [llength $args] > 1 } {
			append sql "AND $db_type_column2=[::DYE::DB::string2sql [lindex $args 1]] " 
		}
		append sql "ORDER BY t.clock DESC"
	}
	
msg "DYE DB DEBUG shots_using_category, sql=$sql"	
	if { [llength $return_what] == 1 } {
		return [db eval "$sql"]
	} else {
		array set result {}
		foreach fn $return_what { set result($fn) {} }
		db eval "$sql" {
			for {set i 0} {$i < [llength $return_what]} {incr i} {
				lappend result([lindex $return_what $i]) [subst $[lindex $return_what $i]]
			}
		}		
		return [array get result]
	}
}

# Updates a category value both in the database and in all shot files that used it.
# Returns the list of modified shot file names (basenames only, no path nor extension).
proc ::DYE::DB::update_category { field_name old_value new_value { update_files 1 } } {
	set db [get_db]
	set filenames {}
	set clocks {}
	set new_value [string trim $new_value]
	
	set sql "SELECT clock, filename FROM shot WHERE $field_name=[::DYE::DB::string2sql $old_value]"
	db eval "$sql" {
		lappend clocks $clock
		lappend filenames $filename
	}

	set i 0
	foreach shot_file $filenames {
		# Update in shot history files			
		if { [file exists "[homedir]/history/${shot_file}.shot"] } {
			set path "[homedir]/history/${shot_file}.shot"		
		} elseif { [file exists "[homedir]/history_archive/${shot_file}.shot"] } {
			set path "[homedir]/history_archive/${shot_file}.shot"		
		} else {
			set path {}
		}
			
		if { $path eq "" } {
			set fmtime "NULL"
		} else {
			if { $update_files == 1 } {
				array set new_settings {} 
				set new_settings($field_name) $new_value 
				::DYE::modify_shot_file $path new_settings
			}			
			set fmtime [file mtime $path]
		}
	
		# Update in database
		if { $::DYE::settings(db_persist_desc) == 1 } {
			set sql "UPDATE shot SET file_modification_date=COALESCE($fmtime,file_modification_date), $field_name=[::DYE::DB::string2sql $new_value] WHERE clock=[lindex $clocks $i]"
			msg "DYE: $sql"
			db eval "$sql"
		}
		
		incr i
	}

	# Update in-memory variables, if they happen to use that category value
	if { $::settings($field_name) eq $old_value } {
		set ::settings($field_name) $new_value
		::DYE::define_last_shot_desc
	}
	if { $::DSx_settings(past_$field_name) eq $old_value } {
		set ::DSx_settings(past_$field_name) $new_value
		::DYE::define_past_shot_desc
	}
	if { $::DSx_settings(past_${field_name}2) eq $old_value } {
		set ::DSx_settings(past_${field_name}2) $new_value
		::DYE::define_past_shot_desc2
	}
	if { $::DYE::settings(next_$field_name) eq $old_value } {
		set ::DYE::settings(next_$field_name) $new_value
		::DYE::define_next_shot_desc
	}	
	if { $::DYE::DE::data($field_name) eq $old_value } {
		set "::DYE::DE::data($field_name)" $new_value
	}
	
	update_last_updated
	::save_settings
	::save_DSx_settings
	::DYE::save_settings
	
	return $filenames
}
	
# Updates a category value both in the database and in shot files that used it.
# Returns the list of modified shot file names (basenames only, no path nor extension).
# 'field_name' must be available in the data dictionary with data_type=category.
proc ::DYE::DB::NEW_update_category { field_name old_value new_value { use_specified_files 1 } { files_to_modify {} } args } {
	set db [get_db]
	set filenames {}
	set clocks {}
	set update_shots 1
	
	if { [string trim $old_value] eq "" || $old_value eq $new_value } { return }
	set new_value [string trim $new_value]
	lassign [::DYE::field_lookup $field_name {data_type db_table db_type_column1 db_type_column2 \
		shot_field lookup_table desc_section}] \
		data_type db_table db_type_column1 db_type_column2 shot_field lookup_table desc_section
	if { $data_type ne "category" } { return }

	if { $use_specified_files == 1 && [llength $files_to_modify] == 0 } { 
		set update_shots 0
	}

	if { $db_table eq "shot" } {
		set sql "SELECT s.clock, s.filename FROM shot s WHERE s.removed=0 AND $field_name=[::DYE::DB::string2sql $old_value] "
		set sql_count "SELECT COUNT(clock) FROM shot s WHERE s.removed=0 AND $field_name=[::DYE::DB::string2sql $old_value] "
	} else {
		set sql "SELECT s.clock, s.filename FROM $db_table t INNER JOIN V_shot s ON t.clock=s.clock 
			WHERE s.removed=0 AND $field_name=[::DYE::DB::string2sql $old_value] "
		set sql_count "SELECT COUNT(DISTINCT s.clock) FROM $db_table t INNER JOIN V_shot s ON t.clock=s.clock 
			WHERE s.removed=0 AND $field_name=[::DYE::DB::string2sql $old_value] "			
	}
	if { $use_specified_files == 1 } {
		if { [llength $files_to_modify] == 0 } { set update_shots 0 }
		append sql "AND s.filename IN ([::DYE::DB::strings2sql $files_to_modify]) "
	}
	if { $db_type_column1 ne "" && [llength $args] > 0 } {
		append sql "AND $db_type_column1=[::DYE::DB::string2sql [lindex $args 0]] "
		append sql_count "AND $db_type_column1=[::DYE::DB::string2sql [lindex $args 0]] "
	}
	if { $db_type_column2 ne "" && [llength $args] > 1 } {
		append sql "AND $db_type_column2=[::DYE::DB::string2sql [lindex $args 1]] "
		append sql_count "AND $db_type_column1=[::DYE::DB::string2sql [lindex $args 0]] "
	}
	append sql "ORDER BY s.clock DESC"	

#msg "DYE DEBUG NEW_update_category, sql_count=$sql_count"
#msg "DYE DEBUG NEW_update_category, sql=$sql"
	set n_total_shots_using_category [db eval "$sql_count"]
		
	set i 0
	if { $update_shots == 1 } {
		db eval "$sql" {
			lappend clocks $clock
			lappend filenames $filename
		}
	
		foreach shot_file $filenames {
			# Update shot history files
			set path [DYE::get_shot_file_path $shot_file]

			if { $path eq "" } {
				set fmtime "NULL"
				msg "DYE ERROR: can't find shot file ${shot_file}.shot for modifying category $category"
			} else {
				array set new_settings {}
				if { $db_table eq "shot" } {
					set new_settings($field_name) $new_value
				} else {
					# This works for both equipment_type and equipment_name, review in future cases
					set new_settings("~$field_name") [list $old_value $new_value] 	
				}
				::DYE::modify_shot_file $path new_settings
				
				set fmtime [file mtime $path]
			}
		
			# Update database
			if { $::DYE::settings(db_persist_desc) == 1 } {
				set sql "UPDATE shot SET file_modification_date=COALESCE($fmtime,file_modification_date)"
				if { $db_table eq "shot" } {
					append sql ",$field_name=[::DYE::DB::string2sql $new_value]" 
				}						
				append sql " WHERE clock=[lindex $clocks $i] AND $field_name=[::DYE::DB::string2sql $old_value]"
				#msg "DYE DB: $sql"
				db eval "$sql"
				
				if { $db_table ne "shot" } {
					set sql "UPDATE $db_table SET $field_name=[::DYE::DB::string2sql $new_value] 
						WHERE clock=[lindex $clocks $i] AND $field_name=[::DYE::DB::string2sql $old_value] "
					if { $db_type_column1 ne "" && [llength $args] > 0 } {
						append sql "AND $db_type_column1=[::DYE::DB::string2sql [lindex $args 0]] " 
					}
					if { $db_type_column2 ne "" && [llength $args] > 1 } {
						append sql "AND $db_type_column2=[::DYE::DB::string2sql [lindex $args 1]] " 
					}						
					# msg "DYE DB: $sql
					db eval "$sql"
				}
			}
			
			incr i
		}
		
		if { $i > 0 } update_last_updated
	}
	
#msg "DYE DEBUG: NEW_update_category: n_total_shots_using_category=$n_total_shots_using_category, i=$i"	
	# Update category db lookup table, if necessary (other_equipment elements). Because the change may have only
	# affected some shots, we don't know whether we need to update the category (no longer used), so we check
	# existence first.
	if { $lookup_table ne "" && $n_total_shots_using_category == $i} {
		# Are there still shots using the old value? If there is, do nothing. If there aren't, update the lookup table. 
	
		set sql "UPDATE $lookup_table SET $field_name=[::DYE::DB::string2sql $new_value] WHERE $field_name=[::DYE::DB::string2sql $old_value] "
		if { $db_type_column1 ne "" && [llength $args] > 0 } {
			append sql "AND $db_type_column1=[::DYE::DB::string2sql [lindex $args 0]] "
		}
		if { $db_type_column2 ne "" && [llength $args] > 1 } {
			append sql "AND $db_type_column2=[::DYE::DB::string2sql [lindex $args 1]] "
		}

#msg "DYE DEBUG: NEW_update_category: $sql"
		db eval "$sql"
		
		if { $desc_section eq "equipment" } { ::DYE::DB::update_equipment_categories }
		
		# TODO: Use the data dictionary 
#		if { $desc_section eq "equipment" } {
#			if { $field_name eq "equipment_type" } {
#				set existing_new_type [db eval { SELECT equipment_name FROM equipment_type WHERE equipment_name=$new_value }]
#				if { $existing_new_type eq "" } {
#					db eval { UPDATE equipment_type SET equipment_name=$new_value WHERE equipment_name=$old_value }
#				} else {
#					db eval { DELETE FROM equipment_type WHERE equipment_name=$old_value }
#				}
#				db eval { UPDATE equipment SET equipment_type=$new_value WHERE equipment_type=$old_value }
#			} elseif { $field_name eq "equipment_name" } {
#				set existing_new_equipment [db eval { SELECT equipment_name FROM equipment 
#					WHERE equipment_name=$new_value AND equipment_type=$equipment_type }]
#				if { $existing_new_equipment eq "" } {
#					db eval { UPDATE equipment SET equipment_name=$new_value 
#						WHERE equipment_name=$old_value AND equipment_type=$equipment_type }
#				} else {
#					db eval { DELETE FROM equipment WHERE equipment_name=$old_value AND equipment_type=$equipment_type }
#				}										
#			}
#			::DYE::DB::update_equipment_categories
#		}		
	}
	
	# Update in-memory variables, if they happen to use that category value
	if { $db_table eq "shot" } {
		if { [info exists ::settings($field_name)] && $::settings($field_name) eq $old_value } {
			set ::settings($field_name) $new_value
			::DYE::define_last_shot_desc
		}
		if { [info exists ::DSx_settings(past_$field_name)] && $::DSx_settings(past_$field_name) eq $old_value } {
			set ::DSx_settings(past_$field_name) $new_value
			::DYE::define_past_shot_desc
		}
		if { [info exists ::DSx_settings(past_${field_name}2)] && $::DSx_settings(past_${field_name}2) eq $old_value } {
			set ::DSx_settings(past_${field_name}2) $new_value
			::DYE::define_past_shot_desc2
		}
		if { [info exists ::DYE::settings(next_$field_name)] && $::DYE::settings(next_$field_name) eq $old_value } {
			set ::DYE::settings(next_$field_name) $new_value
			::DYE::define_next_shot_desc
		}	
		if { [info exists ::DYE::DE::data($field_name)] && $::DYE::DE::data($field_name) eq $old_value } {
			set "::DYE::DE::data($field_name)" $new_value
		}
	} elseif { $shot_field ne "" } {
		if { [info exists ::settings($shot_field)] && $::settings($shot_field) ne "" } {
			set ::settings($shot_field) [::DYE::modify_$shot_field $::settings($shot_field) $field_name $old_value $new_value]
		}
		if { [info exists ::DSx_settings(past_$field_name)] && $::DSx_settings(past_$shot_field) ne "" } {
			set ::DSx_settings(past_$shot_field) [::DYE::modify_$shot_field $::DSx_settings(past_$shot_field) \
				$field_name $old_value $new_value]
		}
		if { [info exists ::DSx_settings(past_${field_name}2)] && $::DSx_settings(past_${shot_field}2) ne "" } {
			set ::DSx_settings(past_${shot_field}2) [::DYE::modify_$shot_field $::DSx_settings(past_${shot_field}2) \
				$field_name $old_value $new_value]
		}
		if { [info exists ::DYE::settings(next_$field_name)] && $::DYE::settings(next_$shot_field) ne "" } {
			set ::DYE::settings(next_${shot_field}) [::DYE::modify_$shot_field $::DYE::settings(next_$shot_field) \
				$field_name $old_value $new_value]
		}	
		if { [info exists ::DYE::DE::data($field_name)] && $::DYE::DE::data($field_name) ne "" } {
			set "::DYE::DE::data($shot_field)" [::DYE::modify_$shot_field $::DYE::DE::data($shot_field) \
				$field_name $old_value $new_value]
		}
	} else {
		msg "DYE ERROR: DB::update_category - can't modify $field_name value in memory variables"
	}
	
	::save_settings
	::save_DSx_settings
	::DYE::save_settings
	
	return $filenames
}

# Adds a new category value to a lookup table. Note that categories that are entered directly in shots (like 
# 	grinder_model) don't have a lookup table and can't be added to.
# Returns the number of insertions done, 0 if none.
# 'args', if specified, gives extra column_name column_value pairs to insert.  
proc ::DYE::DB::add_category { field_name new_value {type1 {}} {type2 {}} args } {
	set db [get_db]
	set new_value [string trim $new_value]
	if { $new_value eq "" } { return 0 }
	
	lassign [::DYE::field_lookup $field_name {data_type db_type_column1 db_type_column2 lookup_table}] \
		data_type db_type_column1 db_type_column2 lookup_table
	if { $data_type ne "category" } { return }
	
	set fields {}
	set field_values {}
	lappend fields $field_name
	lappend field_values [::DYE::DB::string2sql $new_value]
	set where_conds {}
	if { $db_type_column1 ne "" && $type1 ne "" } {
		lappend where_conds "$db_type_column1=[::DYE::DB::string2sql $type1]"
		lappend fields "$db_type_column1"
		lappend field_values [::DYE::DB::string2sql $type1]
	}
	if { $db_type_column2 ne "" && $type2 ne "" } {
		lappend where_conds "$db_type_column2=[::DYE::DB::string2sql $type2]"
		lappend fields "$db_type_column2"
		lappend field_values [::DYE::DB::string2sql $type2]
	}
	
	if { [llength $args] > 0 } {
		for { set i 0 } { $i < [llength $args] } { incr i 2 } {
			if { [expr {$i+1}] < [llength $args] } {
				lappend fields [lindex $args $i]
				lappend field_values [lindex $args [expr {$i+1}]]
			}
		}
	}
	lappend fields "sort_number"
	lappend field_values "(SELECT (COUNT($field_name)+1)*10 FROM $lookup_table)"
	
	set check_sql "SELECT $field_name FROM $lookup_table WHERE $field_name=[::DYE::DB::string2sql $new_value] "
	if { $where_conds ne "" } { append check_sql " AND [join $where_conds { AND }]" }
	#msg "DYE DB add_category, check_sql=$check_sql"	
	if { [db exists "$check_sql"] } { return 0 }
	
	set insert_sql "INSERT INTO $lookup_table ([join $fields ,]) VALUES ([join $field_values ,])"
	
	msg "DYE DB add_category, insert_sql=$insert_sql"	
	db eval "$insert_sql"	
	return [db changes]
}

proc ::DYE::DB::remove_category { field_name value {type1 {}} {type2 {}} } {
	set db [get_db]
	if { $value eq "" } { return 0 }

	set n_shots [shots_using_category $field_name $value "count" $type1 $type2]
	if { $n_shots > 0 } { return 0 }
	
	lassign [::DYE::field_lookup $field_name {data_type db_type_column1 db_type_column2 lookup_table}] \
		data_type db_type_column1 db_type_column2 lookup_table
	if { $data_type ne "category" } { return }
	
	set sql "DELETE FROM $lookup_table WHERE $field_name=[::DYE::DB::string2sql $value]"
	if { $db_type_column1 ne "" && $type1 ne "" } {
		append sql " AND $db_type_column1=[::DYE::DB::string2sql $type1]"
	}
	if { $db_type_column2 ne "" && $type2 ne "" } {
		append sql " AND $db_type_column2=[::DYE::DB::string2sql $type2]"
	}

	db eval "$sql"
	return [db changes]
}

# Returns whether the database contains some chart series data.
proc ::DYE::DB::has_shot_series_data {} {
	set db [get_db]
	return [db eval { SELECT EXISTS(SELECT 1 FROM shot_series LIMIT 1) }]
}

# Number of shots that have no chart series data.
proc ::DYE::DB::n_shots_without_series {} {
	set db [get_db]
	return [db eval { SELECT COUNT(DISTINCT clock) FROM shot s LEFT JOIN shot_series ss ON s.clock=ss.shot_clock 
		WHERE ss.shot_clock IS NULL } ]
}

proc ::DYE::DB::previous_values { field_name {exc_removed_shots 1} {filter {}} {max_items 500} } {
	set db [get_db]	
	lassign [::DYE::field_lookup $field_name {data_type db_table lookup_table db_type_column1 db_type_column2}] \
		data_type db_table lookup_table db_type_column1 db_type_column2 
	if { $data_type eq "" } {
		msg "DYE: ERROR in DYE::DB::previous_values, '$field_name' not found in data dictionary"
		return
	}
	
	set fields {}
	set grouping_fields {}
	lappend fields "$field_name"
	lappend grouping_fields "$field_name"
	
	if { $db_table eq "shot" } {
		set sql "SELECT [join $fields ,] FROM shot "
	} else {
		set sql "SELECT [join $fields ,] FROM $db_table t INNER JOIN shot ON t.clock=shot.clock "
	}
	
	append sql "WHERE LENGTH(TRIM(COALESCE($field_name,''))) > 0 "
	if { $exc_removed_shots == 1  } { append sql "AND shot.removed=0 " }
	if { $filter ne "" } { append sql "AND $filter " }
	append sql "GROUP BY [join $grouping_fields ,] "
	append sql "ORDER BY MAX(shot.clock)"
	
	#msg "DYE: previous_values sql=$sql"
	if { [llength $fields] == 1 } {
		return [db eval "$sql LIMIT $max_items"]
	} else {
		array set result {}
		
		db eval "$sql LIMIT 1" columns break
		set fields $columns(*)
				
		foreach fn $fields { set result($fn) {} }
		db eval "$sql LIMIT $max_items" {
			for {set i 0} {$i < [llength $fields]} {incr i 1} {
				lappend result([lindex $fields $i]) [subst $[lindex $fields $i]]
			}
		}		
		return [array get result]
	}
	
} 

# Deletes all chart series data.
proc ::DYE::DB::delete_shot_series_data {} {
	set db [get_db]
	db eval { DELETE FROM shot_series }
}
		
### "DESCRIBE YOUR ESPRESSO" PAGE #####################################################################################

namespace eval ::DYE::DE {
	variable widgets
	array set widgets {}
	
	# Widgets in the page bind to variables in this data array, not to the actual global variables behind, so they 
	# can be changed dynamically to load and save to different shots (last, next or those selected in the left or 
	# right of the history viewer). Values are actually saved only when tapping the "Done" button.
	variable data
	array set data {
		page_name "::DYE::DE"
		page_title {translate {Describe your espresso}}
		# current / past / past2
		describe_which_shot {current}
		comes_from_sleep 0
		read_from_status "last"
		read_from_last_text "Read from\rlast shot" 
		read_from_prev_text "Read from\rselection"
		read_from_label {}
		shot_file {}
		clock 0
		grinder_dose_weight 0
		drink_weight 0
		bean_brand {}
		bean_type {}
		roast_date {}
		roast_level {}
		bean_notes {}
		grinder_model {}
		grinder_setting {}
		drink_tds 0
		drink_ey 0
		espresso_enjoyment 0
		espresso_notes {}
		my_name {}
		drinker_name {}
		skin {}
		beverage_type {}
		upload_to_visualizer_label {}
		repository_links {}
	}
	#		other_equipment {}

	# src_data contains a copy of the source data when the page is loaded. So we can easily check whether something
	# has changed.
	variable src_data
	array set src_data {}
}

proc ::DYE::DE::load_page { which_shot { comes_from_sleep 0 } } {
	variable data
	set ns [namespace current]
	set data(describe_which_shot) $which_shot
	set data(comes_from_sleep) $comes_from_sleep
	
	if { [::DYE::DE::load_description] == 0 } {
		tk_messageBox -message "[translate {The requested shot description is not available}]" \
			-type ok -default ok -icon info
		return
	}
	
	set ::current_espresso_page "off"
	page_to_show_when_off $ns
	
	DYE::GUI::relocate_dropdown_arrows ::DYE::DE::widgets "bean_brand bean_type roast_level grinder_model \
		grinder_setting my_name drinker_name"
}

# This is added to the page context actions, so automatically executed every time (after) the page is shown.
proc ::DYE::DE::show_page {} {
	variable widgets
	variable data
	set ns [namespace current]
	
	if { $::DYE::settings(use_stars_to_rate_enjoyment) == 1 } {
		::DYE::GUI::hide_widgets "espresso_enjoyment espresso_enjoyment_clicker*" $ns

		for { set i 1 } { $i <= 5 } { incr i } {
			.can itemconfig $widgets(espresso_enjoyment_rating$i) -state normal
			.can itemconfig $widgets(espresso_enjoyment_rating_half$i) -state hidden
		}
		::DYE::GUI::show_widgets "espresso_enjoyment_rating_button" $ns
	} else {
		::DYE::GUI::show_widgets "espresso_enjoyment espresso_enjoyment_clicker*" $ns
		
		for { set i 1 } { $i <= 5 } { incr i } {
			.can itemconfig $widgets(espresso_enjoyment_rating$i) -state hidden
			.can itemconfig $widgets(espresso_enjoyment_rating_half$i) -state hidden
		}
		::DYE::GUI::hide_widgets "espresso_enjoyment_rating_button" $ns
	}

	if { $data(describe_which_shot) eq "next" } {
		::DYE::GUI::disable_widgets "grinder_dose_weight* drink_weight* drink_tds* drink_ey* espresso_enjoyment* \
			espresso_enjoyment_rating*" $ns
	} else {
		::DYE::GUI::enable_widgets "grinder_dose_weight* drink_weight* drink_tds* drink_ey* espresso_enjoyment*" $ns
		if { $::DYE::settings(use_stars_to_rate_enjoyment) == 1 } {
			::DYE::GUI::enable_widgets "espresso_enjoyment_rating*" $ns
			::DYE::GUI::draw_rating $ns espresso_enjoyment 5
		}
	}
	
	::DYE::DE::grinder_model_change
	::DYE::DE::update_visualizer_button 0
}
	
proc ::DYE::DE::unload_page {} {
	variable data
	if { $data(comes_from_sleep) == 1 } {
		set ::DYE::DE::data(comes_from_sleep) 0
		set_next_page off off
		set ::current_espresso_page "off"
		start_sleep
	} elseif { $data(describe_which_shot) eq "current" || $data(describe_which_shot) eq "next" } {
		set_next_page off off
		start_idle
		page_show off
	} else {
		set_next_page off DSx_past
		page_show off
	}	
}
	
proc ::DYE::DE::setup_ui {} {
	variable data
	variable widgets
	set page [namespace current]
	
	::DYE::GUI::add_page $page -buttons_loc right 
	
	# LEFT COLUMN 
	set x_left_label 100; set x_left_field 400; set width_left_field 28; set x_left_down_arrow 990
	
	# BEANS DATA
	add_de1_image $page $x_left_label 150 "[skin_directory_graphics]/icons/bean.png"
	add_de1_text $page $x_left_field 250 -font [DSx_font font 10] -fill $::DSx_settings(font_colour) \
		-anchor "nw" -text [translate "Beans"]
	set x 570; set y 245
	add_de1_text $page $x $y -font fontawesome_reg_small \
		-fill $::DSx_settings(font_colour) -anchor "nw" -justify "left" -text $::DYE::GUI::symbol_sort_down	
	add_de1_button $page {
		say "" $::settings(sound_button_in)
		DYE::IS::load_page beans ::DYE::DE::select_beans_callback \
			"$DYE::DE::data(bean_brand) $DYE::DE::data(bean_type) $DYE::DE::data(roast_date)" 
		} [expr {$x-200}] $y [expr {$x+60}] [expr {$y+75}]

	# Beans roaster / brand 
	set y 350
	::DYE::GUI::add_text_entry $page bean_brand $x_left_label $y $x_left_field $y $width_left_field \
		-dropdown_callback_cmd "::DYE::DE::select_category_callback"
	
	# Beans type/name
	incr y 100
	::DYE::GUI::add_text_entry $page bean_type $x_left_label $y $x_left_field $y $width_left_field \
		-dropdown_callback_cmd "::DYE::DE::select_category_callback"

	# Roast date
	incr y 100
	::DYE::GUI::add_text_entry $page roast_date $x_left_label $y $x_left_field $y $width_left_field

	# Roast level
	incr y 100
	::DYE::GUI::add_text_entry $page roast_level $x_left_label $y $x_left_field $y $width_left_field \
		-dropdown_callback_cmd "::DYE::DE::select_category_callback"

	# Bean notes
	incr y 100
	::DYE::GUI::add_multiline_entry $page bean_notes $x_left_label $y $x_left_field $y $width_left_field 3
	
	# EQUIPMENT
	set y 925
	add_de1_image $page $x_left_label $y "[skin_directory_graphics]/icons/niche.png"
	add_de1_text $page $x_left_field [expr {$y+130}] -font [DSx_font font 10] \
		-fill $::DSx_settings(font_colour) -anchor "nw" -text [translate "Equipment"]
	# Other equipment (EXPERIMENTAL)
	if { [info exists ::debugging] && $::debugging == 1 } {
		add_de1_button $page { say "" $::settings(sound_button_in); ::DYE::SEQ::load_page } \
			$x_left_label [expr {$y+50}] [expr {$x_left_field+400}] [expr {$y+200}]
	}
	
	# Grinder model
	incr y 240
	::DYE::GUI::add_text_entry $page grinder_model $x_left_label $y $x_left_field $y $width_left_field \
		-dropdown_callback_cmd "::DYE::DE::select_category_callback"
	
	# Grinder setting
	incr y 100
	::DYE::GUI::add_text_entry $page grinder_setting $x_left_label $y $x_left_field $y $width_left_field \
		-dropdown_cmd {say "" $::settings(sound_button_in)
			if { $::DYE::DE::data(grinder_model) eq "" } break
			DYE::IS::load_page grinder_setting ::DYE::DE::select_category_callback $::DYE::DE::data(grinder_setting) \
				single 1000 " grinder_model=[::DYE::DB::string2sql $::DYE::DE::data(grinder_model)]" }

	# EXTRACTION
	set x_right_label 1280; set x_right_field 1525
	add_de1_image $page $x_right_label 150 "[skin_directory_graphics]/icons/espresso.png"
	add_de1_text $page 1550 250 -font [DSx_font font 10] -fill $::DSx_settings(font_colour) \
		-anchor "nw" -text [translate "Extraction"]

	# Calc EY from TDS button
	::DYE::GUI::add_button2 $page calc_ey_from_tds 2000 125 [translate "Calc EY from TDS"] \
		{$::DYE::settings(calc_ey_from_tds)} "" ::DYE::DE::calc_ey_from_tds_click
	
	# Grinder Dose weight
	set y 350
	::DYE::GUI::add_text_entry $page grinder_dose_weight $x_right_label $y $x_right_field $y 8
	
	# Drink weight
	set offset 525
	::DYE::GUI::add_text_entry $page drink_weight [expr {$x_right_label+$offset}] $y [expr {$x_right_field+$offset}] $y 8

	# Total Dissolved Solids
	set x_hclicker_field 2050
	incr y 100	
	::DYE::GUI::add_text_entry $page drink_tds $x_right_label $y $x_hclicker_field $y 5 -clicker {} \
		-clicker_cmd ::DYE::DE::calc_ey_from_tds

	# Extraction Yield
	incr y 100
	::DYE::GUI::add_text_entry $page drink_ey $x_right_label $y $x_hclicker_field $y 5 -clicker {}
	
	# Enjoyment entry with horizontal clicker
	incr y 100
	::DYE::GUI::add_text_entry $page espresso_enjoyment $x_right_label $y $x_hclicker_field $y 5 -clicker {}
	bind $::DYE::DE::widgets(espresso_enjoyment) <KeyPress> { if {[string is entier %K] != 1} break }
	
	# Enjoyment stars rating (on top of the enjoyment text entry + arrows, then dinamically one or the other is hidden
	#	when the page is shown, depending on the settings)
	::DYE::GUI::add_rating $page espresso_enjoyment -1 -1 [expr {$x_hclicker_field-250}] $y 610
	
	# Espresso notes
	incr y 100
	::DYE::GUI::add_multiline_entry $page espresso_notes $x_right_label $y $x_right_field $y 45 5

	# PEOPLE
	set y 1030
	add_de1_image $page $x_right_label $y "[skin_directory_graphics]/icons/people.png"	
	add_de1_text $page $x_right_field [expr {$y+140}] -font [DSx_font font 10] \
		-fill $::DSx_settings(font_colour) -anchor "nw" -text [translate "People"]

	# Barista (my_name)
	incr y 240
	::DYE::GUI::add_text_entry $page my_name $x_right_label $y $x_right_field $y 15 \
		-dropdown_callback_cmd "::DYE::DE::select_category_callback"
	
	# Drinker name
	::DYE::GUI::add_text_entry $page drinker_name [expr {$x_right_label+700}] $y [expr {$x_right_field+600}] $y 15 \
		-dropdown_callback_cmd "::DYE::DE::select_category_callback"

	# BOTTOM BUTTONS	
	# Clear shot data (only clears "propagatable" fields)
	set x 100; set y 1385
	::DYE::GUI::add_button2 $page clear_shot_data $x $y [translate "Clear shot\rdata"] "" eraser \
		::DYE::DE::clear_shot_data_click	

	# Recover "propagatable" fields from a previous shot
	set x [expr {$x+$::DYE::GUI::button2_width+75}]
	set data(read_from_label) [translate $data(read_from_last_text)]
	::DYE::GUI::add_button2 $page read_from $x $y "" "" file_import \
		::DYE::DE::read_from_click

	# Upload to Miha's Visualizer button
	set x [expr {$x+$::DYE::GUI::button2_width+75}]
	set data(upload_to_visualizer_label) [translate "Upload to\rVisualizer"]
	::DYE::GUI::add_button2 $page upload_to_visualizer $x $y "" "" file_upload \
		::DYE::DE::upload_to_visualizer_click
	
	::add_de1_action $page ::DYE::DE::show_page
}

# Callback procedure returning control from the item_selection page to the describe_espresso page, to select a 
# source shot to be used for next shot propagation values. 
proc ::DYE::DE::select_shot_callback { shot_clock shot_desc item_type } {
	variable data
	page_to_show_when_off [namespace current]
	
	if { $shot_clock ne "" } {
		set sql "SELECT [join $::DYE::propagated_fields ,] FROM shot WHERE clock=$shot_clock"
		set db ::DYE::DB::get_db
		db eval $sql values {
			foreach f $::DYE::propagated_fields {
				set data($f) $values($f)
			}
		}
	}
}

# Callback procedure returning control from the item_selection page to the describe_espresso page, to select a 
# category item from the list of previously entered values. 
proc ::DYE::DE::select_category_callback { id value type } {
	variable data
	page_to_show_when_off [namespace current]
	
	if { $value ne "" } {
		set data($type) $value
		if { $type eq "grinder_model" } ::DYE::DE::grinder_model_change	
	}
}

proc ::DYE::DE::select_bean_brand_callback { id value type } {
	::DYE::DE::select_category_callback $id $value "bean_brand"
}

proc ::DYE::DE::select_bean_type_callback { id value type } {
	::DYE::DE::select_category_callback $id $value "bean_type"
}

proc ::DYE::DE::select_roast_level_callback { id value type } {
	::DYE::DE::select_category_callback $id $value "roast_level"
}

proc ::DYE::DE::select_roast_grinder_name_callback { id value type } {
	::DYE::DE::select_category_callback $id $value "grinder_name"
}


# Callback procedure returning control from the item_selection page to the describe_espresso page, to select the 
# full beans definition item from the list of previously entered values. 
proc ::DYE::DE::select_beans_callback { clock bean_desc item_type } {
	variable data
	page_to_show_when_off [namespace current]
		
	if { $bean_desc ne "" } {
		set db ::DYE::DB::get_db
		db eval {SELECT bean_brand,bean_type,roast_date,roast_level,bean_notes FROM shot \
				WHERE clock=$clock} {
			set data(bean_brand) $bean_brand
			set data(bean_type) $bean_type
			set data(roast_date) $roast_date
			set data(roast_level) $roast_level
			set data(bean_notes) $bean_notes
		}
	}
}

proc ::DYE::DE::grinder_model_change {} {
	variable data
	if { $data(grinder_model) eq "" } {
		::DYE::GUI::disable_widgets grinder_setting_dropdown* ::DYE::DE
	} else {
		::DYE::GUI::enable_widgets grinder_setting_dropdown* ::DYE::DE
	}
}

proc ::DYE::DE::clear_shot_data_click {} {
	say "clear" $::settings(sound_button_in)
	foreach f $DYE::propagated_fields {
		set ::DYE::DE::data($f) {}
	}
	set ::DYE::DE::data(espresso_notes) {}
#	if { $data(describe_which_shot) eq "next" } {
#		set ::DYE::settings(next_modified) 1
#	}
}

proc ::DYE::DE::read_from_click {} {
	variable data
	say "read" $::settings(sound_button_in)

	# Bring descriptive data from last shot (in-memory if editing the next description), if not using
	# the last shot use the DB to get it back.
	if { ![info exists ::DYE::DE::data(clock) ] || $::DYE::DE::data(clock) == 0 || $::DYE::DE::data(clock) eq {} } {			
		set filter "clock < [clock seconds]"
	} else {
		set filter "clock < $::DYE::DE::data(clock)"
	}
	set sql_conditions {}
	foreach f $::DYE::propagated_fields {
		lappend sql_conditions "LENGTH(TRIM(COALESCE($f,'')))>0"
	}
	
	if { $data(read_from_status) eq "prev" } {
		::DYE::IS::load_page shot DYE::DE::select_shot_callback {} "single" 100 \
			" $filter AND ([join $sql_conditions { OR }]) "
		set ::DYE::DE::data(read_from_status) "last"
	} else {
		set sql "SELECT [join $::DYE::propagated_fields ,] FROM shot \
			WHERE $filter AND ([join $sql_conditions { OR }]) \
			ORDER BY clock DESC LIMIT 1"			
		set db [::DYE::DB::get_db] 
		db eval "$sql" values {
			foreach f $::DYE::propagated_fields {
				set data($f) $values($f)
			}
		}
		
		set data(read_from_status) "prev"
	}
	
	set data(read_from_label) [translate $data(read_from_${data(read_from_status)}_text)]
#	if { $data(describe_which_shot) eq "next" } {
#		set DYE::settings(next_modified) 1
#	}
}

# Update the current shot description from the "next" description when doing a new espresso, if it has been
# modified by the user.
proc ::DYE::DE::reset_gui_starting_espresso_enter_hook { args } { 
	msg "DYE: reset_gui_starting_espresso_enter_hook"
	set propagate $::DYE::settings(propagate_previous_shot_desc)
	
#	if { $::DYE::settings(next_modified) == 1 } {
		foreach f $::DYE::propagated_fields {
			set ::settings($f) $::DYE::settings(next_$f)
#			if { $propagate == 0 } {
#				set ::DYE::settings(next_$f) {}
#			}
		}
#	} elseif { $propagate == 0 } {
#		foreach f $::DYE::propagated_fields {
#			set ::settings($f) {}
#		}
#	}
}


# Reset the "next" description and update the current shot summary description
proc ::DYE::DE::reset_gui_starting_espresso_leave_hook { args } {
#	msg "DYE: reset_gui_starting_espresso_leave_hook, ::android=$::android, ::undroid=$::undroid"	
#	msg "DYE: reset_gui_starting_espresso_leave - DSx settings bean_weight=$::DSx_settings(bean_weight), settings grinder_dose_weight=$::settings(grinder_dose_weight), DSx_settings live_graph_beans=$::DSx_settings(live_graph_beans)"
#	msg "DYE: reset_gui_starting_espresso_leave - settings drink_weight=$::settings(drink_weight), DSx_settings saw=$::DSx_settings(saw), settings final_desired_shot_weight=$::settings(final_desired_shot_weight), DSx_settings live_graph_weight=$::DSx_settings(live_graph_weight), DE1 scale_sensor_weight $::de1(scale_sensor_weight)"
#	msg "DYE: reset_gui_starting_espresso_leave - DYE_settings next_modified=$::DYE::settings(next_modified)"
	
#	if { $::DYE::settings(next_modified) == 1 } {
		# This can't be set on <enter> as it is blanked in reset_gui_starting_espresso
		set ::settings(espresso_notes) $::DYE::settings(next_espresso_notes)
		set ::DYE::settings(next_espresso_notes) {}
		set ::DYE::settings(next_modified) 0
#	}

	if { [info exists ::DSx_settings(live_graph_beans)] && $::DSx_settings(live_graph_beans) > 0 } {
		set ::settings(grinder_dose_weight) $::DSx_settings(live_graph_beans)
	} elseif { [info exists ::DSx_settings(bean_weight)] && $::DSx_settings(bean_weight) > 0 } {
		set ::settings(grinder_dose_weight) [round_to_one_digits [return_zero_if_blank $::DSx_settings(bean_weight)]]
	} else {
		set ::settings(grinder_dose_weight) 0
	}

	if { $::undroid == 1 } {
		if { [info exists ::DSx_settings(saw)] && $::DSx_settings(saw) > 0 } {
			set ::settings(drink_weight) [round_to_one_digits $::DSx_settings(saw)] 
		} elseif { [info exists ::settings(final_desired_shot_weight)] && $::settings(final_desired_shot_weight) > 0 } {
			set ::settings(drink_weight) [round_to_one_digits $::settings(final_desired_shot_weight)]
		} else {
			set ::settings(drink_weight) 0
		}
	} else {
		if { [info exists ::DSx_settings(live_graph_weight)] && $::DSx_settings(live_graph_weight) > 0 } {
			set ::settings(drink_weight) $::DSx_settings(live_graph_weight)
		# Don't use de1(scale_sensor_weight), if bluetooth scale disconnects then this is set to the previous shot weight
#		} elseif { $::de1(scale_sensor_weight) > 0 } {
#			set ::settings(drink_weight) [round_to_one_digits $::de1(scale_sensor_weight)]
		} elseif { [info exists ::DSx_settings(saw)] && $::DSx_settings(saw) > 0 } {
			set ::settings(drink_weight) [round_to_one_digits $::DSx_settings(saw)] 
		} elseif { [info exists ::settings(final_desired_shot_weight)] && $::settings(final_desired_shot_weight) > 0 } {
			set ::settings(drink_weight) [round_to_one_digits $::settings(final_desired_shot_weight)]
		} else {
			set ::settings(drink_weight) 0
		}
	}

	::DYE::define_last_shot_desc
	::DYE::define_next_shot_desc

	set ::settings(repository_links) {}
	
	# Settings already saved in reset_gui_starting_espresso, but as we have redefined them...
	# TODO ::save_settings FAILS HERE, reported to John, correction should be in next version.
	set de1appVersion [lindex [package versions de1app] 0]
	if { [package vcompare $de1appVersion 1.33.7] >= 0 } {
		::save_settings
	}
	::DYE::save_settings
}

# Reset the descriptions of the shot in the right of the History Viewer whenever the status of the right list is
# modified.
proc ::DYE::DE::history_godshots_switch_leave_hook { args } {
	if {$::DSx_settings(history_godshots) ne "history" } {
		set ::DYE::past_shot_desc2 {}
		set ::DYE::past_shot_desc_one_line2 {}
	}
}

# Opens the last shot, the shot on the left of the history viewer, or the shot on the right of the history
# 	viewer, and writes all relevant DYE fields to the ::DYE::DE page variables.
# Returns 1 if successful, 0 otherwise.
proc ::DYE::DE::load_description {} {
	variable widgets
	variable data
	variable src_data
	
#	foreach f {grinder_dose_weight drink_weight drink_tds drink_ey espresso_enjoyment} {
#		$widgets(${f}) configure -state normal
#	}
	
	set data(read_from_label) [translate $data(read_from_${data(read_from_status)}_text)]
	
	if { $data(describe_which_shot) eq "past" } {
		if { ! [info exists ::DSx_settings(past_clock)] } { return 0 }
		set data(clock) $::DSx_settings(past_clock)
						
		set data(shot_file) $::DSx_settings(past_shot_file)
		set data(page_title) "Describe past espresso: $::DSx_settings(shot_date_time)"

		foreach f $::DYE::desc_text_fields {
			if { [info exists ::DSx_settings(past_$f)] } {
				set data($f) [string trim $::DSx_settings(past_$f)]
			} else {
				set data($f) {}
			}
		}
		foreach f $::DYE::desc_numeric_fields {
			if { [info exists ::DSx_settings(past_$f)] } {
				set data($f) [DYE::return_blank_if_zero $::DSx_settings(past_$f)]
			} else {
				set data($f) {}
			}
		}
		
		# Bean and Drink weights past variable names don't follow the past_* naming convention, so we have to handle
		# them differently
		if { [return_zero_if_blank [ifexists ::DSx_settings(past_bean_weight) 0]] > 1 } {
			set data(grinder_dose_weight) $::DSx_settings(past_bean_weight)
		} else {
			set data(grinder_dose_weight) {}
		}
		
		if { [return_zero_if_blank [ifexists ::DSx_settings(drink_weight) 0]] > 1 } {
			set data(drink_weight) $::DSx_settings(drink_weight) 
#		} elseif { $::DSx_settings(past_final_desired_shot_weight) > 0 } {
#			set data(drink_weight) $::DSx_settings(past_final_desired_shot_weight)
		} else {
			set data(drink_weight) {}
		}

#		if { $data(drink_weight) eq "" && $::DSx_settings(past_final_desired_shot_weight) > 0 } {
#			set data(drink_weight) $::DSx_settings(past_final_desired_shot_weight)
#		}
	} elseif { $data(describe_which_shot) eq "past2" } {
		if { ! [info exists ::DSx_settings(past_clock2)] } { return 0 }
		set data(clock) $::DSx_settings(past_clock2)
		
		set data(shot_file) $::DSx_settings(past_shot_file2)
		set data(page_title) "Describe past espresso: $::DSx_settings(shot_date_time2)"
		
		foreach f $::DYE::desc_text_fields {
			if { [info exists ::DSx_settings(past_${f}2)] } {
				set data($f) [string trim $::DSx_settings(past_${f}2)]
			} else {
				set data($f) {}
			}
		}
		foreach f $::DYE::desc_numeric_fields {
			if { [info exists ::DSx_settings(past_${f}2)] } {
				set data($f) [DYE::return_blank_if_zero $::DSx_settings(past_${f}2)]
			} else {
				set data($f) {}
			}
		}

		# Bean and Drink weights past variable names don't follow the past_* naming convention, so we have to handle
		# them differently
		if { [return_zero_if_blank [ifexists ::DSx_settings(past_bean_weight2) 0]] > 1 } {
			set data(grinder_dose_weight) $::DSx_settings(past_bean_weight2)
		} else {
			set data(grinder_dose_weight) {}
		}
		
		if { [return_zero_if_blank [ifexists ::DSx_settings(drink_weight2) 0]] > 1} {
			set data(drink_weight) $::DSx_settings(drink_weight2) 
#		} elseif { $::DSx_settings(past_final_desired_shot_weight2) > 0 } {
#			set data(drink_weight) $::DSx_settings(past_final_desired_shot_weight2)
		} else {
			set data(drink_weight) {}
		}
		
#		if { $data(drink_weight) eq "" && $::DSx_settings(past_final_desired_shot_weight) > 0 } {
#			set data(drink_weight) $::DSx_settings(past_final_desired_shot_weight)
#		}
		
	} elseif { $data(describe_which_shot) eq "next" } {
		set data(clock) {}
		set data(shot_file) {}
		set data(page_title) "Describe your next espresso"

		foreach f {grinder_dose_weight drink_weight drink_tds drink_ey espresso_enjoyment} {
			set data($f) {}
#			$widgets($f) configure -state disabled
		}

#		foreach f {bean_brand bean_type roast_date roast_level bean_notes grinder_model grinder_setting \
#				other_equipment espresso_notes my_name drinker_name} 		
		foreach f {bean_brand bean_type roast_date roast_level bean_notes grinder_model grinder_setting \
				espresso_notes my_name drinker_name} {
			set data($f) [string trim $DYE::settings(next_$f)]
		}
		
		set data(grinder_dose_weight) {}
		set data(drink_weight) {}
		set data(repository_links) {}
	} else {
		if { ! [info exists ::settings(espresso_clock)] } { return 0 }
		# Assume $data(describe_which_shot) eq "current"
		set data(clock) $::settings(espresso_clock)
		
		set data(shot_file) "[homedir]/history/[clock format $::settings(espresso_clock) -format $::DYE::filename_clock_format].shot"
		set data(page_title) "Describe last espresso: [::DYE::DE::last_shot_date]"
		
		foreach f $::DYE::desc_text_fields {
			if { [info exists ::settings($f)] } {
				set data($f) [string trim $::settings($f)]
			} else {
				set data($f) {}
			}
		}		
		foreach f $::DYE::desc_numeric_fields {
			if { [info exists ::settings($f)] } {
				set data($f) [DYE::return_blank_if_zero $::settings($f)]
			} else {
				set data($f) {}
			}
		}
		
	}
		
	array set src_data {}
	foreach fn "$::DYE::desc_numeric_fields $::DYE::desc_text_fields" {
		set src_data($fn) $data($fn)
	}
	
	return 1
}


# Saves the local variables from the Describe Espresso page into the target variables depending on which
#	description we're editing (last shot, left on the history viewer, or right in the history viewer),
#	and saves the modified data in the correct history .shot file.
proc ::DYE::DE::save_description {} {
	variable data
	set needs_saving 0
	array set new_settings {}
	
	# $::settings(espresso_clock) may not be defined on a new install!
	if { [info exists ::settings(espresso_clock)] } {
		set last_clock $::settings(espresso_clock)
	} else {
		set last_clock 0
	}
	
	if { ($data(describe_which_shot) eq "past" && $::DSx_settings(past_clock) == $last_clock) || \
			($data(describe_which_shot) eq "past2" && $::DSx_settings(past_clock2) == $last_clock) } {
		set is_past_edition_of_current 1
	} else {
		set is_past_edition_of_current 0
	}
	
	if { $data(describe_which_shot) eq "past" || $data(describe_which_shot) eq "past2" } {
		if { $data(describe_which_shot) eq "past" || ($data(describe_which_shot) eq "past2" && \
				$::DSx_settings(past_clock) == $::DSx_settings(past_clock2)) } {
			set clock $::DSx_settings(past_clock) 
			foreach f $::DYE::desc_numeric_fields {
				if { ![info exists ::DSx_settings(past_$f)] || $::DSx_settings(past_$f) ne [return_zero_if_blank $data($f)] } {
					set ::DSx_settings(past_$f) [return_zero_if_blank $data($f)]
					set new_settings($f) [return_zero_if_blank $data($f)] 
					set needs_saving 1
					
					# These two don't follow the above var naming convention
					# These two don't follow the above var naming convention
					if { $f eq "grinder_dose_weight" && [return_zero_if_blank $data($f)] > 0 } {
						set ::DSx_settings(past_bean_weight) [round_to_one_digits $data(grinder_dose_weight)]
					}
					if { $f eq "drink_weight" && [return_zero_if_blank $data($f)] > 0 } {
						set ::DSx_settings(drink_weight) [round_to_one_digits $data(drink_weight)]
					}
				}
			}
			foreach f $::DYE::desc_text_fields {
				if { ![info exists ::DSx_settings(past_$f)] || $::DSx_settings(past_$f) ne $data($f) } {
					set ::DSx_settings(past_$f) [string trim $data($f)]
					set new_settings($f) $data($f)
					set needs_saving 1
				}
			}

			if { $needs_saving == 1 } { 
				::DYE::define_past_shot_desc 
				if { $::DSx_settings(past_clock) == $::DSx_settings(past_clock2) } {
					::DYE::define_past_shot_desc2
				}
				::save_DSx_settings
			}
		} 
		
		if { $data(describe_which_shot) eq "past2" || ($data(describe_which_shot) eq "past" && \
				$::DSx_settings(past_clock) == $::DSx_settings(past_clock2)) } {
			set clock $::DSx_settings(past_clock2) 
			foreach f $::DYE::desc_numeric_fields {
				if { ![info exists ::DSx_settings(past_${f}2)] || \
						$::DSx_settings(past_${f}2) ne [return_zero_if_blank $data($f)] } {
					set ::DSx_settings(past_${f}2) [return_zero_if_blank $data($f)]
					set new_settings($f) [return_zero_if_blank $data($f)]
					set needs_saving 1
					
					# These two don't follow the above var naming convention
					if { $f eq "grinder_dose_weight" && [return_zero_if_blank $data($f)] > 0 } {
						set ::DSx_settings(past_bean_weight2) [round_to_one_digits $data(grinder_dose_weight)]
					}
					if { $f eq "drink_weight" && [return_zero_if_blank $data($f)] > 0 } {
						set ::DSx_settings(drink_weight2) [round_to_one_digits $data(drink_weight)]
					}
				}
			}
			foreach f $::DYE::desc_text_fields {
				if { ![info exists ::DSx_settings(past_${f}2)] || $::DSx_settings(past_${f}2) ne $data($f) } {
					set ::DSx_settings(past_${f}2) $data($f)
					set new_settings($f) [string trim $data($f)]
					set needs_saving 1					
				}				
			}

			if { $needs_saving == 1 } { 
				::DYE::define_past_shot_desc2 
				if { $::DSx_settings(past_clock) == $::DSx_settings(past_clock2) } {
					::DYE::define_past_shot_desc
				}
			}
		}

		if { $needs_saving == 0 } { return }

		if { $is_past_edition_of_current == 0 } {
			::DYE::modify_shot_file $data(shot_file) new_settings
			
			if { $::DYE::settings(db_persist_desc) == 1 } {
				set new_settings(file_modification_date) [file mtime $data(shot_file)]
				::DYE::DB::update_shot_description $clock new_settings
			}
			
			::save_DSx_settings
			msg "DYE: Save past espresso to history"
		}
	} 
	
	if { $data(describe_which_shot) eq "current" || $is_past_edition_of_current == 1 } {
		foreach f $::DYE::desc_numeric_fields {
			if { ![info exists ::settings($f)] || $::settings($f) ne [return_zero_if_blank $data($f)] } {
				set ::settings($f) [return_zero_if_blank $data($f)]
				set new_settings($f) [return_zero_if_blank $data($f)]
				set needs_saving 1
			}			
		}
		foreach f $::DYE::desc_text_fields {
			if { ![info exists ::settings($f)] || $::settings($f) ne $data($f) } {
				set ::settings($f) [string trim $data($f)]
				set new_settings($f) [string trim $data($f)]
				set needs_saving 1

				if { $DYE::settings(next_modified) == 0 && [lsearch $::DYE::propagated_fields $f] > -1 && \
						$::DYE::settings(propagate_previous_shot_desc) == 1 } {
					set ::DYE::settings(next_$f) [string trim $data($f)]
				}
			}
		}

		set needs_save_DSx_settings 0
		if { [return_zero_if_blank $data(grinder_dose_weight)] > 0 && \
				[ifexists ::DSx_settings(live_graph_beans) {}] ne $data(grinder_dose_weight)} {
			set ::DSx_settings(live_graph_beans) [round_to_one_digits $data(grinder_dose_weight)]
			set needs_save_DSx_settings 1
		}
		if { [return_zero_if_blank $data(drink_weight)] > 0 && \
				[ifexists ::DSx_settings(live_graph_weight) {}] ne $data(drink_weight) } {
			set ::DSx_settings(live_graph_weight) [round_to_one_digits $data(drink_weight)]
			set needs_save_DSx_settings 1
		}

#		# TBD THIS IS TO UPDATE THE TEXT WITH THE WEIGHTS AND RATIOS BELOW THE LAST SHOT CHART IN THE MAIN PAGE,
#		# 	BUT THE TEXT IS NOT BEING UPDATED, UNLIKE IN THE HISTORY VIEWER.
#		if { [return_zero_if_blank $data(grinder_dose_weight)] > 0 && \
#				$data(grinder_dose_weight) != $::settings(DSx_bean_weight) } {
#			set ::settings(DSx_bean_weight) [round_to_one_digits $data(grinder_dose_weight)]
#		}
		
		if { $needs_save_DSx_settings } {
			::save_DSx_settings
		}
		if { $needs_saving == 1 } {
			::save_settings
			::DYE::save_settings
			::DYE::modify_shot_file $data(shot_file) new_settings
			if { $::DYE::settings(db_persist_desc) == 1 } {
				set new_settings(file_modification_date) [file mtime $data(shot_file)]
				::DYE::DB::update_shot_description $data(clock) new_settings
			}
			# OLD (before v1.11), wrongly stored profile changes for next shot made after making the shot but before editing last shot description.
			#::save_espresso_rating_to_history
			::DYE::define_last_shot_desc
			::DYE::define_next_shot_desc
		}
	}
	
	if { $data(describe_which_shot) eq "next" } {
#		foreach f {bean_brand bean_type roast_date roast_level bean_notes grinder_model grinder_setting \
#				other_equipment espresso_notes my_name drinker_name} 		
		foreach f {bean_brand bean_type roast_date roast_level bean_notes grinder_model grinder_setting \
				espresso_notes my_name drinker_name} {
			if { $DYE::settings(next_$f) ne $data($f) } {
				set ::DYE::settings(next_$f) [string trim $data($f)]
				set needs_saving 1
			}			
		}

		if { $needs_saving == 1 } {
			set ::DYE::settings(next_modified) 1
			::DYE::define_next_shot_desc
			::DYE::save_settings
		}		
	}
}

# A clone of DSx last_shot_date, but uses settings(espresso_clock) if DSx_settings(live_graph_time) is not
# available (e.g. if DSx_settings.tdb were manually removed). Also will allow future skin-independence.
proc ::DYE::DE::last_shot_date {} {
	if { [info exists ::DSx_settings(live_graph_time)] } {
		return [::last_shot_date]
	} elseif { [info exists ::settings(espresso_clock)] } {
		set last_shot_clock $::settings(espresso_clock)
		set date [clock format $last_shot_clock -format {%a %d %b}]
		if {$::settings(enable_ampm) == 0} {
			set a [clock format $last_shot_clock -format {%H}]
			set b [clock format $last_shot_clock -format {:%M}]
			set c $a
		} else {
			set a [clock format $last_shot_clock -format {%I}]
			set b [clock format $last_shot_clock -format {:%M}]
			set c $a
			regsub {^[0]} $c {\1} c
		}
		if {[ifexists $::settings(enable_ampm) 1] == 1} {
			set pm [clock format $last_shot_clock -format %P]
			} else {
			set pm ""
		}
		return "$date $c$b$pm"
	} else {
		return ""
	}
}

# Return 1 if some data has changed in the form.
proc ::DYE::DE::needs_saving { } {
	variable data
	variable src_data
	
	foreach fn $::DYE::desc_text_fields {
		if { $data($fn) ne $src_data($fn) } {
			return 1
		}
	}	
	foreach fn $::DYE::desc_numeric_fields {
		if { [return_zero_if_blank $data($fn)] != [return_zero_if_blank $src_data($fn)] } {
			return 1
		}
	}
	return 0
}

proc ::DYE::DE::calc_ey_from_tds_click {} {
	say "" $::settings(sound_button_in)
	if { $::DYE::settings(calc_ey_from_tds) eq "on" } {
		set ::DYE::settings(calc_ey_from_tds) off
	} else { 
		set ::DYE::settings(calc_ey_from_tds) on 
		::DYE::DE::calc_ey_from_tds
	}		
}

# Calculates the Extraction Yield % to be shown in the Describe Espresso page from the user-entered
# Total Dissolved Solids %, the dose and the drink weight. Uses standard formula.
proc ::DYE::DE::calc_ey_from_tds  {} {
	variable data 
	
	if { $::DYE::settings(calc_ey_from_tds) eq "on" } {		
		if { $data(drink_weight) > 0 && $data(grinder_dose_weight) > 0 && $data(drink_tds) > 0 } {
			set data(drink_ey) [round_to_two_digits [expr {$data(drink_weight) * $data(drink_tds) / \
				$data(grinder_dose_weight)}]]
		} else {
			set data(drink_ey) {}
		}
	}
}

proc ::DYE::DE::upload_to_visualizer_click {} {
	if { $::DYE::DE::data(repository_links) ne {} } {
		say [translate "browsing"] $::settings(sound_button_in)
		if { [llength $::DYE::DE::data(repository_links)] > 1 } {
			::DYE::web_browser [lindex $::DYE::DE::data(repository_links) 1]
		}
		return
	}
	
	say "" $::settings(sound_button_in)
	if { $::android == 1 && [borg networkinfo] eq "none" } {
		set ::DYE::DE::data(upload_to_visualizer_label) [translate "Failed\rNo wifi"]
		set ::DYE::settings(last_visualizer_result) "[translate {Upload failed}]: [translate {No wifi}]" 
		.can itemconfig $::DYE::DE::widgets(upload_to_visualizer_label) -fill $::DSx_settings(orange)
		update
		after 3000 { ::DYE::DE::update_visualizer_button }
		say "" $::settings(sound_button_out)
		return
	}
	
	# Ensure latest values are in the shot file in case they have changed
	if { [::DYE::DE::needs_saving] } {
		set answer [tk_messageBox -message "[translate {You have unsaved changes to the shot description.}]\r\
			[translate {Do you want to save your changes first?}]" \
			-type yesnocancel -icon question]
		if { $answer eq "yes" } { 
			::DYE::DE::save_description
		} elseif { $answer eq "cancel" } { 
			return 			
		}
	}
		
	set ::DYE::DE::data(upload_to_visualizer_label) [translate "Uploading..."]
	.can itemconfig $::DYE::DE::widgets(upload_to_visualizer_label) -fill $::DSx_settings(orange)
	update
	
	array set arr_changes {}
	set content [::DYE::modify_shot_file $::DYE::DE::data(shot_file) arr_changes 0 0]	
	set visualizer_id [::DYE::visualizer_upload $content]
	
	if { $visualizer_id eq "" } {
		set ::DYE::DE::data(upload_to_visualizer_label) [translate "Upload\rfailed"]
		update
		after 3000 ::DYE::DE::update_visualizer_button
	} else {
		set ::DYE::DE::data(upload_to_visualizer_label) [translate "Upload\rsuccessful"]
		set ::DYE::DE::data(repository_links) "Visualizer https://visualizer.coffee/shots/$visualizer_id"
		set arr_changes(repository_links) $::DYE::DE::data(repository_links)
		::DYE::modify_shot_file $::DYE::DE::data(shot_file) arr_changes
		update
		after 3000 ::DYE::DE::update_visualizer_button
	}
	say "" $::settings(sound_button_out)
}

proc ::DYE::DE::update_visualizer_button { {check_context 1} } {
	if { $check_context == 1 && $::de1(current_context) ne "::DYE::DE" } {
		msg "DYE WARNING: WRONG context in update_visualizer_button='$::de1(current_context)'"	
		return
	}

	if { $::DYE::DE::data(describe_which_shot) ne "next" && $::DYE::settings(visualizer_url) ne "" && \
			$::DYE::settings(visualizer_username) ne "" && $::DYE::settings(visualizer_password) ne ""  } {
		.can itemconfig $::DYE::DE::widgets(upload_to_visualizer_label) -fill $::DSx_settings(font_colour)
		foreach wn {_symbol _label _img ""} {
			.can itemconfig $::DYE::DE::widgets(upload_to_visualizer$wn) -state normal
		}
		if { $::DYE::DE::data(repository_links) eq {} } {
			.can itemconfig $::DYE::DE::widgets(upload_to_visualizer_symbol) -text $::DYE::GUI::symbol_file_upload
			set ::DYE::DE::data(upload_to_visualizer_label) [translate "Upload to\rVisualizer"]
		} else {
			.can itemconfig $::DYE::DE::widgets(upload_to_visualizer_symbol) -text $::DYE::GUI::symbol_file_contract
			set ::DYE::DE::data(upload_to_visualizer_label) [translate "See in\rVisualizer"]
		}
	} else {
		foreach wn {_symbol _label _img ""} {
			.can itemconfig $::DYE::DE::widgets(upload_to_visualizer$wn) -state hidden
		}		
	}
}

proc ::DYE::DE::page_cancel {} {
	if { [::DYE::DE::needs_saving] == 1 } {
		set answer [tk_messageBox -message "[translate {You have unsaved changes to the shot description.}]\r\
			[translate {Do you want to save your changes first?}]" \
			-type yesno -icon question]
		if { $answer eq "yes" } { 
			::DYE::DE::page_done 
			return
		}
	}
	
	say [translate {cancel}] $::settings(sound_button_in);
	::DYE::DE::unload_page
}

proc ::DYE::DE::page_done {} {
	say [translate {done}] $::settings(sound_button_in)
	::DYE::DE::save_description
	::DYE::DE::unload_page
}

### GENERIC ITEM SELECTION PAGE #######################################################################################

namespace eval ::DYE::IS {
	variable widgets
	array set widgets {
		items {}
		items_scrollbar {}
		items_slider 3
		advsteps_items {}
	}
		
	# State variables for the "Item select" page. Not persisted.
	variable data
	array set data {
		page_name "::DYE::IS"
		page_title {}
		item_type {bean_brand}
		selectmode {single}	
		callback_proc {}
		max_items 1000
		filter_string {}
		allow_modify 1
		page_title {}	
		filter_indexes {}
		item_ids {}
		item_values {}
		modified_value {}
		modified_result {}
	}
}

# Launches the dialog page to select an item. DON'T SHOW THE DYE_item_select PAGE ANY OTHER WAY!!
# Requires a callback command/procedure to return control to the calling page, it must be a function with three  
# arguments (item_id item_value item_type) that processes the result and moves to the source page (or somewhere else).
proc ::DYE::IS::load_page { item_type callback_proc {selected {}} {selectmode {single}} {max_items 1000} \
		{filter {}} {allow_modify 1} args } {	
	variable data
	variable widgets
	set ns [namespace current]
			
	set item_ids {}
	set items {}
	set db [::DYE::DB::get_db]
			
	if { $item_type eq "shot" } {
		set data(page_title) [translate {Select a shot}]
		set sql "SELECT clock, shot_desc FROM V_shot WHERE removed=0 "
		if { $filter ne "" } { append sql " AND $filter" }
		append sql " ORDER BY clock DESC LIMIT $max_items"
		
		db eval "$sql" {
				lappend item_ids $clock
				lappend items $shot_desc
			}
		set allow_modify 0
	} elseif { $item_type eq "beans" } {
		set data(page_title) [translate {Select the beans batch}]
		set sql "SELECT MAX(clock) AS clock, bean_desc FROM V_shot WHERE LENGTH(bean_desc) > 0 AND removed=0 "
		if { $filter ne "" } { append sql " AND  $filter" }
		append sql " GROUP BY bean_desc ORDER BY MAX(clock) DESC LIMIT $max_items"
		
		db eval "$sql" {
				lappend item_ids $clock
				lappend items $bean_desc
			}
		set allow_modify 0
	} elseif { $item_type eq "equipment_setting" } {
		set sql "SELECT equipment_setting FROM shot_equipment WHERE LENGTH(COALESCE(equipment_setting,'')) > 0 "
		if { $filter ne "" } { append sql " AND $filter" }
		append sql " GROUP BY equipment_setting ORDER BY MAX(clock) DESC LIMIT $max_items"

		set items [db eval $sql]
		set allow_modify 0
	} else {
		if { $item_type eq "bean_brand" } {
			set data(page_title) [translate {Select the beans roaster / brand}]
		} elseif { $item_type eq "bean_type" } {
			set data(page_title) [translate {Select the beans type / name}]
		} elseif { $item_type eq "roast_level" } {
			set data(page_title) [translate {Select the beans roast level}]
		} elseif { $item_type eq "grinder_model" } {
			set data(page_title) [translate {Select the grinder model}]
		} elseif { $item_type eq "grinder_setting" } {
			set data(page_title) [translate {Select the grinder setting}]
		} elseif { $item_type eq "my_name" } {
			set data(page_title) [translate {Select the barista name}]
		} elseif { $item_type eq "drinker_name" } {
			set data(page_title) [translate {Select the drinker name}]
		} else {
			return 			
		}

		set sql "SELECT TRIM($item_type) FROM shot \
			WHERE removed=0 AND LENGTH(TRIM(COALESCE($item_type,''))) > 0 "
		if { $filter ne "" } { append sql " AND $filter" }
		append sql " GROUP BY TRIM($item_type) "
		if { $item_type eq "grinder_setting" } {
			append sql "ORDER BY TRIM($item_type) LIMIT $max_items"
		} else { 
			append sql "ORDER BY MAX(clock) DESC LIMIT $max_items"
		}
		set items [db eval $sql]
	}				

	if { $selected ne "" } {
		if { [lsearch $items $selected] == -1 } {
			if { [llength $item_ids] > 0 } {
				lappend item_ids -1
			}
			lappend items $selected
		}
	}
					
	set data(item_type) $item_type
	set data(callback_proc) $callback_proc
	set data(selectmode) $selectmode
	set data(max_items) $max_items
	set data(filter) $filter
	set data(allow_modify) $allow_modify
	set data(item_ids) $item_ids
	set data(item_values) $items
	set data(filter_string) {}
	set data(filter_indexes) {}
	set data(modified_value) {}
	set data(modified_result) {} 
						
	set widget $widgets(items)
	$widget delete 0 end
	$widget insert 0 {*}$items
	
	page_to_show_when_off $ns
			
	::DYE::GUI::set_scrollbars_dims $ns "items"

	if { [llength $items] == 0 && $selected eq "" } {
		say [translate "no choices"] $::settings(sound_button_in)
		foreach fn "filter_string_label filter_string items_label items items_scrollbar modified_value_label \
			modified_value modify_label modify_img modify_button" {
			.can itemconfig $::DYE::IS::widgets($fn) -state hidden
		}
		.can itemconfig $::DYE::IS::widgets(empty_category_msg) -state normal
		hide_android_keyboard
		return
	} 

	foreach fn "filter_string_label filter_string items_label items items_scrollbar modified_value_label \
			modified_value modify_label modify_img modify_button" {
		.can itemconfig $::DYE::IS::widgets($fn) -state normal
	}
	.can itemconfig $::DYE::IS::widgets(empty_category_msg) -state hidden
					
	if { $allow_modify == 1 } {
		::DYE::GUI::enable_widgets "modified_value* modify_*" $ns
	} else {
		::DYE::GUI::disable_widgets "modified_value* modify_*" $ns
	}
			
	if { $selected ne "" } {
		set idx [lsearch -exact $items $selected]
		if { $idx >= 0 } {
			$widget selection set $idx
			$widget see $idx
			
			if { $allow_modify == 1 } {
				set data(modified_value) $selected
			}
		}
	}
	
	# Pause to avoid Teclast issue with the listboxes wrong selections when changing pages. But it does NOT WORK.
	#pause 300 
	hide_android_keyboard
}
		
# Setup the "Item select" page User Interface. 
proc ::DYE::IS::setup_ui {} {
	variable data
	variable widgets
	set page [namespace current]	

	::DYE::GUI::add_page $page -buttons_loc center
	
	# Items search entry box
	set entries_width 75
	::DYE::GUI::add_text_entry $page "filter_string" 380 150 400 150 $entries_width -label [translate "Filter values"] \
		-font [DSx_font font 8] -label_font [DSx_font font 8] -label_anchor "ne" -label_justify "right" 
	bind $widgets(filter_string) <KeyRelease> ::DYE::IS::filter_string_change 
	
	# Empty category message
	::DYE::GUI::add_text $page 1280 750 [translate "This category is currently empty.\r\
Available values are read from description data\rentered in this and previous shots.\r\r\
Please fill shots data in the previous page\rfor values to start appearing here."] \
		-widget_name empty_category_msg -font [DSx_font font 10] -fill $::DYE::GUI::remark_color \
		-anchor "center" -justify "center" -state hidden

	# Items listbox
	::DYE::GUI::add_listbox $page items 380 230 400 230 $entries_width 16 -font [DSx_font font 8] \
		-label [translate "Values"] -label_font [DSx_font font 8] -label_anchor "ne" -label_justify "right"
	bind $widgets(items) <<ListboxSelect>> ::DYE::IS::items_select
	
	# Modify selected item entrybox
	::DYE::GUI::add_text_entry $page "modified_value" 380 1300 400 1300 $entries_width -label [translate "Modify value"] \
		-font [DSx_font font 8] -label_font [DSx_font font 8] -label_anchor "ne" -label_justify "right" 
	bind $widgets(modified_value) <Leave> { hide_android_keyboard
		set ::DYE::IS::data(modified_value) [string trim $::DYE::IS::data(modified_value)] }
	
	# Modify button
	::DYE::GUI::add_button1 $page modify 2250 1260 "Modify" ::DYE::IS::modify_click
	
	# Modify result text
	add_de1_variable $page 2450 1450 -font [DSx_font font 10] -fill $::DSx_settings(orange) -anchor "ne" \
		-justify "right" -textvariable {$::DYE::IS::data(modified_result)} 
	
}

proc ::DYE::IS::filter_string_change {} {
	variable data
	set items_widget $::DYE::IS::widgets(items)
	set item_values $data(item_values)
	set filter_string $data(filter_string) 
	set filter_indexes $data(filter_indexes)
	
	if { [string length $filter_string ] < 3 } {
		# Show full list
		if { [llength $item_values] > [$items_widget index end] } {
			$items_widget delete 0 end
			$items_widget insert 0 {*}$item_values
		}
		set filter_indexes {}
	} else {
		set filter_indexes [lsearch -all -nocase $item_values "*$filter_string*"]

		$items_widget delete 0 end
		set i 0
		foreach idx $filter_indexes { 
			$items_widget insert $i [lindex $item_values $idx]
			incr i 
		}
	}
}

proc ::DYE::IS::items_select {} {
	variable data
	set widget $::DYE::IS::widgets(items)
	
	if { $data(allow_modify) == 1 } {
		if { [$widget curselection] eq "" } {
			set data(modified_value) {}
		} else {
			set data(modified_value) [$widget get [$widget curselection]]
		}
	}	
}

proc ::DYE::IS::modify_click {} {
	variable data	
	if { $data(allow_modify) != 1 } return
	
	say [translate {modify}] $::settings(sound_button_in)
	set items_widget $::DYE::IS::widgets(items)
	set sel_idx [$items_widget curselection]
	if { $sel_idx ne "" } {
		set old_value [$items_widget get $sel_idx]
		if { $old_value ne $data(modified_value) && $data(modified_value) ne "" } {
			set data(modified_result) [translate "Modifying data..."]
			::update_onscreen_variables
			borg toast [translate "Modifying data..."] 1
			borg spinner on
			update 
			
			set modified_shots [::DYE::DB::update_category $data(item_type) $old_value $data(modified_value)]
			
			if { [llength $modified_shots] > 0 } {
				$items_widget delete $sel_idx $sel_idx
				$items_widget insert $sel_idx $data(modified_value)
				$items_widget selection set $sel_idx
				
				if { [llength $modified_shots] == 1 } {
					set data(modified_result) "[llength $modified_shots] [translate {shot file modified}]"
				} else {
					set data(modified_result) "[llength $modified_shots] [translate {shot files modified}]"
				}
			} else {
				set data(modified_result) [translate "No files modified"]
			}
			borg spinner off
			borg systemui $::android_full_screen_flags
		}
	}
}
	
proc ::DYE::IS::page_cancel {} {
	variable data
	say [translate {cancel}] $::settings(sound_button_in)
	$data(callback_proc) {} {} $data(item_type)
}
	
proc ::DYE::IS::page_done {} {
	variable data
	say [translate {save}] $::settings(sound_button_in)
	
	set items_widget $::DYE::IS::widgets(items)
	set item_value {}
	set item_id {}
	
	if {[$items_widget curselection] ne ""} {
		set sel_idx [$items_widget curselection]
		set item_value [$items_widget get $sel_idx]
					
		if { [llength $data(item_ids)] == 0 } {
			set item_id $item_value
		} else {
			if { [llength $data(filter_indexes)] > 0 } {
				set new_sel_idx [lindex $data(filter_indexes) $sel_idx]
				set sel_idx $new_sel_idx
			}
			set item_id [lindex $data(item_ids) $sel_idx]
		}
	}

	$data(callback_proc) $item_id $item_value $data(item_type)	
}

### GENERIC NUMERIC ENTRIES EDITION PAGE ##############################################################################

namespace eval ::DYE::NUME {
	variable widgets
	array set widgets {}
		
	variable data
	array set data {
		page_name "::DYE::NUME"
		previous_page {}
		callback_cmd {}
		show_previous_values 1
		page_title {}
		field_name {}
		num_variable {}
		value {}
		min_value {}
		max_value {}
		n_decimals {}
		default_value {}
		small_increment {}
		big_increment {}
		previous_values {}
		value_format {}
	}
}

# Accepts any of the named options -page_title, -min_value, -max_value, -n_decimals, -default_value, 
# -small_increment and -big_increment. If not specified, they are taken from the data dictionary entry for 'field_name'.
proc ::DYE::NUME::load_page { field_name { num_variable {}} args } {
	variable data
	variable widgets
	array set opts $args
	
	foreach fn [array names data] {
		if { $fn ne "page_name" } { set data($fn) {} }
	}
	
	# If the field name is found in the data dictionary, use its metadata unless they are provided in the proc call
	set opt_names "n_decimals min_value max_value default_value small_increment big_increment"
	lassign [DYE::field_lookup $field_name "name data_type $opt_names"] f_name f_data_type f_n_decimals \
		f_min_value f_max_value f_default_value f_small_increment f_big_increment
	foreach fn $opt_names {
		set data($fn) [ifexists opts(-$fn) [subst \$f_$fn]] 
	}
	if { $f_data_type ne "numeric" } {
		msg "DYE WARNING: field '$field_name' is not numeric, cannot launch page ::DYE::NUME"
		return
	}

	set data(field_name) $field_name
	if { [info exists opts(-callback_cmd)] } {
		set data(callback_cmd) $opts(-callback_cmd)
	}	
	set data(show_previous_values) [ifexists opts(-show_previous_values) 1]
	set data(num_variable) $num_variable
	#if { $data(value) eq "" && $data(default_value) ne "" } { set data(value) $data(default_value) }
	if { $data(small_increment) eq "" } { set data(small_increment) 1.0 }
	if { $data(big_increment) eq "" } { set data(big_increment) 10.0 }
	
	if { [info exists opts(-page_title)] } {
		set data(page_title) $page_title
	} elseif { $f_name ne "" } {
		set data(page_title) [translate "Edit $f_name"]
	} else {
		set data(page_title) [translate "Edit number"]
	}
	
	set data(previous_values) [::DYE::DB::previous_values $field_name]
		
	set ns [namespace current]
	::DYE::GUI::set_previous_page $ns
	page_to_show_when_off $ns	
	::DYE::GUI::set_scrollbars_dims $ns "previous_values"

	::DYE::GUI::enable_or_disable_widgets [expr $::DYE::NUME::data(n_decimals)>0] "num_dot*" $ns

	if { $num_variable ne "" && [subst \$$num_variable] ne "" } {
		# Without the delay, the value is not selected. Tcl misteries...
		after 10 ::DYE::NUME::set_value [subst \$$num_variable]
	}	
}

proc ::DYE::NUME::setup_ui {} {
	variable data
	variable widgets
	set page [namespace current]	
	
	::DYE::GUI::add_page $page -buttons_loc center
	
	# Value being edited
	set x_left_center 550; set y 275
	::DYE::GUI::add_text_entry $page $data(field_name) -1 -1 $x_left_center $y 5 -font [DSx_font font 16] \
		-textvariable ::DYE::NUME::data(value) -widget_name value -data_type numeric -exportselection 1
	
	# Erase button
	::DYE::GUI::add_symbol $page $x_left_center [expr {$y+140}] eraser -size medium -has_button 1 \
		-button_cmd { set ::DYE::NUME::data(value) "" }
	
	# Increment/Decrement value arrows 
	incr y 45; set y_symbol_offset 5; set y_label_offset 90
	::DYE::GUI::add_symbol $page [expr {$x_left_center-100}] [expr {$y+$y_symbol_offset}] chevron_left \
		-size medium -anchor center \
		-has_button 1 -button_cmd { ::DYE::NUME::incr_value [expr -$::DYE::NUME::data(small_increment)] }
	::DYE::GUI::add_variable $page [expr {$x_left_center-100}] [expr {$y+$y_label_offset}] \
		{-[format [::DYE::NUME::value_format] $::DYE::NUME::data(small_increment)]} \
		-anchor center -font [DSx_font font 6]
	
	::DYE::GUI::add_symbol $page [expr {$x_left_center-260}] [expr {$y+$y_symbol_offset}] chevron_double_left \
		-size medium -anchor center \
		-has_button 1 -button_cmd { ::DYE::NUME::incr_value [expr -$::DYE::NUME::data(big_increment)] }
	::DYE::GUI::add_variable $page [expr {$x_left_center-260}] [expr {$y+$y_label_offset}] \
		{-[format [::DYE::NUME::value_format] $::DYE::NUME::data(big_increment)]} \
		-anchor center -font [DSx_font font 6]

	::DYE::GUI::add_symbol $page [expr {$x_left_center-400}] [expr {$y+$y_symbol_offset}] arrow_to_left \
		-size medium -anchor center \
		-has_button 1 -button_cmd { ::DYE::NUME::set_value $::DYE::NUME::data(min_value) }
	::DYE::GUI::add_variable $page [expr {$x_left_center-400}] [expr {$y+$y_label_offset}] \
		{[format [::DYE::NUME::value_format] $::DYE::NUME::data(min_value)]} \
		-anchor center -font [DSx_font font 6]
	
	::DYE::GUI::add_symbol $page [expr {$x_left_center+360}] [expr {$y+$y_symbol_offset}] chevron_right \
		-size medium -anchor center \
		-has_button 1 -button_cmd { ::DYE::NUME::incr_value $::DYE::NUME::data(small_increment) }
	::DYE::GUI::add_variable $page [expr {$x_left_center+360}] [expr {$y+$y_label_offset}] \
		{+[format [::DYE::NUME::value_format] $::DYE::NUME::data(small_increment)]} \
		-anchor center -font [DSx_font font 6]
	
	::DYE::GUI::add_symbol $page [expr {$x_left_center+510}] [expr {$y+$y_symbol_offset}] chevron_double_right \
		-size medium -anchor center \
		-has_button 1 -button_cmd { ::DYE::NUME::incr_value $::DYE::NUME::data(big_increment) }
	::DYE::GUI::add_variable $page [expr {$x_left_center+510}] [expr {$y+$y_label_offset}] \
		{+[format [::DYE::NUME::value_format] $::DYE::NUME::data(big_increment)]} \
		-anchor center -font [DSx_font font 6]

	::DYE::GUI::add_symbol $page [expr {$x_left_center+670}] [expr {$y+$y_symbol_offset}] arrow_to_right \
		-size medium -anchor center \
		-has_button 1 -button_cmd { ::DYE::NUME::set_value $::DYE::NUME::data(max_value) }
	::DYE::GUI::add_variable $page [expr {$x_left_center+670}] [expr {$y+$y_label_offset}] \
		{[format "%.$::DYE::NUME::data(n_decimals)f" $::DYE::NUME::data(max_value)]} \
		-anchor center -font [DSx_font font 6]

	# Previous values listbox
	::DYE::GUI::add_listbox $page previous_values 450 600 450 680 16 9 -label [translate "Previous values"] \
		-font [DSx_font font 10] -label_font [DSx_font font 10] 
	bind $widgets(previous_values) <<ListboxSelect>> ::DYE::NUME::previous_values_select
	
	# Numeric type pad
	set x_base 1450; set y_base 225
	set width 280; set height 220; set space 70
	set numpad_font_size 12
	
	set x [expr {$x_base+0*($width+$space)}]
	set y [expr {$y_base+0*($height+$space)}]
	::DYE::GUI::add_button $page num7 $x $y [expr {$x+$width}] [expr {$y+$height}] "7" {::DYE::NUME::enter_character 7} \
		-label_font [DSx_font font $numpad_font_size]
	
	set x [expr {$x_base+1*($width+$space)}]
	set y [expr {$y_base+0*($height+$space)}]
	::DYE::GUI::add_button $page num8 $x $y [expr {$x+$width}] [expr {$y+$height}] "8" {::DYE::NUME::enter_character 8} \
		-label_font [DSx_font font $numpad_font_size]

	set x [expr {$x_base+2*($width+$space)}]
	set y [expr {$y_base+0*($height+$space)}]
	::DYE::GUI::add_button $page num9 $x $y [expr {$x+$width}] [expr {$y+$height}] "9" {::DYE::NUME::enter_character 9} \
		-label_font [DSx_font font $numpad_font_size]

	set x [expr {$x_base+0*($width+$space)}]
	set y [expr {$y_base+1*($height+$space)}]
	::DYE::GUI::add_button $page num4 $x $y [expr {$x+$width}] [expr {$y+$height}] "4" {::DYE::NUME::enter_character 4} \
		-label_font [DSx_font font $numpad_font_size]

	set x [expr {$x_base+1*($width+$space)}]
	set y [expr {$y_base+1*($height+$space)}]
	::DYE::GUI::add_button $page num5 $x $y [expr {$x+$width}] [expr {$y+$height}] "5" {::DYE::NUME::enter_character 5} \
		-label_font [DSx_font font $numpad_font_size]

	set x [expr {$x_base+2*($width+$space)}]
	set y [expr {$y_base+1*($height+$space)}]
	::DYE::GUI::add_button $page num6 $x $y [expr {$x+$width}] [expr {$y+$height}] "6" {::DYE::NUME::enter_character 6} \
		-label_font [DSx_font font $numpad_font_size]

	set x [expr {$x_base+0*($width+$space)}]
	set y [expr {$y_base+2*($height+$space)}]
	::DYE::GUI::add_button $page num1 $x $y [expr {$x+$width}] [expr {$y+$height}] "1" {::DYE::NUME::enter_character 1} \
		-label_font [DSx_font font $numpad_font_size]

	set x [expr {$x_base+1*($width+$space)}]
	set y [expr {$y_base+2*($height+$space)}]
	::DYE::GUI::add_button $page num2 $x $y [expr {$x+$width}] [expr {$y+$height}] "2" {::DYE::NUME::enter_character 2} \
		-label_font [DSx_font font $numpad_font_size]

	set x [expr {$x_base+2*($width+$space)}]
	set y [expr {$y_base+2*($height+$space)}]
	::DYE::GUI::add_button $page num3 $x $y [expr {$x+$width}] [expr {$y+$height}] "3" {::DYE::NUME::enter_character 3} \
		-label_font [DSx_font font $numpad_font_size]

	set x [expr {$x_base+0*($width+$space)}]
	set y [expr {$y_base+3*($height+$space)}]
	::DYE::GUI::add_button $page num_del $x $y [expr {$x+$width}] [expr {$y+$height}] "Del" {::DYE::NUME::enter_character DEL} \
		-label_font [DSx_font font $numpad_font_size]

	set x [expr {$x_base+1*($width+$space)}]
	set y [expr {$y_base+3*($height+$space)}]
	::DYE::GUI::add_button $page num0 $x $y [expr {$x+$width}] [expr {$y+$height}] "0" {::DYE::NUME::enter_character 0} \
		-label_font [DSx_font font $numpad_font_size]

	set x [expr {$x_base+2*($width+$space)}]
	set y [expr {$y_base+3*($height+$space)}]
	::DYE::GUI::add_button $page num_dot $x $y [expr {$x+$width}] [expr {$y+$height}] "." {::DYE::NUME::enter_character .} \
		-label_font [DSx_font font $numpad_font_size]
}

proc ::DYE::NUME::value_format {} {
	variable data
	return "%.$data(n_decimals)f"
}

proc ::DYE::NUME::set_value { new_value } {
	variable data
	if { $new_value ne "" } {
		if { $new_value != 0 } { set new_value [string trimleft $new_value 0] } 
		set new_value [format [value_format] $new_value]
	}
	set data(value) $new_value
	value_change
	select_value
}

proc ::DYE::NUME::select_value {} {
	variable widgets
	focus $widgets(value)
	$widgets(value) selection range 0 end 
}

proc ::DYE::NUME::value_change {} {
	variable data
	set widget $::DYE::NUME::widgets(value)
	if { $data(value) ne "" } {
		if { $data(min_value) ne "" && $data(value) < $data(min_value) } {
			$widget configure -foreground $::DYE::GUI::error_color
		} elseif { $data(max_value) ne "" && $data(value) > $data(max_value) } {
			$widget configure -foreground $::DYE::GUI::error_color
		} else {
			$widget configure -foreground $::DYE::GUI::font_color
		}
	}
}

proc ::DYE::NUME::enter_character { char } {
	variable data
	set widget $::DYE::NUME::widgets(value)

	set max_len [string length [expr round($data(max_value))]]
	if { $data(n_decimals) > 0 } { incr max_len [expr {$data(n_decimals)+1}] }

	set idx -1
	catch { set idx [$widget index sel.first] }
	#[selection own] eq $widget
	if { $idx > -1 } {
		#set ::DYE::debug_text "SELECTION MODE: sel from $idx to [$widget index sel.last]"
		set idx_last [$widget index sel.last]
		if { $char eq "DEL" } {
			set data(value) "[string range $data(value) 0 [expr {$idx-1}]][string range $data(value) $idx_last end]"
		} else {
			set data(value) "[string range $data(value) 0 [expr {$idx-1}]]$char[string range $data(value) $idx_last end]"
		}
		selection own $widget
		$widget selection clear
		$widget icursor [expr {$idx+1}]
	} else {	
		set idx [$widget index insert]
		#set ::DYE::debug_text "NON-SELECTION MODE: insert=$idx"
		if { $char eq "DEL" } {
			set data(value) "[string range $data(value) 0 [expr {$idx-2}]][string range $data(value) $idx end]"
			if { $idx > 0 } { $widget icursor [expr {$idx-1}] }
		} elseif { [string length $data(value)] < $max_len } {
			$widget insert $idx $char
		}
	}
	
	set data(value) [string trimleft $data(value) 0]
	value_change
}

proc ::DYE::NUME::incr_value { incr } {
	variable data	
	
	if { $data(value) eq "" } {
		if { $data(default_value) ne "" } {
			set value $data(default_value)
		} elseif { $data(min_value) ne "" && $data(max_value) ne "" } {
			set value [expr {($data(max_value)-$data(min_value))/2}]
		} else {
			set value 0
		}
	} else {
		set value $data(value)
	}

	set new_value [expr {$value + $incr}]
	if { $data(min_value) ne "" && $new_value < $data(min_value) } {
		set new_value $data(min_value)
	} 
	if { $data(max_value) ne "" && $new_value > $data(max_value) } {
		set new_value $data(max_value)
	}
	
	set new_value [format [value_format] $new_value]
	if { $new_value != $data(value) } {
		set_value $new_value
	}
}

proc ::DYE::NUME::previous_values_select {} {
	variable widgets
	set new_value [::DYE::GUI::listbox_get_selection $widgets(previous_values)]
	if { $new_value ne "" } { set_value $new_value }
}

proc ::DYE::NUME::page_cancel {} {
	variable data
	if { $data(callback_cmd) ne "" } {
		$data(callback_cmd) {}
	} else {
		page_to_show_when_off $data(previous_page)
	}
}

proc ::DYE::NUME::page_done {} {
	variable data
	set fmt [value_format]
	
	if { $data(value) ne "" } {
		if { $data(value) < $data(min_value) } {
			set data(value) [format $fmt $data(min_value)]
		} elseif { $data(value) > $data(max_value) } {
			set data(value) [format $fmt $data(max_value)]
		} else {
			if { $data(value) > 0 } { set data(value) [string trimleft $data(value) 0] }
			set data(value) [format $fmt $data(value)]
		}
	}
	
	if { $data(callback_cmd) ne "" } {
		$data(callback_cmd) $data(value)
	} else {		
		set $data(num_variable) $data(value)
		page_to_show_when_off $data(previous_page)
	}
}

### GENERIC TEXT ENTRIES EDITION PAGE ##############################################################################

namespace eval ::DYE::TXT {
	variable widgets
	array set widgets {}
		
	variable data
	array set data {
		page_name "::DYE::TXT"
		previous_page {}
		callback_cmd {}
		read_only 0
		page_title {}
		field_name {}
		text_variable {}
		value {}
	}
}

proc ::DYE::TXT::load_page { field_name { text_variable {} } {read_only 0} args } {
	variable data
	variable widgets
	array set opts $args
	
	foreach fn [array names data] {
		if { $fn ne "page_name" } { set data($fn) {} }
	}
	
	# If the field name is found in the data dictionary, use its metadata unless they are provided in the proc call
	lassign [DYE::field_lookup $field_name "name data_type"] name data_type 

	set data(field_name) $field_name
	if { [info exists opts(-callback_cmd)] } {
		set data(callback_cmd) $opts(-callback_cmd)
	}
	set data(text_variable) $text_variable
	
	if { [info exists opts(-page_title)] } {
		set data(page_title) $opts(-page_title)
	} elseif { $name ne "" } {
		if { $read_only == 1 } {
			set data(page_title) [translate $name]
		} else {
			set data(page_title) [translate "Edit $name"]
		}
	} else {
		if { $read_only == 1 } {
			set data(page_title) $field_name
		} else {
			set data(page_title) [translate "Edit $name"]
		}
	}
	
	set ns [namespace current]
	::DYE::GUI::set_previous_page $ns
	page_to_show_when_off $ns	
#	::DYE::GUI::set_scrollbars_dims $ns "value"

	if { $text_variable ne "" && [subst \$$text_variable] ne "" } {
		set data(value) [subst \$$text_variable]
	}
	
	::DYE::GUI::enable_or_disable_widgets [expr !$read_only] "value*" $ns
}

proc ::DYE::TXT::setup_ui {} {
	variable data
	variable widgets
	set page [namespace current]	
	
	::DYE::GUI::add_page $page -buttons_loc center
	
	# Value being edited
	set x_left_center 550; set y 275
	::DYE::GUI::add_multiline_entry $page $data(field_name) -1 -1 100 200 115 24 \
		-textvariable ::DYE::TXT::data(value) -widget_name value -editor_page 0
	
	# Erase button
	::DYE::GUI::add_symbol $page 100 900 eraser -size medium -has_button 1 \
		-button_cmd { set ::DYE::TXT::data(value) "" }
}

proc ::DYE::TXT::page_cancel {} {
	variable data
	if { $data(callback_cmd) ne "" } {
		$data(callback_cmd) {}
	} else {
		page_to_show_when_off $data(previous_page)
	}
}

proc ::DYE::TXT::page_done {} {
	variable data
	
	if { $data(value) ne "" } {
		set data(value) [string trim $data(value)]
	}
	
	if { $data(callback_cmd) ne "" } {
		$data(callback_cmd) $data(value)
	} else {
		if { $data(read_only) != 1 } {
			set $data(text_variable) $data(value)
		}
		page_to_show_when_off $data(previous_page)
	}
}

### "FILTER SHOT HISTORY" PAGE #########################################################################################

namespace eval ::DYE::FSH {
	variable widgets
	array set widgets {}
	#		profiles_widget {}
	#		profiles_scrollbar_widget {}
	#		profiles_slider 0
	#		beans_widget {}
	#		beans_scrollbar_widget {}
	#		beans_slider 1
	#		shots_widget {}
	#		shots_scrollbar_widget {}
	#		shots_slider 2
		
	
	variable data
	array set data {
		page_name "::DYE::FSH"
		page_title "Filter Shot History"
		category1 {profile_title}
		categories1_label {Profiles}
		category2 {beans}
		categories2_label {Beans}
		left_filter_status {off}
		right_filter_status {off}
		left_filter_shots {}
		right_filter_shots {}
		matched_shots {}
		n_matched_shots_text {}
		date_from {}
		date_to {}
		ey_from {}
		ey_to {}
		ey_max 0
		tds_from {}
		tds_to {}
		tds_max 0
		enjoyment_from {}
		enjoyment_to {}
		enjoyment_max 0
		order_by_date "Date"
		order_by_tds "TDS"
		order_by_ey "EY"
		order_by_enjoyment "Enjoyment"
	}
}

# Prepare the DYE_filter_shot_history page.
proc ::DYE::FSH::load_page { {category1 profile_title} {category2 bean_brand} } {
	variable widgets
	variable data
	set ns [namespace current]
	
	foreach fn "category1 category2" { set data($fn) {} }

	category1_change $category1
	category2_change $category2
	set_order_by date

	page_to_show_when_off $ns
	::DYE::GUI::set_scrollbars_dims $ns "categories1 categories2 shots"
	::DYE::GUI::relocate_text_wrt $widgets(reset_categories1) $widgets(categories1_scrollbar) ne 0 -12 se \
		$widgets(reset_categories1_button)
	::DYE::GUI::relocate_text_wrt $widgets(reset_categories2) $widgets(categories2_scrollbar) ne 0 -12 se \
		$widgets(reset_categories2_button) 
	
	if { $::DYE::settings(use_stars_to_rate_enjoyment) == 1 } {
		.can itemconfig $widgets(enjoyment_from) -state hidden
		.can itemconfig $widgets(enjoyment_to_label) -state hidden
		.can itemconfig $widgets(enjoyment_to) -state hidden
		for { set i 1 } { $i <= 5 } { incr i } {
			.can itemconfig $widgets(enjoyment_from_rating$i) -state normal
			.can itemconfig $widgets(enjoyment_from_rating_half$i) -state normal
			.can itemconfig $widgets(enjoyment_to_rating$i) -state normal
			.can itemconfig $widgets(enjoyment_to_rating_half$i) -state normal			
		}
		.can itemconfig $widgets(enjoyment_to_rating_label) -state normal
		.can itemconfig $widgets(enjoyment_from_rating_button) -state normal
		.can itemconfig $widgets(enjoyment_to_rating_button) -state normal
		
		::DYE::GUI::draw_rating FSH espresso_enjoyment -widget_name enjoyment_from
		::DYE::GUI::draw_rating FSH espresso_enjoyment -widget_name enjoyment_to
	} else {
		.can itemconfig $widgets(enjoyment_from) -state normal
		.can itemconfig $widgets(enjoyment_to_label) -state normal
		.can itemconfig $widgets(enjoyment_to) -state normal
		for { set i 1 } { $i <= 5 } { incr i } {
			.can itemconfig $widgets(enjoyment_from_rating$i) -state hidden
			.can itemconfig $widgets(enjoyment_from_rating_half$i) -state hidden
			.can itemconfig $widgets(enjoyment_to_rating$i) -state hidden
			.can itemconfig $widgets(enjoyment_to_rating_half$i) -state hidden			
		}
		.can itemconfig $widgets(enjoyment_to_rating_label) -state hidden
		.can itemconfig $widgets(enjoyment_from_rating_button) -state hidden
		.can itemconfig $widgets(enjoyment_to_rating_button) -state hidden	
	}
}

# Setup the "Search Shot History" page User Interface.
proc ::DYE::FSH::setup_ui {} {
	variable widgets
	variable data
	set page [namespace current]
	
	# -title [translate "Filter Shot History"] 
	::DYE::GUI::add_page $page -cancel_button 0 -buttons_loc center
	
	# Categories1 listbox
	set x_left 60; set y 120
	::DYE::GUI::add_listbox $page categories1 $x_left $y $x_left [expr {$y+80}] 25 10 -label_font [DSx_font font 10] \
		-selectmode multiple
	::DYE::GUI::add_text $page [expr {$x_left+340}] [expr {$y+15}] "\[ [translate "Reset"] \]" \
		-widget_name reset_categories1 -fill $::DYE::GUI::remark_color -has_button 1 \
		-button_cmd ::DYE::FSH::reset_categories1_click -button_width 150
	
	# Categories2 listbox
	set x_left2 700
	::DYE::GUI::add_listbox $page categories2 700 $y $x_left2 [expr {$y+80}] 25 10 -label_font [DSx_font font 10] \
		-selectmode multiple
	::DYE::GUI::add_text $page [expr {$x_left2+340}] [expr {$y+15}] "\[ [translate "Reset"] \]" \
		-widget_name reset_categories2 -fill $::DYE::GUI::remark_color -has_button 1 \
		-button_cmd ::DYE::FSH::reset_categories2_click -button_width 150
	
	# Date period from
	set x_right_label 1450; set x_right_widget 1725; set y 200
	::DYE::GUI::add_text_entry $page date_from $x_right_label $y $x_right_widget $y 11 -label [translate "Date from"] \
		-data_type date
	bind $widgets(date_from) <FocusOut> ::DYE::FSH::date_from_leave	
	# Date period to	
	::DYE::GUI::add_text_entry $page date_to 1975 $y 2025 $y 11 -label [translate "to"] -data_type date
	bind $widgets(date_to) <FocusOut> ::DYE::FSH::date_to_leave
	
	# TDS from
	::DYE::GUI::add_text_entry $page drink_tds $x_right_label [incr y 100] $x_right_widget $y 6 \
		-label [translate "TDS % from"] -widget_name tds_from
	# TDS to
	::DYE::GUI::add_text_entry $page drink_tds 1875 $y 1925 $y 6 -label [translate "to"] -widget_name tds_to
	
	# EY from
	::DYE::GUI::add_text_entry $page drink_ey $x_right_label [incr y 100] $x_right_widget $y 6 \
		-label [translate "EY % from"] -widget_name ey_from	
	# EY to
	::DYE::GUI::add_text_entry $page drink_ey 1875 $y 1925 $y 6 -label [translate "to"] -widget_name ey_to
		
	# Enjoyment from
	::DYE::GUI::add_text_entry $page espresso_enjoyment 1450 500 1725 500 6 -widget_name "enjoyment_from" \
		-label [translate "Enjoyment from"]	
	# Enjoyment to
	::DYE::GUI::add_text_entry $page espresso_enjoyment 1875 500 1925 500 6 -widget_name "enjoyment_to" \
		-label [translate "to"]
	
	# Enjoyment stars rating from/to
	::DYE::GUI::add_rating $page espresso_enjoyment -1 -1 1725 500 600 -widget_name "enjoyment_from"
	::DYE::GUI::add_rating $page espresso_enjoyment 1650 575 1725 575 600 -widget_name "enjoyment_to" -label "to"

	# Order by
	::DYE::GUI::add_text $page $x_right_label 690 [translate "Order by"] -font [DSx_font font 9]

	set x $x_right_widget; set y 720
	::DYE::GUI::add_variable $page $x $y {$::DYE::FSH::data(order_by_date)} -anchor center -justify center \
		-has_button 1 -button_width 140 -button_cmd { say "" $::settings(sound_button_in); ::DYE::FSH::set_order_by date } 
	::DYE::GUI::add_variable $page [incr x 175] $y {$::DYE::FSH::data(order_by_tds)} -anchor center -justify center \
		-has_button 1 -button_width 100 -button_cmd { say "" $::settings(sound_button_in); ::DYE::FSH::set_order_by tds } 
	::DYE::GUI::add_variable $page [incr x 150] $y {$::DYE::FSH::data(order_by_ey)} -anchor center -justify center \
		-has_button 1 -button_width 100 -button_cmd { say "" $::settings(sound_button_in); ::DYE::FSH::set_order_by ey } 
	::DYE::GUI::add_variable $page [incr x 200] $y {$::DYE::FSH::data(order_by_enjoyment)} -anchor center -justify center \
		-has_button 1 -button_width 130 -button_cmd { say "" $::settings(sound_button_in); ::DYE::FSH::set_order_by enjoyment } 
	
	# Reset button
	set y 825
	::DYE::GUI::add_button1 $page reset $x_left $y [translate Reset] ::DYE::FSH::reset_click

	# Search button
	::DYE::GUI::add_button1 $page search 2200 $y [translate Search] ::DYE::FSH::search_shot_history

	# Number of search matches
	set data(n_matched_shots_text) [translate "No shots"]
	::DYE::GUI::add_variable $page 2150 900 {$::DYE::FSH::data(n_matched_shots_text)} -font [DSx_font font 10] \
		-anchor "ne" -justify "right" -width [rescale_x_skin 800]
	
	# Search results showing matching shots
	::DYE::GUI::add_listbox $page shots -1 -1 $x_left 975 115 7 
	
	# Button "Apply to left history"
	set y 1375
	::DYE::GUI::add_button2 $page apply_to_left_side $x_left $y "[translate {Apply to}]\n[translate {left side}]" \
		{$::DYE::FSH::data(left_filter_status)} filter ::DYE::FSH::apply_to_left_side_click
	
	# Button "Apply to right history"
	::DYE::GUI::add_button2 $page apply_to_right_side 2050 $y "[translate {Apply to}]\n[translate {right side}]" \
		{$::DYE::FSH::data(right_filter_status)} filter ::DYE::FSH::apply_to_right_side_click
}

proc ::DYE::FSH::category1_change { new_category } {
	variable data	
	if { $data(category1) eq $new_category } return
		
	set data(category1) {}
	if { $new_category ne "" } {
		lassign [::DYE::field_lookup $new_category "name_plural data_type"] name_plural data_type
		if { $name_plural eq "" } {
			msg "DYE: ERROR on FSH::load_page, category1='$new_category' not found"
			return
		}
		if { $data_type ne "category" } {
			msg "DYE: ERROR on FSH::load_page, field '$new_category' is not a category"
			return
		}
		set data(category1) $new_category
		set data(categories1_label) [translate $name_plural]
	}
	
	fill_categories1_listbox
}

proc ::DYE::FSH::fill_categories1_listbox {} {
	variable data
	variable widgets
#	set db ::DYE::DB::get_db
#	set profiles [db eval {SELECT profile_title FROM shot WHERE LENGTH(COALESCE(profile_title,''))>0 AND removed=0
#		GROUP BY profile_title ORDER BY count(*) DESC}]	
	$widgets(categories1) delete 0 end

	if { $data(category1) ne "" } {
		set cat_values [::DYE::DB::available_categories $data(category1)]
		$widgets(categories1) insert 0 {*}$cat_values
	}
}

proc ::DYE::FSH::reset_categories1_click {} {
	variable widgets
	say [translate {reset}] $::settings(sound_button_in)
	$widgets(categories1) selection clear 0 end
}

proc ::DYE::FSH::category2_change { new_category } {
	variable data	
	if { $data(category2) eq $new_category } return
		
	set data(category2) {}
	if { $new_category ne "" } {
		lassign [::DYE::field_lookup $new_category "name_plural data_type"] name_plural data_type
		if { $name_plural eq "" } {
			msg "DYE: ERROR on FSH::load_page, category2='$new_category' not found"
			return
		}
		if { $data_type ne "category" } {
			msg "DYE: ERROR on FSH::load_page, field '$new_category' is not a category"
			return			
		}
		set data(category2) $new_category
		set data(categories2_label) [translate $name_plural]
	}
	
	fill_categories2_listbox
}

proc ::DYE::FSH::fill_categories2_listbox {} {
	variable widgets
	variable data
#	set db ::DYE::DB::get_db
#	set beans [db eval {
#		SELECT bean_desc FROM V_shot WHERE LENGTH(bean_desc) > 0 AND removed=0
#		GROUP BY bean_desc ORDER BY MAX(clock) DESC}]
	$widgets(categories2) delete 0 end

	if { $data(category2) ne "" } {
		set cat_values [::DYE::DB::available_categories $data(category2)]
		$widgets(categories2) insert 0 {*}$cat_values
	}
}

proc ::DYE::FSH::reset_categories2_click {} {
	variable widgets
	say [translate {reset}] $::settings(sound_button_in)
	$widgets(categories2) selection clear 0 end
}


proc ::DYE::FSH::date_from_leave {} {
	variable widgets
	variable data
	if { $data(date_from) eq ""} {
		$widgets(date_from) configure -bg $::DYE::GUI::bg_color
	} elseif { [regexp {^([0-9][0-9]*/)*([0-9][0-9]*/)*[0-9]{4}$} $data(date_from)] == 0 } {
		$widgets(date_from) configure -bg $::DYE::GUI::remark_color
	} else {
		$widgets(date_from)  configure -bg $::DYE::GUI::bg_color
		
		if { [regexp {^[0-9]{4}$} $data(date_from)] == 1 } {
			set data(date_from) "1/1/$data(date_from)" 
		} elseif { [regexp {^[0-9][0-9]*/[0-9]{4}$} $data(date_from)] == 1 } {
			set data(date_from) "1/$data(date_from)"
		}	
#				set ::DYE_debug_text "Entered '$::DYE::FSH::data(date_from)'"
#				if { [catch {clock scan $::DYE::FSH::data(date_from) -format $::DYE::settings{date_format} -timezone :UTC}] } {
#					%W configure -bg $::DSx_settings(orange)
#				} else {
#					%W configure -bg $::DSx_settings(bg_colour)
#				}			
	}
	hide_android_keyboard	
}

proc ::DYE::FSH::date_to_leave {} {
	variable widgets
	variable data
	if { $data(date_to) eq ""} {
		$widgets(date_to) configure -bg $::DYE::GUI::bg_color			
	} elseif { [regexp {^([0-9][0-9]*/)*([0-9][0-9]*/)*[0-9]{4}$} $::DYE::FSH::data(date_to)] == 0 } {
		$widgets(date_to) configure -bg $::DYE::GUI::remark_color
	} else {
		$widgets(date_to) configure -bg $::DYE::GUI::bg_color
		
		if { $::DYE::settings(date_format) eq "%d/%m/%Y" } {
			if { [regexp {^[0-9]{4}$} $data(date_to)] == 1 } {
				set data(date_to) "31/12/$data(date_to)" 
			} elseif { [regexp {^[0-9][0-9]*/[0-9]{4}$} $data(date_from)] == 1 } {
				set data(date_to) "31/$data(date_to)"
			}
		} elseif { $::DYE::settings(date_format) eq "%m/%d/%Y" }  {
			if { [regexp {^[0-9]{4}$} $data(date_to)] == 1 } {
				set data(date_to) "12/31/$data(date_to)" 
			}					
		}
			
	}
	hide_android_keyboard 
}

proc ::DYE::FSH::set_order_by { field } {
	variable data
	set data(order_by_date) "[translate Date]"
	set data(order_by_tds) "[translate TDS]"
	set data(order_by_ey) "[translate EY]"
	set data(order_by_enjoyment) "[translate Enjoyment]"
	
	set data(order_by_$field) "\[ $data(order_by_$field) \]"	
}

proc ::DYE::FSH::reset_click {} {
	variable data
	variable widgets
	say [translate {reset}] $::settings(sound_button_in)
	
	$widgets(categories1) selection clear 0 end
	$widgets(categories2) selection clear 0 end
	set data(date_from) {}
	set data(date_to) {}
	set data(tds_from) {}
	set data(tds_to) {}
	set data(ey_from) {}
	set data(ey_to) {}
	set data(enjoyment_from) {}
	::DYE::GUI::draw_rating FSH enjoyment_from
	set data(enjoyment_to) {}
	::DYE::GUI::draw_rating FSH enjoyment_to
	set_order_by date	
	$widgets(shots) delete 0 end
	set data(matched_shots) {}
	set data(n_matched_shots_text) "[translate {No matching shots}]"
}

# Runs the specified search in the shot history and show the results in the shots listbox.
# ::DSx_filtered_past_shot_files
proc ::DYE::FSH::search_shot_history {} {
	variable widgets
	variable data
	say [translate {search}] $::settings(sound_button_in)
	
	# Build the SQL SELECT statement
	set where_conds {}
	
	set c1_values [::DYE::GUI::listbox_get_selection $widgets(categories1)]
	if { $c1_values ne "" } {
		lappend where_conds "$data(category1) IN ([::DYE::DB::strings2sql $c1_values])"
	}
#	set c1_widget $widgets(categories1)
#	if {[$c1_widget curselection] ne ""} {
#		set c1_values {}
#		foreach idx [$c1_widget curselection] {
#			lappend c1_values [$c1_widget get $idx]
#		}
#		lappend where_conds "$data(category1) IN ([::DYE::DB::strings2sql $c1_values])"
#	}

	set c2_values [::DYE::GUI::listbox_get_selection $widgets(categories2)]
	if { $c2_values ne "" } {
		lappend where_conds "$data(category2) IN ([::DYE::DB::strings2sql $c2_values])"
	}
#	set c2_widget $widgets(categories2)
#	if {[$c2_widget curselection] ne ""} {
#		set c2_values {}
#		foreach idx [$c2_widget curselection] {
#			lappend c2_values [$c2_widget get $idx]
#		}
#		lappend where_conds "bean_desc IN ([::DYE::DB::strings2sql $beans])"
#	}
	
	if { $data(date_from) ne "" } {
		set from_clock [clock scan "$data(date_from) 00:00:00" -format "$::DYE::settings(date_format) %H:%M:%S"]
		lappend where_conds "clock>=$from_clock"
	}	
	if { $data(date_to) ne "" } {
		set to_clock [clock scan "$data(date_to) 23:59:59" -format "$::DYE::settings(date_format) %H:%M:%S"]
		lappend where_conds "clock<=$to_clock"
	}

	if { $data(tds_from) ne "" } {
		lappend where_conds "LENGTH(drink_tds)>0 AND drink_tds>=$data(tds_from)"
	}	
	if { $data(tds_to) ne "" } {
		lappend where_conds "LENGTH(drink_tds)>0 AND drink_tds<=$data(tds_to)"
	}
	
	if { $data(ey_from) ne "" } {
		lappend where_conds "LENGTH(drink_ey)>0 AND drink_ey>=$data(ey_from)"
	}	
	if { $data(ey_to) ne "" } {
		lappend where_conds "LENGTH(drink_ey)>0 AND drink_ey<=$data(ey_to)"
	}

	if { $data(enjoyment_from) ne "" } {
		lappend where_conds "LENGTH(espresso_enjoyment)>0 AND espresso_enjoyment>=$data(enjoyment_from)"
	}	
	if { $data(enjoyment_to) ne "" && $data(enjoyment_to) > 0 } {
		lappend where_conds "LENGTH(espresso_enjoyment)>0 AND espresso_enjoyment<=$data(enjoyment_to)"
	}
	
	set sql "SELECT filename, shot_desc FROM V_shot WHERE removed=0 "
	if {[llength $where_conds] > 0} { 
		append sql "AND [join $where_conds " AND "] "
	}
	
	if { [string first "\[" $data(order_by_enjoyment)] >= 0 } {
		append sql {ORDER BY espresso_enjoyment DESC, clock DESC}
	} elseif { [string first "\[" $data(order_by_ey)] >= 0 } {
		append sql {ORDER BY drink_ey DESC, clock DESC}
	} elseif { [string first "\[" $data(order_by_tds)] >= 0 } {
		append sql {ORDER BY drink_tds DESC, clock DESC}
	} else {
		append sql {ORDER BY clock DESC}
	}
		
	# Run the search
	set data(matched_shots) {}
	set cnt 0
	$widgets(shots) delete 0 end	
	
	set db ::DYE::DB::get_db
	msg "DYE: $sql"
	db eval "$sql" {
		lappend data(matched_shots) $filename "$filename.shot"
		$widgets(shots) insert $cnt $shot_desc
		
		# TODO Move this line to the select for left side button.
		if { $cnt == 0 } { set ::DSx_settings(DSx_past_espresso_name) $filename }
			
		incr cnt
	}
	
	set data(n_matched_shots) $cnt
	if { $cnt == 0 } {
		set data(n_matched_shots_text) "[translate {No matching shots}]"
	} elseif { $cnt == 1 } {
		set data(n_matched_shots_text) "$cnt [translate {matching shot}]"
	} else {		
		set data(n_matched_shots_text) "$cnt [translate {matching shots}]"
	}
}

proc ::DYE::FSH::apply_to_left_side_click {} {
	variable data
	say [translate {filter}] $::settings(sound_button_in)
	if {$data(left_filter_status) eq "off"} {
		if {[llength $data(matched_shots)] > 0} {
			# Ensure the files still exist on disk, otherwise don't include them
			set ::DSx_filtered_past_shot_files {} 
			for { set i 0 } { $i < [llength $data(matched_shots)] } { incr i 2 } {
				set fn [lindex $data(matched_shots) $i]
				if { [file exists "[homedir]/history/${fn}.shot"] } {
					lappend ::DSx_filtered_past_shot_files $fn
					lappend ::DSx_filtered_past_shot_files "${fn}.shot"
				} elseif { [file exists "[homedir]/history_archive/${fn}.shot"] } {
					lappend ::DSx_filtered_past_shot_files $fn
					lappend ::DSx_filtered_past_shot_files "${fn}.shot"
				}
			}				
			#set ::DSx_filtered_past_shot_files $data(matched_shots)
			set data(left_filter_status) "on"
		}
	} else {
		set data(left_filter_status) "off"
		unset -nocomplain ::DSx_filtered_past_shot_files
	}	
}

proc ::DYE::FSH::apply_to_right_side_click {} {
	variable data
	say [translate {filter}] $::settings(sound_button_in)
	
	if {$data(right_filter_status) eq "off"} {
		if {[llength $data(matched_shots)] > 0} {
			# Ensure the files still exist on disk, otherwise don't include them
			set ::DSx_filtered_past_shot_files2 {} 
			for { set i 0 } { $i < [llength $data(matched_shots)] } { incr i 2 } {
				set fn [lindex $data(matched_shots) $i]
				if { [file exists "[homedir]/history/${fn}.shot"] } {
					lappend ::DSx_filtered_past_shot_files2 $fn
					lappend ::DSx_filtered_past_shot_files2 "${fn}.shot"
				} elseif { [file exists "[homedir]/history_archive/${fn}.shot"] } {
					lappend ::DSx_filtered_past_shot_files2 $fn
					lappend ::DSx_filtered_past_shot_files2 "${fn}.shot"
				}
			}				
			#set ::DSx_filtered_past_shot_files2 $data(matched_shots)
			set data(right_filter_status) "on"
		}
	} else {
		set data(right_filter_status) "off"
		unset -nocomplain ::DSx_filtered_past_shot_files
	}
}

proc ::DYE::FSH::page_done {} {
	say [translate {save}] $::settings(sound_button_in)
	page_to_show_when_off DSx_past
	
	if {$::DYE::FSH::data(left_filter_status) eq "on"} {
		fill_DSx_past_shots_listbox
	}
	if {$::DYE::FSH::data(right_filter_status) eq "on"} {
		fill_DSx_past2_shots_listbox
	}
}

### "SHOT EQUIPMENT" PAGE ##############################################################################################

namespace eval ::DYE::SEQ {
	# State variables for the "DYE_shot_equipment" page. Not persisted. 
	variable widgets
	array set widgets {}
	
	variable data
	array set data {
		page_name {::DYE::SEQ}
		types {}
		availables {}
		availables_types {}
		availables_names {}
		selected {}
		selected_types {}
		selected_names {}
		selected_descs {}
		selected_settings {}
		selected_setting {}
	}
}

# Prepare and launch the DYE_shot_equipment page.
proc ::DYE::SEQ::load_page {} {
	::DYE::DB::update_equipment_categories
	fill_selected_listbox
	fill_types_listbox
	fill_availables_listbox

	page_to_show_when_off [namespace current]
	
	::DYE::GUI::set_scrollbars_dims ::DYE::SEQ "types availables selected"
#	set_types_scrollbar_dims
#	set_availables_scrollbar_dims
#	set_selected_scrollbar_dims
	
	::DYE::GUI::relocate_dropdown_arrows ::DYE::SEQ::widgets selected_setting
	::DYE::GUI::disable_widgets "selected_setting* selecting_setting_dropdown* select_equipment* unselect_equipment*" \
		::DYE::SEQ
	
	hide_android_keyboard
}

proc ::DYE::SEQ::setup_ui {} {
	variable data
	variable widgets
	set page [namespace current]

	::DYE::GUI::add_page $page -title [translate "Other equipment"] -buttons_loc center
	
	set x_left_label 60; set x_left_field 140
	set left_entry_width 40; set right_entry_width 50
	set x_mid_icons 1180; set x_right_field 1330 
	
	# Header
	set y 150
	::DYE::GUI::add_text $page 540 $y [translate "Available"] -font [DSx_font font 10] -widget_name available_header \
		-fill $::DYE::GUI::page_title_color -anchor "center" -justify "center"
	::DYE::GUI::add_text $page 1840 $y [translate "Used in this shot"] -font [DSx_font font 10] -widget_name used_header \
		-fill $::DYE::GUI::page_title_color -anchor "center" -justify "center"

	# Available equipment types
	set y 200
	::DYE::GUI::add_symbol $page $x_left_label $y pencil -widget_name edit_equipment_types -has_button 1 \
		-button_cmd ::DYE::SEQ::edit_equipment_types_click
	
	::DYE::GUI::add_listbox $page types -1 -1 $x_left_field $y $left_entry_width 6 -selectmode multiple
	bind $::DYE::SEQ::widgets(types) <<ListboxSelect>> ::DYE::SEQ::fill_availables_listbox
	
	# Available equipment
	incr y 400
	::DYE::GUI::add_symbol $page $x_left_label $y pencil -widget_name edit_equipment_names -has_button 1 \
		-button_cmd ::DYE::SEQ::edit_equipment_names_click

	::DYE::GUI::add_listbox $page availables -1 -1 $x_left_field $y $left_entry_width 14 -selectmode multiple
	bind $::DYE::SEQ::widgets(availables) <<ListboxSelect>> ::DYE::SEQ::availables_select 

	# Select equipment (arrow right)
	set y 660; set width 200; set height 200;
	::DYE::GUI::add_symbol $page $x_mid_icons $y circle_right -widget_name select_equipment -has_button 1 \
		-button_cmd ::DYE::SEQ::select_equipment_click -size big -anchor center
	
	# Deselect equipment (arrow left)
	incr y 250
	::DYE::GUI::add_symbol $page $x_mid_icons $y circle_left -widget_name unselect_equipment -has_button 1 \
		-button_cmd ::DYE::SEQ::unselect_equipment_click -size big -anchor center
	
	# Selected equipment
	set y 200
	::DYE::GUI::add_listbox $page selected -1 -1 $x_right_field $y $right_entry_width 19 -selectmode single
	bind $::DYE::SEQ::widgets(selected) <<ListboxSelect>> ::DYE::SEQ::selected_select 
		
	# Equipment setting
	incr y 1125
	::DYE::GUI::add_text_entry $page equipment_setting [expr {$x_right_field-20}] $y $x_right_field $y $right_entry_width \
		-widget_name selected_setting -label_anchor "ne" -label_justify "right" \
		-dropdown_cmd ::DYE::SEQ::selected_setting_dropdown_click
	bind $::DYE::SEQ::widgets(selected_setting) <Leave> ::DYE::SEQ::selected_setting_change
	
#	add_de1_text $page $x_right_label $y -font [DSx_font font 7] \
#		-fill $::DSx_settings(font_colour) -anchor "nw" -text [translate "Setting"]
#	set widgets(selected_setting) [add_de1_widget $page entry $x_right_field $y {
#			bind $widget <Leave> {
#				hide_android_keyboard
#				set selected_widget $::DYE::SEQ::widgets(selected)
#				set sel_idx [$selected_widget curselection]
#				if { $sel_idx eq "" } { break }
#				
#				set old_setting [lindex $::DYE::SEQ::data(selected_settings) $sel_idx]
#				if { $old_setting ne $::DYE::SEQ::data(selected_setting) } {
#					set ::DYE::SEQ::data(selected_settings) [lreplace $::DYE::SEQ::data(selected_settings) \
#						$sel_idx $sel_idx $::DYE::SEQ::data(selected_setting)] 
#					set new_desc "[lindex $::DYE::SEQ::data(selected_types) $sel_idx] - [lindex $::DYE::SEQ::data(selected_names) $sel_idx]"
#					if { $::DYE::SEQ::data(selected_setting) ne "" } {
#						append new_desc " \[$::DYE::SEQ::data(selected_setting)\]"
#					}
#					set ::DYE::SEQ::data(selected) [lreplace $::DYE::SEQ::data(selected) \
#						$sel_idx $sel_idx $new_desc]
#				}
#			}
#			bind $widget <Return> { hide_android_keyboard ; focus [tk_focusNext %W] }
#		} -textvariable ::DYE::SEQ::data(selected_setting) -relief sunken \
#		-width $setting_entry_width -font [DSx_font font 7] \
#		-borderwidth 1 -bg $::DSx_settings(bg_colour) -highlightthickness 1 \
#		-highlightcolor $::DSx_settings(font_colour) -justify left \
#		-foreground $::DSx_settings(font_colour) -insertbackground $::DSx_settings(orange) ]
#	set widgets(selected_setting_dropdown) [add_de1_text $page \
#		$x_right_field [expr {$y-11}] -font fontawesome_reg_small \
#		-fill $::DSx_settings(font_colour) -anchor "nw" -justify "left" -text $DYE::GUI::symbol_sort_down ]
#	set widgets(selected_setting_dropdown_button) [add_de1_button $page {
#		say "" $::settings(sound_button_in)
#		set selected_widget $::DYE::SEQ::widgets(selected)
#		set sel_idx [$selected_widget curselection]
#		if { $sel_idx eq "" } { break }		
#		
#		DYE::IS::load_page equipment_setting ::DYE::SEQ::select_setting_callback $::DYE::SEQ::data(selected_setting) \
#			"single" 1000 "equipment=[::DYE::DB::string2sql [lindex $::DYE::SEQ::data(selected_names) $sel_idx]]"
#		} [expr {$x_right_field-5}] $y [expr {$x_right_field+60}] [expr {$y+68}] ]
}
	
	
# Fills the elements of the Equipment Types listbox in the DYE_shot_equipment page.
proc ::DYE::SEQ::fill_types_listbox {} {
	variable data
	set data(types) [::DYE::DB::available_categories equipment_type]
}

# Fills the elements of the avaible equipment names listbox in the DYE_shot_equipment page.
# If the 'types' listbox has elements selected, only shows equipment names belonging to the selected types.
# Doesn't show equipment that is in use in the current shot.
proc ::DYE::SEQ::fill_availables_listbox {} {
	variable data
	variable widgets
	set data(availables_types) {}
	set data(availables_names) {}
	set data(availables) {}
	
	array set equip [::DYE::DB::available_categories equipment_name 1 "" 1 \
		[::DYE::GUI::listbox_get_selection $widgets(types)]]
	if { [array size equip] > 0 } {
		for { set i 0 } { $i < [llength $equip(equipment_name)] } { incr i } {
			set desc "[lindex $equip(equipment_type) $i] - [lindex $equip(equipment_name) $i]"
#msg "DYE DEBUG fill_availables_listbox, searching '$desc' in '$data(selected_descs)'"
			if { [lsearch -exact $data(selected_descs) $desc] == -1 } {
				lappend data(availables_types) [lindex $equip(equipment_type) $i]
				lappend data(availables_names) [lindex $equip(equipment_name) $i]
				lappend data(availables) $desc
			}
		}
	}
	
	availables_select
}

# Fills the listbox of selected equipment from the shot description field 'other_equipment' in the ::DYE::DE
#	page.
proc ::DYE::SEQ::fill_selected_listbox { } {
	variable data
	foreach f {selected selected_types selected_names selected_descs selected_settings selected_setting } {
		set data($f) {}
	}
	
	set other_equipment $::DYE::DE::data(other_equipment) 
	if { $other_equipment ne "" } {		
		for { set i 0 } { $i < [llength $other_equipment] } { incr i 3 } {
			set sel_name [lindex $other_equipment $i]
			lappend data(selected_names) $sel_name			
			set sel_type [lindex $other_equipment [expr {$i+1}]]
			lappend data(selected_types) $sel_type
			set sel_setting [lindex $other_equipment [expr {$i+2}]]
			lappend data(selected_settings) $sel_setting
			
			set sel_desc "$sel_type - $sel_name"
			lappend data(selected_descs) $sel_desc
			
			if { $sel_setting ne "" } { append sel_desc " \[$sel_setting\]" }
			lappend data(selected) $sel_desc
		}
	}
	
	selected_select
}

proc ::DYE::SEQ::edit_equipment_types_click {} {	
	say "" $::settings(sound_button_in)
	set type [::DYE::GUI::listbox_get_selection $::DYE::SEQ::widgets(types)]
#	if { $type eq "" } return
#	set sel_idx [$::DYE::SEQ::widgets(types) curselection]
#	if { $sel_idx eq "" } return
#	set type [lindex $::DYE::SEQ::data(types) $sel_idx]	
	::DYE::MODC::load_page equipment_type $type $type
}

proc ::DYE::SEQ::edit_equipment_names_click {} {
	say [translate "modify"] $::settings(sound_button_in)
	#::DYE::EQE::load_page
	set sel_idx [$::DYE::SEQ::widgets(availables) curselection]
	if { $sel_idx eq "" } return
	set type [lindex $::DYE::SEQ::data(availables_types) $sel_idx]
	set name [lindex $::DYE::SEQ::data(availables_names) $sel_idx]
	::DYE::MODC::load_page equipment_name $name $name $type	
}

proc ::DYE::SEQ::select_equipment_click {} {
	variable data
	variable widgets
	set awidget $widgets(availables)
	set swidget $widgets(selected)
	if { [$awidget curselection] eq "" } return

	set sel_start [llength $data(selected)]
	set sel_end $sel_start	
	foreach idx [$awidget curselection] {
		set sel_name [lindex $data(availables_names) $idx]
		set sel_type [lindex $data(availables_types) $idx]
		set sel_desc "$sel_type - $sel_name"
		
		if { [lsearch -exact $data(selected_descs) $sel_desc] == -1 } {
			lappend data(selected) $sel_desc		
			lappend data(selected_types) $sel_type
			lappend data(selected_names) $sel_name
			lappend data(selected_descs) $sel_desc
			lappend data(selected_settings) {}
			incr sel_end
		}
	}	
	if { $sel_end > $sel_start } {
		$swidget selection clear 0 9999
		$swidget selection set $sel_start $sel_end
	}
	
	::DYE::SEQ::fill_availables_listbox	
	::DYE::SEQ::selected_select
}

proc ::DYE::SEQ::unselect_equipment_click {} {
	variable widgets
	variable data
	set swidget $widgets(selected)
	set awidget $widgets(availables)
	if { [$swidget curselection] eq "" } return
	
	set rm_descs {}
	set sel_idx [$swidget curselection]
	set n_del 0
	foreach idx $sel_idx {
		set del_idx [expr {$idx-$n_del}]
		lappend rm_descs [lindex $data(selected_descs) $del_idx]
		set data(selected) [lreplace $data(selected) $del_idx $del_idx]
		set data(selected_types) [lreplace $data(selected_types) $del_idx $del_idx]
		set data(selected_names) [lreplace $data(selected_names) $del_idx $del_idx]
		set data(selected_descs) [lreplace $data(selected_descs) $del_idx $del_idx]
		set data(selected_settings) [lreplace $data(selected_settings) $del_idx $del_idx]
		incr n_del
	}
	::DYE::SEQ::fill_availables_listbox	
	
	$awidget selection clear 0 9999
	set idx 0
	foreach desc $data(availables) {
		if { [lsearch $rm_descs $desc] > -1 } {
			$awidget selection set $idx $idx
		}
		incr idx
	}
	::DYE::SEQ::availables_select
	::DYE::SEQ::selected_select
}

proc ::DYE::SEQ::availables_select {} {
	if { [$::DYE::SEQ::widgets(availables) curselection] eq "" } {
		::DYE::GUI::disable_widgets select_equipment* ::DYE::SEQ
	} else {
		::DYE::GUI::enable_widgets select_equipment* ::DYE::SEQ
	}
}
	
proc ::DYE::SEQ::selected_select {} {
	variable widgets
	variable data
	set sel_idx [$widgets(selected) curselection]
#	set setting_widget $widgets(selected_setting)
	if { $sel_idx eq "" } {
		set data(selected_setting) {}
		::DYE::GUI::disable_widgets "unselect_equipment* selected_setting* selected_setting_dropdown*" ::DYE::SEQ
	} else {
		::DYE::GUI::enable_widgets "unselect_equipment*" ::DYE::SEQ
		
		if { [llength $sel_idx] == 1} {
			set data(selected_setting) [lindex $data(selected_settings) $sel_idx]
			::DYE::GUI::enable_widgets "selected_setting* selected_setting_dropdown*" ::DYE::SEQ
		} else {
			set data(selected_setting) {}
			::DYE::GUI::disable_widgets "selected_setting* selected_setting_dropdown*" ::DYE::SEQ
		}
	}	
}

proc ::DYE::SEQ::selected_setting_change {} {
	variable data
	hide_android_keyboard
	set selected_widget $::DYE::SEQ::widgets(selected)
	set sel_idx [$selected_widget curselection]
	if { $sel_idx eq "" } return
	
	set old_setting [lindex $data(selected_settings) $sel_idx]
	if { $old_setting ne $data(selected_setting) } {
		set data(selected_settings) [lreplace $data(selected_settings) $sel_idx $sel_idx $data(selected_setting)] 
		set new_desc "[lindex $data(selected_types) $sel_idx] - [lindex $data(selected_names) $sel_idx]"
		if { $data(selected_setting) ne "" } {
			append new_desc " \[$data(selected_setting)\]"
		}
		set data(selected) [lreplace $data(selected) $sel_idx $sel_idx $new_desc]
	}
}

proc ::DYE::SEQ::selected_setting_dropdown_click {} {
	variable data
	say "" $::settings(sound_button_in)			
	set selected_widget $::DYE::SEQ::widgets(selected)
	set sel_idx [$selected_widget curselection]
	if { $sel_idx eq "" } return
		
	::DYE::IS::load_page equipment_setting ::DYE::SEQ::select_setting_callback $data(selected_setting) \
		"single" 1000 "equipment_name=[::DYE::DB::string2sql [lindex $data(selected_names) $sel_idx]] AND \
			equipment_type=[::DYE::DB::string2sql [lindex $data(selected_types) $sel_idx]]"
}
	
	
# Callback procedure returning control from the item_selection page to the equipment page, to select the 
# selected equipment setting from the list of previously entered values. 
proc ::DYE::SEQ::select_setting_callback { setting_id setting args } {
	variable data
	if { $setting ne "" } {
		set data(selected_setting) $setting
	}
	
	page_to_show_when_off [namespace current]
}

proc ::DYE::SEQ::page_cancel {} {
	say [translate {cancel}] $::settings(sound_button_in);
	page_to_show_when_off [namespace current]
}

proc ::DYE::SEQ::page_done {} {
	variable data
	say [translate {done}] $::settings(sound_button_in)
	set other_equipment {} 
	for {set i 0} { $i < [llength $data(selected)] } {incr i} {
		lappend other_equipment [lindex $data(selected_names) $i] \
			[lindex $data(selected_types) $i] [lindex $data(selected_settings) $i]
	}
	set ::DYE::DE::data(other_equipment) $other_equipment
	page_to_show_when_off [namespace current]
}

### "MODIFY CATEGORY" PAGE #############################################################################################

namespace eval ::DYE::MODC {
	# State variables for the "DYE_modify_category" page. Not persisted. 
	variable widgets
	array set widgets {}
	# affected_shots_slider 1
	
	variable data
	array set data {
		page_name "::DYE::MODC"
		previous_page {}
		page_title {}
		allow_add 1
		edit_mode "modify"
		category {}
		categories {}
		types {}
		add_value {}
		modify_value {}
		affected_shots {}
		affected_shots_filenames {}
		affected_shots_label {Init}
		modify_only_selected 0
		backup_shot_files 0
		modify_status {}
	}
}

# Prepare and launch the DYE_modify_category page.
proc ::DYE::MODC::load_page { category {selected {} } { allow_add {} } args } {	
	variable data
	variable widgets
	
	foreach f "add_value affected_shots affected_shots_filenames" { set data($f) {} } 

	lassign [DYE::field_lookup $category "name_plural desc_section lookup_table"] cat_name_plural desc_section lookup_table
	if { $desc_section eq "equipment" } { DYE::DB::update_equipment_categories }
	if { $allow_add eq "" } [set allow_add [expr {$lookup_table ne ""}]]
	
	set data(category) $category
	set data(page_title) "[translate {Edit}] [string tolower [translate $cat_name_plural]]"
	set data(types) $args
	set data(allow_add) $allow_add
	modify_value_change
	set data(backup_shot_files) $::DYE::settings(backup_modified_shot_files)
	fill_categories_listbox 0
		
	set ns [namespace current]
	DYE::GUI::set_previous_page $ns 
	page_to_show_when_off $ns	
	
	DYE::GUI::set_scrollbars_dims $ns "categories affected_shots"
	if { $category eq "equipment" } {
		::DYE::GUI::show_widgets "modify_type* modify_setting* modify_option*" $ns
	} else {
		::DYE::GUI::hide_widgets "modify_type* modify_setting* modify_option*" $ns
	}
	
	set_edit_mode "modify"
	if { $allow_add == 1 } {
		DYE::GUI::enable_widgets "action_add*" $ns
	} else {
		DYE::GUI::disable_widgets "action_add*" $ns
	}
	
	if { $selected eq "" } { 
		if { [$widgets(categories) size] > 0 } { $widgets(categories) selection set 0 }
	} else {
		DYE::GUI::listbox_set_selection $widgets(categories) $selected
	}
	categories_select
#	set data(modify_value) $new_value
		
	hide_android_keyboard
}

proc ::DYE::MODC::setup_ui {} {
	variable data
	variable widgets
	set page [namespace current]

	::DYE::GUI::add_page $page -buttons_loc center -cancel_button 0

	# LEFT COLUMN
	set x 100; set y 175
	DYE::GUI::add_listbox $page "categories" $x $y $x $y 45 13 -label ""
	bind $widgets(categories) <<ListboxSelect>> ::DYE::MODC::categories_select

	# Main actions selector
	set x_actions 1150
	DYE::GUI::add_symbol $page $x_actions [incr y 40] "pencil" -widget_name action_modify -has_button 1 \
		-button_cmd {::DYE::MODC::set_edit_mode modify} -anchor center
	
	DYE::GUI::add_symbol $page $x_actions [incr y 100] "plus" -widget_name action_add -has_button 1 \
		-button_cmd { if { $::DYE::MODC::data(allow_add) == 1 } { ::DYE::MODC::set_edit_mode add } } -anchor center

	DYE::GUI::add_symbol $page $x_actions [incr y 100] "eraser" -widget_name action_remove -has_button 1 \
		-button_cmd {::DYE::MODC::set_edit_mode remove} -anchor center
	
	DYE::GUI::add_symbol $page $x_actions [incr y 180] "circle_up" -widget_name category_up -has_button 1 \
		-button_cmd ::DYE::MODC::move_category_up -anchor center
	
	DYE::GUI::add_symbol $page $x_actions [incr y 100] "circle_down" -widget_name category_down -has_button 1 \
		-button_cmd ::DYE::MODC::move_category_down -anchor center
	
	set y 900
	DYE::GUI::add_listbox $page "affected_shots" $x $y $x [expr {$y+60}] 110 8 -selectmode "multiple"
	set data(affected_shots_label) "Text label"
	bind $widgets(affected_shots) <<ListboxSelect>> ::DYE::MODC::update_affected_shots_label
	
	# RIGHT COLUMN
	set x_label 1350; set x_widget 1600; set y 175; set width 40
	DYE::GUI::add_text_entry $page "modify_value" [expr {$x_widget-20}] $y $x_widget $y $width -label "Modify value" \
		-label_anchor ne -label_justify right
	bind $widgets(modify_value) <KeyRelease> ::DYE::MODC::modify_value_change 

	DYE::GUI::add_variable $page 2400 [incr y 60] {$::DYE::MODC::data(modify_status)} -anchor "ne" \
		-justify "right" -width 700 -fill $::DYE::GUI::remark_color
	
	DYE::GUI::add_text_entry $page "modify_type" [expr {$x_widget-20}] [incr y 70] $x_widget $y $width \
		-label "Modify type" -label_anchor ne -label_justify right  

	DYE::GUI::add_text_entry $page "modify_setting" [expr {$x_widget-20}] [incr y 90] $x_widget $y $width \
		-label "Default setting" -label_anchor ne -label_justify right  

	DYE::GUI::add_checkbox $page "modify_option" $x_widget [incr y 90] "::DYE::MODC::modify_option_change" \
		-label [translate "Propagate from one shot to the next"]
	
	set x 1475; set y 625
	DYE::GUI::add_checkbox $page modify_only_selected $x $y "::DYE::MODC::update_affected_shots_label" \
		-label [translate "Modify only selected shots"]

	DYE::GUI::add_checkbox $page backup_shot_files $x [incr y 100] {} \
		-label [translate "Backup modified shot files"]
	
	DYE::GUI::add_button2 $page "modify" 2050 600 [translate "Modify\rvalue"] {} "pencil" \
		{ ::DYE::MODC::$::DYE::MODC::data(edit_mode)_click }
	
}

# Runs after editing new_value
proc ::DYE::MODC::set_edit_mode { edit_mode } {
	variable data
	variable widgets
	set ns [namespace current]
	if { $edit_mode ne "add" && $edit_mode ne "remove" } { set edit_mode "modify" }
	set data(edit_mode) $edit_mode
	
	foreach action "modify add remove" {
		if { ! ($action eq "add" && $data(allow_add) == 0) } {
			if { $action eq $edit_mode} {
				.can itemconfig $widgets(action_$action) -fill $::DYE::GUI::remark_color
			} else {
				.can itemconfig $widgets(action_$action) -fill $::DYE::GUI::font_color
			}
		}
	}
	
	if { $edit_mode eq "add" || $edit_mode eq "modify" } {
		::DYE::GUI::enable_widgets "modify_value* modify_type* modify_setting* modify_option*" $ns
	} else {
		::DYE::GUI::disable_widgets "modify_value* modify_type* modify_setting* modify_option*" $ns
	}
	
	if { $edit_mode eq "add" } {
		set data(modify_value) ""
		modify_value_change
		.can itemconfig $widgets(modify_value_label) -text [translate "Add new value"]
		.can itemconfig $widgets(modify_label) -text [translate "Add new\rvalue"]
		.can itemconfig $widgets(modify_symbol) -text $::DYE::GUI::symbol_plus
		DYE::GUI::disable_widgets "categories* category_up* category_down* affected_shots* modify_only_selected* \
			backup_shot_files*" $ns
	} elseif { $edit_mode eq "modify" } {
		DYE::GUI::enable_widgets "categories* category_up* category_down* affected_shots* modify_only_selected* \
			backup_shot_files*" $ns
		.can itemconfig $widgets(modify_value_label) -text [translate "Modify value"]
		.can itemconfig $widgets(modify_label) -text [translate "Modify\rvalue"]
		.can itemconfig $widgets(modify_symbol) -text $::DYE::GUI::symbol_pencil
		categories_select
	} else {
		DYE::GUI::enable_widgets "categories* category_up* category_down* affected_shots* modify_only_selected* \
			backup_shot_files*" MODC
		.can itemconfig $widgets(modify_value_label) -text [translate "Remove value"]
		.can itemconfig $widgets(modify_label) -text [translate "Remove\rvalue"]
		.can itemconfig $widgets(modify_symbol) -text $::DYE::GUI::symbol_eraser
		categories_select
	}
}

proc DYE::MODC::fill_categories_listbox { {preserve_selection 1 } } {
	variable data
	variable widgets	
	if { $preserve_selection == 1 } {
		set sel_value [::DYE::GUI::listbox_get_selection $widgets(categories)]
	} 
	$widgets(categories) selection clear 0 end
	
	set data(categories) [::DYE::DB::available_categories $data(category)]

	if { $preserve_selection == 1 && $sel_value ne "" } {
		::DYE::GUI::listbox_set_selection $widgets(categories) $sel_value 
	}	
}

# Runs after editing new_value
proc ::DYE::MODC::modify_value_change {} {
	variable data
	variable widgets
	set ns [namespace current]
	
	set edit_mode $data(edit_mode)
	set new_value $data(modify_value)
	
	if { $edit_mode eq "add" } {
		if { [string length $new_value] == 0 } {
			::DYE::GUI::disable_widgets modify* $ns
			set data(modify_status) [translate "Please type a new value"]
		} elseif { [lsearch -exact $data(categories) $new_value] > -1 } {
			::DYE::GUI::disable_widgets modify* $ns
			set data(modify_status) [translate "New value already exists"]
		} else {
			::DYE::GUI::enable_widgets modify* $ns
			set data(modify_status) ""
		}		
	} elseif { $edit_mode eq "modify" } {
		set old_value [::DYE::GUI::listbox_get_selection $widgets(categories)]
		if { [llength $old_value] == 0 } { set old_value "" } else { set old_value [lindex $old_value 0] }
		
		if { [string length $new_value] == 0 } {
			::DYE::GUI::disable_widgets modify* $ns 
			set data(modify_status) [translate "Please type a non-empty new value"]
		} elseif { $old_value eq $new_value } {
			::DYE::GUI::disable_widgets modify* $ns
			set data(modify_status) [translate "Modified value is unchanged"]
		} elseif { [lsearch -exact $data(categories) $new_value] > -1 } {
			::DYE::GUI::enable_widgets modify* $ns
			set data(modify_status) [translate "Modified value is identical to existing value. They'll be be joined"]
		} else {
			::DYE::GUI::enable_widgets modify* $ns
			set data(modify_status) ""
		}						
	} elseif { $edit_mode eq "remove" } {
		set data(modify_status) [translate "The old value will be emptied / removed"]
		::DYE::GUI::enable_widgets modify* $ns
	}	
}

proc ::DYE::MODC::categories_select {} {
	variable data
	variable widgets
	set ns [namespace current]
	if { $data(edit_mode) eq "add" } return
	
	set sel_idx [$widgets(categories) curselection] 
	if { $sel_idx eq "" } {
		set data(affected_shots_filenames) {} 
		set data(affected_shots) {}	
		set data(modify_value) {}
		::DYE::GUI::disable_widgets "modify_value* modify_type* modify_setting* modify_option* modify* \
			category_up* category_down*" $ns
	} else {
		if { [llength $sel_idx] > 1 } { set sel_idx [lindex $sel_idx 0] }
		if { $data(edit_mode) eq "modify" } {
			::DYE::GUI::enable_widgets "modify_value* modify_type* modify_setting* modify_option*" $ns
		} 
		
		set data(modify_value) [$widgets(categories) get $sel_idx]
		modify_value_change
		
		array set affected_shots [::DYE::DB::shots_using_category $data(category) $data(modify_value) "filename shot_desc"]
		if { [array size affected_shots] == 0 } {
			set data(affected_shots_filenames) {} 
			set data(affected_shots) {}		
		} else { 
			set data(affected_shots_filenames) $affected_shots(filename) 
			set data(affected_shots) $affected_shots(shot_desc)
		}
		
		if { $sel_idx == 0 } {
			::DYE::GUI::disable_widgets category_up* $ns
			::DYE::GUI::enable_widgets category_down* $ns
		} elseif { [expr {$sel_idx+1}] == [$widgets(categories) size] } {
			::DYE::GUI::enable_widgets category_up* $ns
			::DYE::GUI::disable_widgets category_down* $ns
		} else {
			::DYE::GUI::enable_widgets "category_up* category_down*" $ns
		}
	}
	update_affected_shots_label
}

# Updates the text above the affected shots listbox to inform the number of shots that will be modified.
proc ::DYE::MODC::update_affected_shots_label {} {
	variable data 
	set text ""
	
	set only_selected $data(modify_only_selected)
	if { $only_selected == 1 } {
		set n [llength [$::DYE::MODC::widgets(affected_shots) curselection]]
	} else {
		set n [llength $data(affected_shots)]
	}
	
	if { $n == 0 } {
		set text [translate "No shots will be modified"]
	} elseif { $n == 1 } {
		if { $only_selected == 1 } {
			set text "$n [translate {SELECTED shot will be permanently modified}]"
		} else {
			set text "$n [translate {shot will be permanently modified}]"
		}
	} else {
		if { $only_selected == 1 } {
			set text "$n [translate {SELECTED shots will be permanently modified}]"
		} else {
			set text "$n [translate {shots will be permanently modified}]"
		}
	}

	set data(affected_shots_label) $text 
}
	
proc ::DYE::MODC::move_category_up {} {
	variable widgets
	variable data
	set sel_idx [$widgets(categories) curselection]
	if { $sel_idx eq "" || $sel_idx == 0 } return
	# Prevent double taps, which screws up things
	::DYE::GUI::disable_widgets "category_up_button category_down_button" ::DYE::MODC

	set field_name $data(category)
	lassign [DYE::field_lookup $field_name {lookup_table}] lookup_table
	if { $lookup_table eq "" } return
	
	set db [::DYE::DB::get_db]
	set current_sel [lindex $data(categories) $sel_idx]
	set current_sel_sort [db eval "SELECT sort_number FROM $lookup_table WHERE $field_name=[::DYE::DB::string2sql $current_sel]" ]
	set prev_sel [lindex $data(categories) [expr {$sel_idx-1}]]
	set prev_sel_sort [db eval "SELECT sort_number FROM $lookup_table WHERE $field_name=[::DYE::DB::string2sql $prev_sel]" ]
	db eval "UPDATE $lookup_table SET sort_number=$current_sel_sort WHERE $field_name=[::DYE::DB::string2sql $prev_sel]; 
		UPDATE $lookup_table SET sort_number=$prev_sel_sort WHERE $field_name=[::DYE::DB::string2sql $current_sel];" 
	
	fill_categories_listbox 1
	categories_select
}

proc ::DYE::MODC::move_category_down {} {
	variable widgets
	variable data
	set sel_idx [$widgets(categories) curselection]
	if { $sel_idx eq "" || $sel_idx == [expr {[$widgets(categories) size]-1}] } return
	# Prevent double taps, which screws up things
	::DYE::GUI::disable_widgets "category_up_button category_down_button" ::DYE::MODC

	set field_name $data(category)
	lassign [DYE::field_lookup $field_name {lookup_table}] lookup_table
	if { $lookup_table eq "" } return
	
	set db [::DYE::DB::get_db]
	set current_sel [lindex $data(categories) $sel_idx]
	set current_sel_sort [db eval "SELECT sort_number FROM $lookup_table WHERE $field_name=[::DYE::DB::string2sql $current_sel]"]
	set next_sel [lindex $data(categories) [expr {$sel_idx+1}]]
	set next_sel_sort [db eval "SELECT sort_number FROM $lookup_table WHERE $field_name=[::DYE::DB::string2sql $next_sel]" ]
	db eval "UPDATE $lookup_table SET sort_number=$current_sel_sort WHERE $field_name=[::DYE::DB::string2sql $next_sel]; 
		UPDATE $lookup_table SET sort_number=$next_sel_sort WHERE $field_name=[::DYE::DB::string2sql $current_sel];" 
	
	fill_categories_listbox 1
	categories_select
}

# Performs the actual modification of the category value.
proc DYE::MODC::modify_click {} {
	variable data
	variable widgets	
	say "" $::settings(sound_button_in)
	
	set old_value [::DYE::GUI::listbox_get_selection $widgets(categories)]
	set new_value $data(modify_value)
	if { $data(edit_mode) ne "modify" || $old_value eq "" || $new_value eq "" || $old_value eq $new_value } return
	
	if { $data(modify_only_selected) == 1 } {
		set target_shots [::DYE::GUI::listbox_get_selection $widgets(affected_shots) $data(affected_shots_filenames)]
		set n_target_shots [llength $target_shots]
		set use_specified_files 1
	} else {
		set use_specified_files 0
		set target_shots {}
		set n_target_shots [llength $data(affected_shots_filenames)]
	}

	if { $n_target_shots == 0 } {
		set data(modify_status) [translate "Modifying database, please wait..."]
	} else {
		set data(modify_status) [translate "Modifying database and shot files, please wait..."]
	}			
	update
	#::update_onscreen_variables
	
	say [translate "modifying"] ""
	borg spinner on

#msg "DYE DEBUG: modify_click old_vaue='$old_value', new_value='$new_value'"	
#msg "DYE DEBUG: target_shots='$target_shots'"	
#msg "DYE DEBUG: data(types)='$data(types)'"
	set modified_shots [::DYE::DB::NEW_update_category $data(category) $old_value $new_value $use_specified_files \
		$target_shots {*}$data(types)]
	
	set result_msg "[translate {Database modified}]\r"
	if { [llength $modified_shots] == 0 } {
		append result_msg [translate "No shot files modified"]
	} elseif { [llength $modified_shots] == 1 } {
		append result_msg "[llength $modified_shots] [translate {shot file modified}]"
	} else {
		append result_msg "[llength $modified_shots] [translate {shot files modified}]"
	}
	set data(modify_status) $result_msg

	fill_categories_listbox
	::DYE::GUI::listbox_set_selection $widgets(categories) "$new_value"
	categories_select
	
	borg spinner off
	borg systemui $::android_full_screen_flags
}

proc ::DYE::MODC::add_click {} {
	variable data
	variable widgets	
	say "" $::settings(sound_button_in)
	
	set new_value $data(modify_value)
	if { $data(edit_mode) ne "add" || $new_value eq "" } {
		set data(modify_status) [translate "Can't add category"]
		return
	}
	
	set n_added [::DYE::DB::add_category $data(category) $new_value]
	
	if { $n_added == 0 } {
		set data(modify_status) [translate "Can't add category"]
	} else {
		set data(modify_status) [translate "New category added"]
		set $data(modify_value) ""
		fill_categories_listbox 0
		DYE::GUI::listbox_set_selection $widgets(categories) "$new_value"
		categories_select
	}
}

proc ::DYE::MODC::remove_click {} {
	variable data
	variable widgets	
	say "" $::settings(sound_button_in)
	
	set sel_idx [$widgets(categories) curselection]
	set remove_value $data(modify_value)
	
	if { $data(edit_mode) ne "remove" || $remove_value eq "" } {
		set data(modify_status) [translate "Can't remove category"]
		return
	}
	
	set n_removed [::DYE::DB::remove_category $data(category) $remove_value]
	
	if { $n_removed == 0 } {
		set data(modify_status) [translate "Can't remove category"]
	} else {
		set data(modify_status) [translate "Category removed"]
		set $data(modify_value) ""
		fill_categories_listbox 0
		if { $sel_idx eq "" } {
			set sel_idx 0
		} elseif { $sel_idx == [$widgets(categories) size] }  {
			set sel_idx [expr {$sel_idx-1}]
		}
		$widgets(categories) selection set $sel_idx
		categories_select
	}
}

proc ::DYE::MODC::page_done {} {
	variable data
	page_to_show_when_off $data(previous_page)	
}
	
proc ::DYE::MODC::page_cancel {} {
	variable data
	page_to_show_when_off $data(previous_page)	
}
	
### "SHORTCUTS MENU" PAGE #############################################################################################

namespace eval ::DYE::MENU {
	# State variables for the "DYE_menu" page. Not persisted. 
	variable widgets
	array set widgets {}
	# affected_shots_slider 1
	
	variable data
	array set data {
		page_name "::DYE::MENU"
		previous_page {}
		page_title {}
		previous_page {}
	}
}

# Prepare and launch the DYE_modify_category page.
proc ::DYE::MENU::load_page { } {	
	variable data
	variable widgets
	set ns [namespace current]
	
	::DYE::GUI::set_previous_page $ns
	page_to_show_when_off $ns	
		
	hide_android_keyboard
}

proc ::DYE::MENU::setup_ui {} {
	variable data
	variable widgets
	set page [namespace current]

	add_de1_image $page 0 0 "[skin_directory_graphics]/background/bg2.jpg"

	::DYE::GUI::add_text $page 650 100 [translate "Menu"] -widget_name page_title \
		-font [DSx_font font $::DYE::GUI::header_font_size] -fill $::DYE::GUI::page_title_color \
		-anchor "center" 

	# Close menu
	::DYE::GUI::add_symbol $page 1200	60 window_close -widget_name close_page -has_button 1 \
		-button_cmd ::DYE::MENU::page_done

	# DYE shortcuts
	set x 100; set y 200
	
	::DYE::GUI::add_text $page $x $y [translate "Edit equipment types"] -widget_name edit_equipment -has_button 1 \
		-button_width 400 -button_cmd {say "" $::settings(sound_button_in); ::DYE::MODC::load_page equipment_type}

	::DYE::GUI::add_text $page $x [incr y 80] [translate "Filter shot history"] -widget_name fsh -has_button 1 \
		-button_width 400 -button_cmd {say "" $::settings(sound_button_in); ::DYE::FSH::load_page}

	::DYE::GUI::add_text $page $x [incr y 80] [translate "Numbers editor"] -widget_name edit_number -has_button 1 \
		-button_width 400 -button_cmd {say "" $::settings(sound_button_in); ::DYE::NUME::load_page drink_tds }
	
	set x 800; set y 200
	
	::DYE::GUI::add_text $page $x $y [translate "DYE settings"] -widget_name edit_equipment -has_button 1 \
		-button_width 400 -button_cmd {say "" $::settings(sound_button_in); ::DYE::CFG::load_page}
	
}

proc ::DYE::MENU::page_done {} {
	variable data
	page_to_show_when_off $data(previous_page)
}

### "CONFIGURATION SETTINGS" PAGE ######################################################################################

namespace eval ::DYE::CFG {
	variable widgets
	array set widgets {}
	
	variable data
	array set data {
		page_name "::DYE::CFG"
		db_status_msg {}
		update_plugin_state {-}
		latest_plugin_version {}
		latest_plugin_url {}
		latest_plugin_desc {}
		update_plugin_msg {}
		plugin_has_been_updated 0
	}
}

# Normally not usedas this is not invoked directly but by the DSx settings pages carousel, but still kept for 
# consistency or for launching the page from a menu.
proc ::DYE::CFG::load_page {} {
	page_to_show_when_off [namespace current]
}

# Added to context actions, so invoked automatically whenever the page is loaded
proc ::DYE::CFG::show_page {} {	
	::DYE::CFG::update_plugin_state	
}

# Setup the "DYE_configuration" page User Interface.
proc ::DYE::CFG::setup_ui {} {
	variable widgets
	set page [namespace current]

	# HEADERS
	::DYE::GUI::add_page $page -add_bg_img 0 -title "Describe Your Espresso Settings" \
		-cancel_button 0 -done_button 0
		
	set y 200
	::DYE::GUI::add_text $page 600 $y [translate "General options"] -font [DSx_font font 10] 	-anchor "center" -justify "center" 	
	::DYE::GUI::add_text $page 1900 $y [translate "Database"] -font [DSx_font font 10] -anchor "center" -justify "center"	
	
	# LEFT SIDE
	set x_label 100; incr y 100
	::DYE::GUI::add_checkbox $page ::DYE::settings(show_shot_desc_on_home) $x_label $y \
		::DYE::CFG::show_shot_desc_on_home_change -use_page_var 0 \
		-widget_name show_shot_desc_on_home \
		-label [translate "Show next & last shot description summaries on DSx home page"]
		
	incr y 80
	::DYE::GUI::add_checkbox $page ::DYE::settings(propagate_previous_shot_desc) $x_label $y \
		::DYE::CFG::propagate_previous_shot_desc_change -use_page_var 0 \
		-widget_name propagate_previous_shot_desc \
		-label [translate "Propagate Beans, Equipment & People from last to next shot"]

	incr y 80
	::DYE::GUI::add_checkbox $page ::DYE::settings(describe_from_sleep) $x_label $y \
		::DYE::CFG::describe_from_sleep_change -use_page_var 0 \
		-widget_name describe_from_sleep \
		-label [translate "Icon on screensaver to describe last shot without waking up DE1"]

	incr y 80
	::DYE::GUI::add_checkbox $page ::DYE::settings(backup_modified_shot_files) $x_label $y \
		::DYE::CFG::backup_modified_shot_files_change -use_page_var 0 \
		-widget_name backup_modified_shot_files \
		-label [translate "Backup past shot files when they are modified (.bak)"]
	
	incr y 80
	::DYE::GUI::add_checkbox $page ::DYE::settings(use_stars_to_rate_enjoyment) $x_label $y \
		::DYE::save_settings -use_page_var 0 \
		-widget_name use_stars_to_rate_enjoyment \
		-label [translate "Use 1-5 stars rating to evaluate enjoyment"]
			
	incr y 150
	::DYE::GUI::add_button2 $page shot_desc_font_color $x_label $y [translate "Shots\rsummaries\rcolor"] \
		"" paintbrush ::DYE::CFG::shot_desc_font_color_change -symbol_fill $::DYE::settings(shot_desc_font_color)
	incr y [expr {$::DYE::GUI::button2_height+35}]
	::DYE::GUI::add_text $page [expr {$x_label+$::DYE::GUI::button2_width/2}] $y "\[ [translate {Use default color}] \]" \
		-anchor center -justify center -fill $::DYE::GUI::default_shot_desc_font_color
	::add_de1_button $page ::DYE::CFG::set_default_shot_desc_font_color $x_label [expr {$y-20}] \
		[expr {$x_label+$::DYE::GUI::button2_width}] [expr {$y+50}]
	
	set x_widget 470; incr y 125
	::DYE::GUI::add_text_entry $page {} $x_label $y $x_widget $y 30 -widget_name visualizer_username \
		-label [translate "Visualizer username"] -textvariable ::DYE::settings(visualizer_username)
	bind $widgets(visualizer_username) <Leave> {
		set ::DYE::settings(visualizer_username) [string trim $::DYE::settings(visualizer_username)]
		::DYE::save_settings }
	
	incr y 80
	::DYE::GUI::add_text_entry $page {} $x_label $y $x_widget $y 30 -widget_name visualizer_password \
		-label [translate "Visualizer password"] -textvariable ::DYE::settings(visualizer_password)
	bind $widgets(visualizer_password) <Leave> { 
		set ::DYE::settings(visualizer_password) [string trim $::DYE::settings(visualizer_password)]
		::DYE::save_settings }	

	incr y 100
	::DYE::GUI::add_text $page $x_label $y [translate "Visualizer last result"]
	::DYE::GUI::add_variable $page $x_widget $y {$::DYE::settings(last_visualizer_result)} -width 1000
	
	# RIGHT SIDE
	set x_label 1600; set y 300
	::DYE::GUI::add_checkbox $page ::DYE::settings(db_persist_series) $x_label $y \
		::DYE::CFG::db_persist_series_change -use_page_var 0 \
		-widget_name db_persist_series \
		-label [translate "Store chart series on database"]
	
	incr y 100
	::DYE::GUI::add_button2 $page resync_db $x_label $y [translate "Resync\rdatabase"] \
		"" sync ::DYE::CFG::resync_db
	
	::DYE::GUI::add_variable $page [expr {$x_label+$::DYE::GUI::button2_width+75}] $y {[translate {Last full sync}]:
[clock format $::DYE::settings(last_sync_clock) -format $::DYE::friendly_clock_format]\r 
[translate {# Analyzed}]: $::DYE::settings(last_sync_analyzed)
[translate {# Added}]: $::DYE::settings(last_sync_inserted)
[translate {# Modified}]: $::DYE::settings(last_sync_modified)
[translate {# Archived}]: $::DYE::settings(last_sync_archived)
[translate {# Unarchived}]: $::DYE::settings(last_sync_unarchived)
[translate {# Removed}]: $::DYE::settings(last_sync_removed)
[translate {# Unremoved}]: $::DYE::settings(last_sync_unremoved)} \
		-widget_name "last_sync" -fill $::DYE::GUI::default_shot_desc_font_color
	
	incr y [expr {$::DYE::GUI::button2_height+60}]
	::DYE::GUI::add_button2 $page rebuild_db $x_label $y [translate "Rebuild\rdatabase"] \
		"" db ::DYE::CFG::rebuild_db

	incr y [expr {$::DYE::GUI::button2_height+60}]
	::DYE::GUI::add_variable $page $x_label $y {$::DYE::GUI::db_progress_msg} -fill $::DYE::GUI::remark_color	

	incr y 60
	::DYE::GUI::add_variable $page $x_label $y {$::DYE::CFG::data(db_status_msg)} -fill $::DYE::GUI::error_color
	
	# Auto-updater
	incr y 60
	::DYE::GUI::add_button2 $page update_plugin $x_label $y [translate "Update\rplugin"] 1 cloud_download_alt \
		::DYE::CFG::update_plugin_click
		
	::DYE::GUI::add_variable $page [expr {$x_label+$::DYE::GUI::button2_width+60}] $y \
		{$::DYE::CFG::data(update_plugin_msg)} -width 220 -fill $::DYE::GUI::remark_color -has_button 1 \
		-button_cmd ::DYE::CFG::show_latest_plugin_description
	
	# FOOTER (versions)
	::DYE::GUI::add_text $page 2150 1520 "DYE plugin v$::DYE::plugin_version - DB v$::DYE::db_version" \
		-font [DSx_font font 7] -justify center -anchor center
	
	::add_de1_action $page ::DYE::CFG::show_page
}

proc ::DYE::CFG::show_shot_desc_on_home_change {} {	
	::DYE::define_last_shot_desc
	::DYE::define_next_shot_desc
	::DYE::save_settings
}

proc ::DYE::CFG::propagate_previous_shot_desc_change {} {
	if { $::DYE::settings(propagate_previous_shot_desc) == 1 } {
		if { $::DYE::settings(next_modified) == 0 } {
			foreach field_name $::DYE::propagated_fields {
				set ::DYE::settings(next_$field_name) $::settings($field_name)
			}
			set ::DYE::settings(next_espresso_notes) {}
		}
	} else {
		if { $::DYE::settings(next_modified) == 0 } {
			foreach field_name "$::DYE::propagated_fields next_espresso_notes" {
				set ::DYE::settings(next_$field_name) {}
			}			
		}
	}
	
	::DYE::define_next_shot_desc
	::DYE::save_settings
}
	
proc ::DYE::CFG::describe_from_sleep_change {} {
	if { $::DYE::settings(describe_from_sleep) == 1 } {
		.can itemconfig $::DYE::GUI::widgets(describe_from_sleep_symbol) -text $::DYE::settings(describe_icon)
		.can coords $::DYE::GUI::widgets(describe_from_sleep_button) [rescale_x_skin 230] [rescale_y_skin 0] \
			[rescale_x_skin 460] [rescale_y_skin 230]
	} else {
		.can itemconfig $::DYE::GUI::widgets(describe_from_sleep_symbol) -text ""
		.can coords $::DYE::GUI::widgets(describe_from_sleep_button) 0 0 0 0
	}	
	::DYE::save_settings
}
	
proc ::DYE::CFG::backup_modified_shot_files_change {} {	
	::DYE::save_settings
}

proc ::DYE::CFG::shot_desc_font_color_change {} {
	say "" $::settings(sound_button_in)	
	set colour [tk_chooseColor -initialcolor $::DYE::settings(shot_desc_font_color) \
		-title [translate "Set shot summary descriptions color"]]
	if {$colour != {}} {
		foreach fn "DSx_home_next_shot_desc DSx_home_last_shot_desc DSx_past_shot_desc DSx_past_shot_desc2 \
				DSx_past_zoomed_shot_desc DSx_past_zoomed_shot_desc2" {
			.can itemconfigure $::DYE::GUI::widgets($fn) -fill $colour
		}
		.can itemconfigure $::DYE::CFG::widgets(shot_desc_font_color_symbol) -fill $colour
		
		set ::DYE::settings(shot_desc_font_color) $colour
		::DYE::save_settings
	}	
}

proc ::DYE::CFG::set_default_shot_desc_font_color {} {
	say "" $::settings(sound_button_in)
	set colour $::DYE::GUI::default_shot_desc_font_color	
	foreach fn "DSx_home_next_shot_desc DSx_home_last_shot_desc DSx_past_shot_desc DSx_past_shot_desc2 \
			DSx_past_zoomed_shot_desc DSx_past_zoomed_shot_desc2" {
		.can itemconfigure $::DYE::GUI::widgets($fn) -fill $colour
	}
	.can itemconfigure $::DYE::CFG::widgets(shot_desc_font_color_symbol) -fill $colour
	
	set ::DYE::settings(shot_desc_font_color) $colour
	::DYE::save_settings
}

proc ::DYE::CFG::db_persist_series_change {} {
	set ns [namespace current]
	
	if { $::DYE::DB::updating_db == 1 } {
		set ::DYE::CFG::data(db_status_msg) [translate "Database busy. Try later"]
		set ::DYE::settings(db_persist_series) [expr {!$::DYE::settings(db_persist_series)}]
		after 3000 { set ::DYE::CFG::data(db_status_msg) "" }
		return
	}
	
	::DYE::save_settings
	
	if { $::DYE::settings(db_persist_series) == 1 } {
		if { [::DYE::DB::n_shots_without_series] > 0 } {
			set answer [tk_messageBox -message "[translate {Do you want to add missing shot series to the database now?}]\r\r\
				[translate {(if you select 'No', only the series for new shots will be stored)}]" \
				-type yesnocancel -icon question]
			if { $answer eq "yes" } { 
				borg spinner on	 
				::DYE::GUI::disable_widgets {db_persist_series* rebuild_db* resync_db*} $ns
				if {[catch { ::DYE::DB::populate 0 1 1 1 } err] != 0} {
					msg "DYE DB: ERROR populating DB: $err"
					set ::DYE::GUI::db_progress_msg [translate "Failed to sync DB:\r$err"]
					update	
				}
				::DYE::GUI::enable_widgets {db_persist_series* rebuild_db* resync_db*} $ns
				borg spinner off
				borg systemui $::android_full_screen_flags
				after 3000 { set ::DYE::GUI::db_progress_msg "" }
			} elseif { $answer eq "cancel" } {
				set ::DYE::settings(db_persist_series) 0
				return
			}
		}
	} else {
		if { [::DYE::DB::has_shot_series_data] } {
			set answer [tk_messageBox -message "[translate {The database currently contains some shot series data.}]\r\r\
				[translate {Do you want to remove them? (select 'No' to maintain them)}]" \
				-type yesnocancel -icon question]
			if { $answer eq "yes" } { 
				::DYE::GUI::disable_widgets {db_persist_series* rebuild_db* resync_db*} $ns
				::DYE::DB::delete_shot_series_data
				::DYE::GUI::enable_widgets {db_persist_series* rebuild_db* resync_db*} $ns
			} elseif { $answer eq "cancel" } {
				set ::DYE::settings(db_persist_series) 1
				return
			}
		}
		
	}
	
}
	
proc ::DYE::CFG::rebuild_db {} {
	say "" $::settings(sound_button_in)
	set ns [namespace current]
	
	#set ::DYE::debug_text "updating_db=$::DYE::DB::updating_db"
	if { $::DYE::DB::updating_db == 1 } {
		set ::DYE::CFG::data(db_status_msg) [translate "Database busy. Try later"]
		after 3000 { set ::DYE::CFG::data(db_status_msg) "" }
		return
	}
	
	borg spinner on	
	::DYE::GUI::disable_widgets {db_persist_series* rebuild_db* resync_db*} $ns
	
	if {[catch { ::DYE::DB::create 1 1 1 } err] != 0} {
		msg "DYE DB: ERROR recreating DB: $err"
		set ::DYE::GUI::db_progress_msg [translate "Failed to recreate DB:\r$err"]
		update
		after 3000 { set ::DYE::GUI::db_progress_msg "" }
		::DYE::GUI::enable_widgets {db_persist_series* rebuild_db* resync_db*} $ns
		borg spinner off
		borg systemui $::android_full_screen_flags
#		set ::DYE::DB::updating_db 0
		return		
	}
	if {[catch { ::DYE::DB::populate "" "" 1 } err] != 0} {
		msg "DYE DB: ERROR populating DB: $err"
		set ::DYE::GUI::db_progress_msg [translate "Failed to sync DB:\r$err"]
		update
		after 3000 { set ::DYE::GUI::db_progress_msg "" }
		::DYE::GUI::enable_widgets {db_persist_series* rebuild_db* resync_db*} $ns
		borg spinner off
		borg systemui $::android_full_screen_flags
		return				
	}
	
	::DYE::GUI::enable_widgets {db_persist_series* rebuild_db* resync_db*} $ns
	borg spinner off
	borg systemui $::android_full_screen_flags
	after 3000 { set ::DYE::GUI::db_progress_msg "" }
	say "" $::settings(sound_button_out)
}

proc ::DYE::CFG::resync_db {} {
	say "" $::settings(sound_button_in)
	set ns [namespace current]
	
	#set ::DYE::debug_text "updating_db=$::DYE::DB::updating_db"	
	if { $::DYE::DB::updating_db == 1 } {
		set ::DYE::CFG::data(db_status_msg) [translate "Database busy. Try later"]
		update
		after 3000 { set ::DYE::CFG::data(db_status_msg) "" }
		return
	}

	borg spinner on
	::DYE::GUI::disable_widgets {db_persist_series* rebuild_db* resync_db*} $ns
	
	if {[catch { ::DYE::DB::populate "" "" 1 } err] != 0} {
		msg "DYE DB: ERROR populating DB: $err"
		set ::DYE::GUI::db_progress_msg [translate "Failed to sync DB:\r$err"]
		update		
	}

	::DYE::GUI::enable_widgets {db_persist_series* rebuild_db* resync_db*} $ns
	borg spinner off
	borg systemui $::android_full_screen_flags
	after 3000 { set ::DYE::GUI::db_progress_msg "" }
	say "" $::settings(sound_button_out)
}

proc ::DYE::CFG::update_plugin_state {} {
	variable data
	variable widgets
	
	::DYE::GUI::enable_or_disable_widgets [expr !$data(plugin_has_been_updated)] update_plugin* [namespace current]
	if { $data(plugin_has_been_updated) == 1 } return
	
	.can itemconfig $widgets(update_plugin_state) -fill $::DYE::GUI::font_color
	set data(update_plugin_msg) ""
	
	if { [ifexists ::DYE::settings(github_latest_url) "" ] eq "" } {
		set data(update_plugin_state) [translate "No update URL"]
	} elseif { $::android == 1 && [borg networkinfo] eq "none" } {
		set data(update_plugin_state) [translate "No wifi"]		
	} else {
		lassign [::DYE::github_latest_release $::DYE::settings(github_latest_url)] \
			data(latest_plugin_version) data(latest_plugin_url) data(latest_plugin_desc)
		
#msg "DYE PLUGIN UPDATE - Comparing [lindex [package versions describe_your_espresso] 0] and $data(latest_plugin_version)"		
		if { $data(latest_plugin_version) == -1 } {
			set data(update_plugin_state) [translate "Error"]
			set data(update_plugin_msg) $data(latest_plugin_desc)
		} elseif { [package vcompare [lindex [package versions describe_your_espresso] 0] \
				$data(latest_plugin_version) ] >= 0 } {
			set data(update_plugin_state) [translate "Up-to-date"]
		} else {
			set data(update_plugin_state) "v$data(latest_plugin_version) [translate available]"
			.can itemconfig $widgets(update_plugin_state) -fill $::DYE::GUI::remark_color
			if { $data(latest_plugin_desc) ne "" } {
				set data(update_plugin_msg) "\[ [translate {What's new?}] \]"
			}
		}
	}
}

proc ::DYE::CFG::show_latest_plugin_description {} {
	variable data
	
	if { $data(latest_plugin_version) eq "" || $data(latest_plugin_version) == -1 || \
			$data(latest_plugin_desc) eq "" } return
	if { [package vcompare [lindex [package versions describe_your_espresso] 0] \
		$data(latest_plugin_version) ] >= 0 } return 
	
	::DYE::TXT::load_page "latest_plugin_desc" ::DYE::CFG::data(latest_plugin_desc) 1 \
		-page_title "[translate {What's new in DYE v}]$data(latest_plugin_version)"
}

proc ::DYE::CFG::update_plugin_click {} {
	variable data
	
	if { $data(latest_plugin_version) eq "" || $data(latest_plugin_version) == -1 } update_plugin_state
	if { $data(latest_plugin_version) eq "" || $data(latest_plugin_version) == -1 || \
			$data(latest_plugin_url) eq "" } return
	
	if { [package vcompare [lindex [package versions describe_your_espresso] 0] \
		$data(latest_plugin_version) ] >= 0 } return

	set update_result [::DYE::update_DSx_plugin_from_github $::DYE::plugin_file $data(latest_plugin_url)]
	if { $update_result == 1 } {
		set data(update_plugin_msg) "[translate {Plugin updated to v}]$data(latest_plugin_version)\r
[translate {Please quit and restart to load changes}]"
		set data(update_plugin_state) [translate "Up-to-date"]
		set data(plugin_has_been_updated) 1		
		update_plugin_state
		#set ::app_has_updated 1
	} else {
		set data(update_plugin_msg) [translate "Error downloading update"]
		set data(update_plugin_state) [translate "Error"]
	}
}

### GLOBAL STUFF AND STARTUP  #########################################################################################

# Backwards compatibility for versions before 1.34 that didn't have the "hide_android_keyboard" proc.
if { [package vcompare [lindex [package versions de1app] 0] 1.34] < 0 } {
	proc hide_android_keyboard {} {
		# make sure on-screen keyboard doesn't auto-pop up
		sdltk textinput off
		focus .can
	}
}

# This has to be here and not in its setup_ui function as it has to be invoked before DSx code for it to 
# get the configuration pages navigation buttons.
::DSx_plugin_page_name $::DYE::CFG::data(page_name)

# Ensure new metadata fields are initialized on the global settings on first use.
# This fails to create them for the first time if the code is on check_settings...
#foreach fn "drinker_name repository_links other_equipment"
foreach fn "drinker_name repository_links" {
	if { ! [info exists ::settings($fn)] } {
		set ::settings($fn) {}
	}
}

lappend ::run_after_startup ::DYE::main